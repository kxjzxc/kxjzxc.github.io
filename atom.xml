<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Kerke&#39;s Eden</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://kxjzxc.github.io/"/>
  <updated>2020-07-30T10:36:02.484Z</updated>
  <id>http://kxjzxc.github.io/</id>
  
  <author>
    <name>Kermit</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>【RPGMakerMV】滑冰谜题</title>
    <link href="http://kxjzxc.github.io/%E3%80%90RPGMakerMV%E3%80%91%E6%BB%91%E5%86%B0%E8%B0%9C%E9%A2%98.html"/>
    <id>http://kxjzxc.github.io/【RPGMakerMV】滑冰谜题.html</id>
    <published>2020-07-30T09:45:21.000Z</published>
    <updated>2020-07-30T10:36:02.484Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>project1论坛上已经有过<a href="https://mp.weixin.qq.com/s?__biz=MzIzMDA3ODg0NA==&amp;mid=501963472&amp;idx=1&amp;sn=d56bf38ff1f95e8b78d8366873fbd128&amp;chksm=70a71ac347d093d58e0479b0e6b3d7e3c4bffc968320597acdfa6b126ce445e7e103af421b7e#rd" target="_blank" rel="noopener">滑冰谜题</a>的教程了，但是这个教程里的滑冰谜题和我想要的不太一样。我想要做的是遇到障碍物才停止的效果，而并非离开冰面停止。<br>网上搜了搜，好像并没有教程，倒是看到有人说可以用YEP_SlipperyTiles插件完成，然而我没搞清楚这个插件的用法。因此最后就自己根据原先的那个教程改进了一下，得到了自己想要的效果。</p><h1 id="实现方法"><a href="#实现方法" class="headerlink" title="实现方法"></a>实现方法</h1><h2 id="地图设置"><a href="#地图设置" class="headerlink" title="地图设置"></a>地图设置</h2><p><img src="地图设置.png" alt="地图设置"></p><p>区域ID：2个</p><p>1：踩到就进入滑冰状态，向当前朝向前进一步。覆盖冰面。</p><p>2: 踩到就离开滑冰状态，恢复正常。放置于冰面出口</p><p>注意点：冰面四周要铺满无法通行的障碍物，因为$gamePlayer.isMapPassable()无法判定地图边界。</p><h2 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h2><p><strong>变量：3个</strong></p><p>001 玩家坐标X (地图坐标X)</p><p>002 玩家坐标Y (地图坐标Y)</p><p>003 玩家坐标区域ID</p><p><strong>开关：1个</strong></p><p>001 滑行</p><p><strong>公共事件：1个</strong><br>001 滑冰</p><p>！<a href="公共事件1.png">公共事件</a><br>！<a href="公共事件2.png">公共事件</a></p><p><strong>地图事件</strong><br>同样我们也要在地图里放一个并行事件调用滑冰公共事件</p>]]></content>
    
    <summary type="html">
    
       
    
    </summary>
    
      <category term="游戏" scheme="http://kxjzxc.github.io/categories/%E6%B8%B8%E6%88%8F/"/>
    
      <category term="RPGMaker" scheme="http://kxjzxc.github.io/categories/%E6%B8%B8%E6%88%8F/RPGMaker/"/>
    
    
      <category term="RPGMaker" scheme="http://kxjzxc.github.io/tags/RPGMaker/"/>
    
      <category term="游戏" scheme="http://kxjzxc.github.io/tags/%E6%B8%B8%E6%88%8F/"/>
    
      <category term="教程" scheme="http://kxjzxc.github.io/tags/%E6%95%99%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>HackingLab之脚本关攻略</title>
    <link href="http://kxjzxc.github.io/HackingLab%E4%B9%8B%E8%84%9A%E6%9C%AC%E5%85%B3%E6%94%BB%E7%95%A5.html"/>
    <id>http://kxjzxc.github.io/HackingLab之脚本关攻略.html</id>
    <published>2020-04-16T02:04:00.000Z</published>
    <updated>2020-04-16T02:40:08.031Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>开始脚本关的攻略！！<br>本次依旧无题目描述。<br><a herf="http://hackinglab.cn/">网络信息安全攻防学习平台</a></p><h1 id="第一关"><a href="#第一关" class="headerlink" title="第一关"></a>第一关</h1><p>这题不是跟基础关的第八题一样吗？使用的python代码也只用改一下url，key就直接出来了。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">import requests</span><br><span class="line">url = &quot;http://lab1.xseclab.com/xss1_30ac8668cd453e7e387c76b132b140bb/search_key.php&quot;</span><br><span class="line">r = requests.get(url,allow_redirects=False)</span><br><span class="line"># 请求获取URL位置的资源，包含从服务器返回的所有内容</span><br><span class="line">r.encoding = r.apparent_encoding</span><br><span class="line">r.encoding = &apos;utf-8&apos;</span><br><span class="line">print(r.text)</span><br></pre></td></tr></table></figure></p><blockquote><p>yougotit_script_now</p></blockquote><h1 id="第二关"><a href="#第二关" class="headerlink" title="第二关"></a>第二关</h1>]]></content>
    
    <summary type="html">
    
       
    
    </summary>
    
      <category term="计算机" scheme="http://kxjzxc.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
      <category term="Hack" scheme="http://kxjzxc.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/Hack/"/>
    
    
      <category term="Hack" scheme="http://kxjzxc.github.io/tags/Hack/"/>
    
  </entry>
  
  <entry>
    <title>关于u盘运行veket系统这件事</title>
    <link href="http://kxjzxc.github.io/%E5%85%B3%E4%BA%8Eu%E7%9B%98%E8%BF%90%E8%A1%8Cveket%E7%B3%BB%E7%BB%9F%E8%BF%99%E4%BB%B6%E4%BA%8B.html"/>
    <id>http://kxjzxc.github.io/关于u盘运行veket系统这件事.html</id>
    <published>2020-04-15T04:07:01.000Z</published>
    <updated>2020-04-15T15:14:20.941Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>上网冲浪时，我偶然了解到可以装在u盘里随身携带的轻量级操作系统。想到家里有一台硬盘损坏无法安装操作系统的老笔记本电脑，我琢磨着能否通过这类操作系统让这台老家伙摆脱被贱卖的命运。</p><h1 id="所需工具"><a href="#所需工具" class="headerlink" title="所需工具"></a>所需工具</h1><ul><li><strong>轻量级Linux系统veket</strong><br>veket是一个容量很小，资源要求很低，同时集成了大部分常用软件的操作系统。更重要的是，该系统的图形界面接近于windows，长辈容易操作。</li><li><strong>YUMI MulitbootUSB</strong><br>其实只要一种讲iso镜像文件写入u盘的工具就好了，常用的软碟通就行。我选择这个工具主要是因为我本来想搞多重引导的u盘。</li><li><strong>8G的U盘</strong><br>一个不小于4G的U盘就够用了，毕竟veket才500M左右。</li><li><strong>一台老电脑</strong><br>最好还是内存不小于2G吧（1G似乎也行？）。</li></ul><h1 id="使用过程"><a href="#使用过程" class="headerlink" title="使用过程"></a>使用过程</h1><p>其实安装过程也没甚好写的，毕竟这玩意比普通安装系统还要简单，我就随便水水流程好了。</p><ol><li>通过YUMI工具将veket的iso镜像文件写入U盘。由于使用的工具可能不大一样，所以我就不写具体操作了。</li><li>进入老电脑的BIOS界面，将电脑设置成优先USB方式启动。不同电脑的设置方式不同，不过网上一般都有教程。</li><li>将U盘插入老电脑，再次开机，进入启动界面。一般来说全选择第一个选项就好，除非使用者有其他用途。</li><li>如此便可以使用了。不过veket系统需要注意的是第一次关机时，系统会询问你是否保存数据。如果使用者没有保存数据的需求（比如只是为了体验），那么选择不保存即可。如果先要保存数据，也只需要安装提示一步一步来（以后就不用了）。</li></ol><p>若有什么地方不太明白，可以到<a href="http://www.lucky8k.com/forum.php" target="_blank" rel="noopener">veket的论坛</a>上逛一逛。</p><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>挺水的一篇教程，主要目的也只是记录一下使用的工具。<br>以前发现笔记本的硬盘损坏后，我也想过直接使用Ubuntu启动盘里的试用系统，然而连个视频都看不了就放弃了。如今使用veket系统后，虽然长时间使用的话电脑还是会卡死（硬伤，莫得办法），但是好歹平时用得还是挺流畅的。<br>其实我本来是在纠结到底选择CDLinux还是veket的，后来想着全都要算了，结果发现CDLinux不知道为何写入不了U盘，只能作罢。所以我的多引导系统U盘并没能完成，着实感到遗憾。</p>]]></content>
    
    <summary type="html">
    
       
    
    </summary>
    
      <category term="教程" scheme="http://kxjzxc.github.io/categories/%E6%95%99%E7%A8%8B/"/>
    
    
      <category term="教程" scheme="http://kxjzxc.github.io/tags/%E6%95%99%E7%A8%8B/"/>
    
      <category term="Linux" scheme="http://kxjzxc.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>HackingLab之基础关攻略</title>
    <link href="http://kxjzxc.github.io/HackingLab%E4%B9%8B%E5%9F%BA%E7%A1%80%E5%85%B3%E6%94%BB%E7%95%A5.html"/>
    <id>http://kxjzxc.github.io/HackingLab之基础关攻略.html</id>
    <published>2020-04-07T09:58:05.000Z</published>
    <updated>2020-04-08T03:40:19.638Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>作为一无所知的小白，我仅仅是将此作为摸鱼时的一种解谜游戏看待，因此不会事先去恶补过多的知识，遇到盲点也会果断放弃，上网查攻略，毕竟乐趣作为重要。</p><p>每一关的解法并不唯一，可以用抓包工具，也可以只用python，我的想法是能写多少写多少方法。题目什么的我也懒得复制粘贴了，毕竟没有意义。</p><p><a herf="http://hackinglab.cn/">攻防平台</a></p><h1 id="闯关"><a href="#闯关" class="headerlink" title="闯关"></a>闯关</h1><h2 id="第一关"><a href="#第一关" class="headerlink" title="第一关"></a>第一关</h2><p>讲道理，看到题目就想到查看源代码。直接F12，答案写在注释里。</p><blockquote><p>jflsjklejflkdsjfklds</p></blockquote><h2 id="第二关"><a href="#第二关" class="headerlink" title="第二关"></a>第二关</h2><p>密文再加密一次又变回明文，既然全是小写字母，就很容易想到与13位后的对应字母替换。查询可知这种加密算法叫做Rot13。</p><blockquote><p>23ksdjfkfds</p></blockquote><h2 id="第三关"><a href="#第三关" class="headerlink" title="第三关"></a>第三关</h2><p>大致看一下密文，发现最后一位是特殊字符“=”，搜索一下与等号有关的加密算法，查到base64算法。在线解密，最终可以得到key。</p><blockquote><p>jkljdkl232jkljkdl2389</p></blockquote><h2 id="第四关"><a href="#第四关" class="headerlink" title="第四关"></a>第四关</h2><p>既然题目都说了MD5，何不一试？</p><blockquote><p>bighp</p></blockquote><h2 id="第五关"><a href="#第五关" class="headerlink" title="第五关"></a>第五关</h2><p>小白没什么思路，搜索关键字无果，于是看攻略。修改请求头中的Accept-Language参数。<br>这意思就是根据语言判断是否是外国人呗……<br><strong>方法一：</strong><br>直接修改浏览器的语言，把中文删去。<br><strong>方法二：</strong><br>用python的request库伪造请求头的Accept-Language参数，然后访问网址，并打印响应内容。<br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line">url = <span class="string">"http://lab1.xseclab.com/base1_0ef337f3afbe42d5619d7a36c19c20ab/index.php"</span></span><br><span class="line">headers = &#123;<span class="string">'Accept-Language'</span>: <span class="string">'q=0.5,en-US;q=0.3,en;q=0.2'</span>&#125;<span class="comment">#伪造请求头参数</span></span><br><span class="line">r = requests.get(url,headers=headers)<span class="comment"># 请求获取URL位置的资源，包含从服务器返回的所有内容</span></span><br><span class="line">r.encoding = r.apparent_encoding</span><br><span class="line">r.encoding = <span class="string">'utf-8'</span></span><br><span class="line">print(r.text)</span><br></pre></td></tr></table></figure></p><blockquote><p><em>(TU687jksf6&amp;</em></p></blockquote><h2 id="第六关"><a href="#第六关" class="headerlink" title="第六关"></a>第六关</h2><p>搜索引擎搜索关键字，发现似乎与“User-Agent”这个属性有关。F12到Network观察请求头，找到该属性，后面参数可以明显看出和浏览器相关，或许修改此处即可。<br><strong>方法一（以Chrome为准）：</strong><br>F12打开开发者工具，点击右上方三个点，点击<code>More Tools</code>-&gt;<code>Network conditions</code>，直接修改User-Agent的值。<br><strong>方法二：</strong><br>用python的request库伪造请求头的User-Agent参数，然后访问网址，并打印响应内容。<br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line">url = <span class="string">"http://lab1.xseclab.com/base6_6082c908819e105c378eb93b6631c4d3/index.php"</span></span><br><span class="line">headers = &#123;<span class="string">'User-Agent'</span>:<span class="string">'HAHA'</span>&#125;</span><br><span class="line">r = requests.get(url,headers=headers)</span><br><span class="line"><span class="comment"># 请求获取URL位置的资源，包含从服务器返回的所有内容</span></span><br><span class="line">r.encoding = r.apparent_encoding</span><br><span class="line">r.encoding = <span class="string">'utf-8'</span></span><br><span class="line">print(r.text)</span><br></pre></td></tr></table></figure></p><blockquote><p>meiyouHAHAliulanqi</p></blockquote><h2 id="第七关"><a href="#第七关" class="headerlink" title="第七关"></a>第七关</h2><p>没什么想法，看攻略说是藏在响应头里。<br><strong>方法一：</strong><br>F12到开发者工具查看Network里的响应头，就看到答案了。<br><strong>方法二：</strong><br>用python的request库申请资源，打印响应头。<br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line">url = <span class="string">"http://lab1.xseclab.com/base7_eb68bd2f0d762faf70c89799b3c1cc52/index.php"</span></span><br><span class="line">r = requests.get(url)</span><br><span class="line"><span class="comment"># 请求获取URL位置的资源，包含从服务器返回的所有内容</span></span><br><span class="line">r.encoding = r.apparent_encoding</span><br><span class="line">r.encoding = <span class="string">'utf-8'</span></span><br><span class="line">print(r.headers)</span><br></pre></td></tr></table></figure></p><blockquote><p>kjh%#$#%FDjjj</p></blockquote><h2 id="第八关"><a href="#第八关" class="headerlink" title="第八关"></a>第八关</h2><p>将鼠标放在超链接“_到这里找key__”上时，发现左下角显示链接与点击链接后的网址不同，可知发生了重定向。<br>搜索浏览器如何阻止重定向，方法无效。<br>搜索python的request库访问如何阻止重定向，找到解决方法，只需再get函数中添加属性<code>allow_redirects=False</code>即可。注意申请的链接是超链接显示的链接。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line">url = <span class="string">"http://lab1.xseclab.com/base8_0abd63aa54bef0464289d6a42465f354/search_key.php"</span></span><br><span class="line">r = requests.get(url,allow_redirects=<span class="literal">False</span>)</span><br><span class="line"><span class="comment"># 请求获取URL位置的资源，包含从服务器返回的所有内容</span></span><br><span class="line">r.encoding = r.apparent_encoding</span><br><span class="line">r.encoding = <span class="string">'utf-8'</span></span><br><span class="line">print(r.text)</span><br></pre></td></tr></table></figure><p><img src="./HackingLab之基础关攻略/第八关.png" alt="响应内容"><br>可以得到一个网址<a herf="http://lab1.xseclab.com/base8_0abd63aa54bef0464289d6a42465f354/key_is_here_now_.php">./key_is_here_now_.php</a></p><blockquote><p>ohHTTP302dd</p></blockquote><h2 id="第九关"><a href="#第九关" class="headerlink" title="第九关"></a>第九关</h2><p>搜索关键字，发现登录信息与cookie有关，并且发现测试网址使用了一个名为“Login”的cookie。<br>F12到Network查看请求头，发现参数<code>Cookie:Login=0</code>,于是尝试用python的request库伪造请求头的Cookie参数，使Login=1，然后访问网址，并打印响应内容，得到答案。<br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line">url = <span class="string">"http://lab1.xseclab.com/base9_ab629d778e3a29540dfd60f2e548a5eb/index.php"</span></span><br><span class="line">headers = &#123;<span class="string">'Cookie'</span>:<span class="string">'Login=1'</span>&#125;</span><br><span class="line">r = requests.get(url,headers=headers)</span><br><span class="line"><span class="comment">#r = requests.post(url,data=&#123;'v':'111111'&#125;)</span></span><br><span class="line"><span class="comment"># 请求获取URL位置的资源，包含从服务器返回的所有内容</span></span><br><span class="line">r.encoding = r.apparent_encoding</span><br><span class="line">r.encoding = <span class="string">'utf-8'</span></span><br><span class="line">print(r.text)</span><br></pre></td></tr></table></figure></p><blockquote><p>yescookieedit7823789KJ</p></blockquote><h2 id="第十关"><a href="#第十关" class="headerlink" title="第十关"></a>第十关</h2><p>发现只能输入3位数字，而999依旧显示太小。<br>F12查看源代码，发现标签属性中限制了输入长度。<br><strong>方法一</strong><br>直接F12在开发者工具里修改源代码，使之能够输入一个极大的数，直接得出答案。<br><strong>方法二</strong><br>用python提交不受标签限制<br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line">url = <span class="string">"http://lab1.xseclab.com/base10_0b4e4866096913ac9c3a2272dde27215/index.php"</span></span><br><span class="line">r = requests.post(url,data=&#123;<span class="string">'v'</span>:<span class="string">'111111'</span>&#125;)</span><br><span class="line"><span class="comment"># 请求获取URL位置的资源，包含从服务器返回的所有内容</span></span><br><span class="line">r.encoding = r.apparent_encoding</span><br><span class="line">r.encoding = <span class="string">'utf-8'</span></span><br><span class="line">print(r.text)</span><br></pre></td></tr></table></figure></p><blockquote><p>768HKyu678567&amp;*&amp;K</p></blockquote><h2 id="第十一关"><a href="#第十一关" class="headerlink" title="第十一关"></a>第十一关</h2><p>题目崩了，答案就直接放在源代码注释里了。</p><blockquote><p>^&amp;*(UIHKJjkadshf</p></blockquote><h2 id="第十二关"><a href="#第十二关" class="headerlink" title="第十二关"></a>第十二关</h2><p>没有思路，上网查攻略，发现与robots协议有关，虽然不知道是怎么想到的……</p><blockquote><p>robots协议也叫robots.txt（统一小写）是一种存放于网站根目录下的ASCII编码的文本文件，它通常告诉网络搜索引擎的漫游器（又称网络蜘蛛），此网站中的哪些内容是不应被搜索引擎的漫游器获取的，哪些是可以被漫游器获取的。</p></blockquote><p>既然如此，就直接访问<a href="http://lab1.xseclab.com/base12_44f0d8a96eed21afdc4823a0bf1a316b/robots.txt" target="_blank" rel="noopener">./robots.txt</a>,看到<code>Disallow: /9fb97531fe95594603aff7e794ab2f5f/</code>。<br>于是访问<a href="http://lab1.xseclab.com/base12_44f0d8a96eed21afdc4823a0bf1a316b/9fb97531fe95594603aff7e794ab2f5f/" target="_blank" rel="noopener">该网址</a>,得到提示说此页面不是登陆页面，继续搜索。<br>一般来说登录页面就是在网址后面加<code>/login.php</code>，尝试，成功看到答案。</p><blockquote><p>UIJ%%IOOqweqwsdf</p></blockquote><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>至此，基础十二关便结束了。<br>虽然总是在上网查攻略，但依旧乐趣不减，毕竟都是我没接触过的东西。<br>感觉学到了不少东西，作为娱乐方式，还是很赚的。<br>以后可能补上抓包工具的解法。</p>]]></content>
    
    <summary type="html">
    
       
    
    </summary>
    
      <category term="计算机" scheme="http://kxjzxc.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
      <category term="Hack" scheme="http://kxjzxc.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/Hack/"/>
    
    
      <category term="Hack" scheme="http://kxjzxc.github.io/tags/Hack/"/>
    
  </entry>
  
  <entry>
    <title>最优停止理论——如何适“可”而止</title>
    <link href="http://kxjzxc.github.io/%E6%9C%80%E4%BC%98%E5%81%9C%E6%AD%A2%E7%90%86%E8%AE%BA%E2%80%94%E2%80%94%E5%A6%82%E4%BD%95%E9%80%82%E2%80%9C%E5%8F%AF%E2%80%9D%E8%80%8C%E6%AD%A2.html"/>
    <id>http://kxjzxc.github.io/最优停止理论——如何适“可”而止.html</id>
    <published>2020-02-22T14:07:05.000Z</published>
    <updated>2020-02-22T16:10:50.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h1><p>本文主要从最优停止问题出发，介绍了麦穗问题和经典的秘书问题以及面对此类问题采取的策略。本文还根据该策略推导并验证了37%法则的正确性，并且简单分析了该法则的适用性。</p><h1 id="理论介绍"><a href="#理论介绍" class="headerlink" title="理论介绍"></a>理论介绍</h1><p>中国有一句古话，叫做适可而止，其意思是到适当的程度就停下来，不要过头。生活中处处需要抉择判断，像是买衣服，挑选伴侣等，而这些问题都需要运用适可而止的思想，否则将确定最终选择，因为我们永远不知道最好的将什么时候出现。但是适可而止的“可”又是什么呢？当我们面对无穷无尽的选择时，有如何知道当前选择是否为“可”呢？在进入正文之前，先让我们听一个小故事。</p><p>传说中古希腊哲学大师苏格拉底的3个弟子曾求教老师，怎样才能找到理想的伴侣。于是苏格拉底带领弟子们来到一片麦田，让他们每人在麦田中选摘一支最大的麦穗，并且要求不能走回头路，且只能摘一支。</p><p>面对老师的要求，三个弟子分别做出了不同的举动。第一个弟子刚刚走了几步便迫不及待地摘了一支自认为是最大的麦穗，结果发现后面的大麦穗多的是；第二位一直左顾右盼，东瞧西望，直到终点才发现，前面最大的麦穗已经错过了；第三位弟子把麦田分为三份，走第一个1/3时，只看不摘，分出大、中、小三类麦穗，在第二个1/3里验证是否正确，在第三个1/3里选择了麦穗中最大最美丽的一支，这就是所谓的麦穗理论。</p><p>为什么第三位弟子能够获得比较满意的结果呢？因为他在选择的过程中采用了一定的策略，即将决策过程分为两段：前2/3的路程用于确定“最基本的满意标准”，最后1/3选择满足“最基本的满意标准”的第一个方案。这里的两段可以是把全部可选方案在数量上分成两段来考察，也可以是把选择时间分成两段。</p><p>麦穗理论实际上要解决的是一种“最优停止问题”。这种问题一般有两个特点：<strong>我们并不清楚我们会遇到什么样的可选方案，只有看过了才知道，即未来不可知，但一个可选方案一旦被错过了不能再回头去选，即不能反悔。</strong>生活中其实很多事情都是类似的问题，麦穗理论里的找到理想伴侣、买房子、换工作等等。</p><p>所以有一个观望的“最优停止”的时间点，也因此这类问题被称为<strong>“最优停止问题”</strong>。</p><p>秘书问题（Secretary problem）是最优停止问题中最著名的一类难题，在不同的地方它也被称作相亲问题、止步问题、见好就收问题、苏丹的嫁妆问题、挑剔的求婚者问题等。该问题的内容是这样的：假设你是面试官，要聘请一名秘书，一共有 n 个应聘者来面试。你按照随机顺序，每次面试一名申请人。你随时可以决定将这份工作交给其中一人，而对方只能接受，于是面试工作就此结束。但是，一旦你否决其中一名申请人，就不能改变主意再回头选择他。面试后总能清楚了解应聘者的合适程度，并能和之前的每个人做比较。问什么样的策略，才使最佳人选被选中的概率最大。</p><p>面对这类问题，Merrill M. Flood在1949年首次提出37%法则。他所采取的的策略类似于上述苏格拉底的第三位弟子的决策：首先对前面一部分面试者，无论优秀与否都直接拒绝，只考察目标，收集数据，用于确定“最基本的满意标准”。然后对剩下的人进行面试，如果遇到一位比之前面试的人都优秀的面试者，那么就立即出手，直接聘请这个人，否则就继续面试。</p><p>在麦穗问题中，那位弟子选择将前2/3的麦穗用于确定“最基本的满意标准”。但是这不一定是最优秀的决策。为了提高我们获得最优结果的概率的时候，我们需要找到最合适的样本量用于制定比较的标准。通过计算，Flood发现37%是一个最优停止点，也就是说选择前37%的人直接拒绝时，得到最适合担任秘书的人的概率最大。</p><h1 id="理论证明"><a href="#理论证明" class="headerlink" title="理论证明"></a>理论证明</h1><p>那么37%是如何推导出来的呢？</p><p>假设事件<script type="math/tex">A_k</script>为第 k 个人被选中，事件<script type="math/tex">B_k</script>为第 k 个人是最优秀的，事件<script type="math/tex">C_r</script>为前 r 名面试者用于确定标准时选到最优秀应聘者，其中<script type="math/tex">1 \le r < k \le n,r \in Z, k \in Z</script>。则选到最优秀的应聘者的概率： </p><script type="math/tex; mode=display">P(C_r)=\sum P(A_kB_k)=\sum\limits_{k=1}^{n} P(B_k)P(A_k|B_k)=\frac{1}{n}\sum\limits_{k=1}^{n} P(A_k|B_k)\qquad (1)</script><p>因为前 r 个人必然会被拒绝，所以<script type="math/tex">P(A_k|B_k)=0,k\le r</script> 。又因为当第 k 个人被选择时，第 k个人前最优秀的人必然在前 r 个人当中，所以 <script type="math/tex">P(A_k|B_k)=\frac{r}{k-1},k>r</script> 。因此式（1）可化简为： </p><script type="math/tex; mode=display">P(C_r)=\frac{1}{n}\sum\limits_{k=r+1}^{n} P(A_k|B_k)=\frac{1}{n}\sum\limits_{k=r+1}^{n} \frac{r}{k-1}=\frac{r}{n}\sum\limits_{k=r+1}^{n} \frac{1}{k-1}\qquad (2)</script><p>因为我们需要选出最优的决策，所以前 r 名面试者用于确定标准时选择到最优秀的应聘者的概率必须为最大，即<script type="math/tex">P(C_{r-1})\le P(C_r)\ge P(C_{r+1})</script>。</p><p>通过计算机程序枚举 n 为 1~10000 时，选取的 r 的值，并选取部分数据记录于下表。</p><div class="table-container"><table><thead><tr><th style="text-align:center">n</th><th style="text-align:center">r</th><th style="text-align:center"><script type="math/tex">\frac{r}{n}</script></th><th style="text-align:center"><script type="math/tex">P(C_r)</script></th></tr></thead><tbody><tr><td style="text-align:center">3</td><td style="text-align:center">1</td><td style="text-align:center">0.333333</td><td style="text-align:center">0.5</td></tr><tr><td style="text-align:center">4</td><td style="text-align:center">1</td><td style="text-align:center">0.25</td><td style="text-align:center">0.458333</td></tr><tr><td style="text-align:center">5</td><td style="text-align:center">2</td><td style="text-align:center">0.4</td><td style="text-align:center">0.433333</td></tr><tr><td style="text-align:center">10</td><td style="text-align:center">3</td><td style="text-align:center">0.3</td><td style="text-align:center">0.39869</td></tr><tr><td style="text-align:center">100</td><td style="text-align:center">37</td><td style="text-align:center">0.37</td><td style="text-align:center">0.371043</td></tr><tr><td style="text-align:center">1000</td><td style="text-align:center">368</td><td style="text-align:center">0.368</td><td style="text-align:center">0.368196</td></tr><tr><td style="text-align:center">10000</td><td style="text-align:center">3679</td><td style="text-align:center">0.3679</td><td style="text-align:center">0.3679</td></tr></tbody></table></div><p>当 n 无限接近于<script type="math/tex">\infty</script>时，<script type="math/tex">P(C_r)</script> 变为积分形式，即式（2）变为：</p><script type="math/tex; mode=display">P(C_r)=\frac{r}{n}\sum\limits_{k=r+1}^{n} \frac{1}{k-1}\approx\frac{r}{n}\int\nolimits_{r}^{n-1} \frac{1}{x}dx=\frac{r}{n}\ln(\frac{n-1}{r})\approx\frac{r}{n}\ln(\frac{n}{r})\qquad (3)</script><p>令函数<script type="math/tex">f(r)=P(C_r)</script> ，所以我们需要所求的<script type="math/tex">r_0</script>为<script type="math/tex">f (r)</script>的最大极值点，即<script type="math/tex">f'(r_0)=0</script> ，此时可得<script type="math/tex">r_0=\frac{n}{e}</script>。已知<script type="math/tex">\frac{1}{e}\approx 0.36788\approx 37%</script>，因此计算结果符合要求。</p><h1 id="验证代码"><a href="#验证代码" class="headerlink" title="验证代码"></a>验证代码</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> oo 1e9+7</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">freopen(<span class="string">"test.txt"</span>,<span class="string">"w"</span>,<span class="built_in">stdout</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">10000</span>;i++)&#123;</span><br><span class="line"><span class="keyword">double</span> maxp=<span class="number">0</span>,temp=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> maxr=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;i;j++)temp+=<span class="number">1.0</span>/j;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=i;j++)&#123;</span><br><span class="line"><span class="keyword">double</span> pj=<span class="number">1.0</span>*j/i;</span><br><span class="line">pj*=temp;</span><br><span class="line"><span class="keyword">if</span>(pj&gt;maxp)&#123;</span><br><span class="line">maxp=pj;</span><br><span class="line">maxr=j;</span><br><span class="line">&#125;</span><br><span class="line">temp-=<span class="number">1.0</span>/j;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;i&lt;&lt;<span class="string">" "</span>&lt;&lt;maxr&lt;&lt;<span class="string">" "</span>&lt;&lt;<span class="number">1.0</span>*maxr/i&lt;&lt;<span class="string">" "</span>&lt;&lt;maxp&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">fclose(<span class="built_in">stdout</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>37%法则还可以用于生活中有很多类似于秘书问题的问题，像是如何选择自己的伴侣，如何决定投资的项目，如何选择停车位等可化简为最优停止问题的问题。在所有最优停止问题中，最大的难点不在于选择哪一种可选方案，而是确定自己需要考虑多少种可选方案。</p><p>最优停止问题的权威教科书开宗明义地指出:“最优停止理论关注的是如何选择时机以执行特定行动的问题。”秘书问题最基本同时也最令人难以置信的前提条件——严格的连续性，即有进无退的单向行进，正好是时间自身属性的一个体现。生活中我们做出决定的时候，往往具有时间上的不可挽回性，你永远无法回到过去去重新做出选择，我们没有二次选择机会，如何适可而止，在合适的时间停止观察做出选择，这是非常重要的问题。</p><p>需要注意的是，37%法则选到的并不一定是最优方案，而是接近于最优的满意方案。还有的时候可能找到最优并不可能，或者代价极大。在这种情况下，我们要能接受“满意”。而且当最优的方案出现在前37%的时候，你会发现37%法则也无法找出满意的方案。因此在生活中，我们需要灵活的应用37%法则，结合自己的经验，寻找到那个令人满意的“可”之所在。</p><h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><p>[1]    约翰尼斯·开普勒  算法之美：指导工作与生活的算法<br>[2]    维基百科 秘书问题<br>[3]    听风临山  生活中一定会用到的数学常识：37%法则</p>]]></content>
    
    <summary type="html">
    
       
    
    </summary>
    
      <category term="杂" scheme="http://kxjzxc.github.io/categories/%E6%9D%82/"/>
    
    
      <category term="杂" scheme="http://kxjzxc.github.io/tags/%E6%9D%82/"/>
    
      <category term="概率" scheme="http://kxjzxc.github.io/tags/%E6%A6%82%E7%8E%87/"/>
    
  </entry>
  
  <entry>
    <title>基于C++的最优化算法——遗传算法</title>
    <link href="http://kxjzxc.github.io/%E5%9F%BA%E4%BA%8EC++%E7%9A%84%E6%9C%80%E4%BC%98%E5%8C%96%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94%E9%81%97%E4%BC%A0%E7%AE%97%E6%B3%95.html"/>
    <id>http://kxjzxc.github.io/基于C++的最优化算法——遗传算法.html</id>
    <published>2020-01-17T14:44:07.000Z</published>
    <updated>2020-01-17T15:16:06.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="要求"><a href="#要求" class="headerlink" title="要求"></a>要求</h1><p>基于抽象优化类 optimizer，编写自己的派生优化类，实现多元方程未知数计算</p><h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><p>最优化算法有许多，像是模拟退火、遗传算法、粒子群算法等等，而我使用的是最优化算法中的遗传算法。</p><h2 id="算法原理"><a href="#算法原理" class="headerlink" title="算法原理"></a>算法原理</h2><p>遗传算法是一类借鉴生物界的进化规律演化而来的随机化搜索方法。其主要特点是直接对结构对象进行操作，不存在求导和函数连续性的限定；具有内在的隐并行性和更好的全局寻优能力；采用概率化的寻优方法，能自动获取和指导优化的搜索空间，自适应地调整搜索方向，不需要确定的规则。</p><p>在理解遗传算法的基本原理之前，先了解一下几个概念：</p><ol><li>个体：一个个体就是一组可能解。将可能解通过编码产生一组数组，即个体的染色体。</li><li>种群：个体的集合。</li><li>适应度：度量某个物种对于生存环境的适应程度。</li><li>选择：产生一代新的子种群后，基于个体的适应度对种群里的个体进行优胜劣汰。</li><li>交叉：以一定的概率将一对染色体的某一段基因进行交换。</li><li>变异：以一定的概率使染色体的某一基因发生改变。</li></ol><p>于是我们对每一代父种群的染色体进行筛选、交叉和变异操作，产生下一代子种群。通过种群的不断遗传与淘汰，最终能够进化出最优解。在算法初始阶段，我们首先随机创建一个包含多个个体的种群，然后对于这个种群，循环进行以下操作，直到完成设置的进化次数：</p><ol><li>评估每条染色体所对应个体的适应度。</li><li>遵照适应度越高，选择概率越大的原则，从种群中选择两个个体作为<br>父方和母方。</li><li>抽取父母双方的染色体，进行交叉，产生子代。</li><li>对子代的染色体进行变异。</li></ol><p><img src="基于C++的最优化算法——遗传算法/遗传算法.png" alt="遗传算法"><br>我讲的还是比较简略的，详情请见<a href="https://www.jianshu.com/p/ae5157c26af9" target="_blank" rel="noopener">这篇博客</a></p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>编码：这份代码中以一组x解为一个个体。</p><p>选择函数：轮盘度选择</p><blockquote><p>轮盘赌选择（Roulette Wheel Selection）：是一种回放式随机采样方法。每个个体进入下一代的概率等于它的适应度值与整个种群中个体适应度值和的比例。选择误差较大。</p></blockquote><p>交叉方式：单点交叉</p><blockquote><p>单点交叉（One-point Crossover）：指在个体编码串中只随机设置一个交叉点，然后再该点相互交换两个配对个体的部分染色体。</p></blockquote><p>变异方式：基因以一定概率在±Xrn的领域内浮动，Xrn以类似退火的方式减小。</p><p><strong>个体类头文件</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> _SI_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _SI_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"string"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"opt1.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdlib.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"time.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Xr 3.0f</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Xl -3.0f<span class="comment">//答案范围</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 个体类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> cnt=<span class="number">0</span>;</span><br><span class="line"><span class="comment">//模板函数，用于生成各种区间上的数据类型</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function">T <span class="title">randT</span><span class="params">(T Lower, T Upper)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> rand() / (<span class="keyword">double</span>)RAND_MAX *(Upper - Lower) + Lower;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SpeciesIndividual</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">double</span> *genes;<span class="comment">//基因序列</span></span><br><span class="line"><span class="keyword">double</span> error;<span class="comment">//误差</span></span><br><span class="line"><span class="keyword">double</span> fitness;<span class="comment">//适应度</span></span><br><span class="line"><span class="keyword">double</span> rate;</span><br><span class="line"><span class="keyword">int</span> xnum;</span><br><span class="line"><span class="comment">//构造函数</span></span><br><span class="line">SpeciesIndividual()&#123;&#125;</span><br><span class="line">SpeciesIndividual(<span class="keyword">int</span> xd)&#123;</span><br><span class="line">xnum=xd;</span><br><span class="line">genes=<span class="keyword">new</span> <span class="keyword">double</span>[xnum];</span><br><span class="line">fitness=<span class="number">0.0f</span>;</span><br><span class="line">error=<span class="number">0.0f</span>;</span><br><span class="line">rate=<span class="number">0.0f</span>;</span><br><span class="line">createByRandomGenes();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">~SpeciesIndividual()&#123;</span><br><span class="line">        <span class="keyword">delete</span>[] genes;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//初始物种基因（随机） 基因直接用x序列编码</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">createByRandomGenes</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;xnum;i++)&#123;</span><br><span class="line">genes[i]=randT(Xl,Xr);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//void createByGreedyGenes();//初始物种基因（贪心）</span></span><br><span class="line"></span><br><span class="line">SpeciesIndividual &amp;<span class="keyword">operator</span> = (SpeciesIndividual <span class="keyword">const</span> &amp;species)&#123;</span><br><span class="line">xnum=species.xnum;</span><br><span class="line">    <span class="keyword">double</span> *genestmp=<span class="keyword">new</span> <span class="keyword">double</span>[species.xnum];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;xnum;i++)&#123;</span><br><span class="line">genestmp[i]=species.genes[i];</span><br><span class="line">        &#125;</span><br><span class="line">error=species.error;</span><br><span class="line">fitness=species.fitness;</span><br><span class="line">rate=species.rate;</span><br><span class="line"><span class="keyword">delete</span>[] genes;</span><br><span class="line">genes=genestmp;</span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span> == (SpeciesIndividual <span class="keyword">const</span> &amp;species)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;xnum;i++)</span><br><span class="line"><span class="keyword">if</span>(genes[i]!=species.genes[i])<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure></p><p><strong>优化程序</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> _OPT_1_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _OPT_1_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"optimizer.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"SpeciesIndividual.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdlib.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"time.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"math.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"iostream"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"algorithm"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DEVELOP_NUM 3000<span class="comment">//进化次数</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pcl 0.6f</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pch 0.95f<span class="comment">//交叉概率</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pm 0.1f<span class="comment">//变异概率</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> oo 1e9+7</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> delta 0.98</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SPECIES_MAXNUM 500<span class="comment">//种群最大数量</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SPECIES_NUM 80 <span class="comment">//种群数量</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line">SpeciesIndividual population[SPECIES_MAXNUM];<span class="comment">//父种群</span></span><br><span class="line">SpeciesIndividual subPopulation[SPECIES_MAXNUM];<span class="comment">//子种群</span></span><br><span class="line"><span class="keyword">int</span> speciesNum=<span class="number">0</span>;<span class="comment">//父种群个体数量</span></span><br><span class="line"><span class="keyword">int</span> subSpeciesNum=<span class="number">0</span>;<span class="comment">//子种群个体数量</span></span><br><span class="line"><span class="keyword">double</span> Temp=<span class="number">1</span>;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 遗传算法</span></span><br><span class="line"><span class="comment"> * 包含：</span></span><br><span class="line"><span class="comment"> * 1.run 开始跑算法</span></span><br><span class="line"><span class="comment"> * 2.createBeginningSpecies 创建种群</span></span><br><span class="line"><span class="comment"> * 3.calRate 计算每一种物种被选中的概率</span></span><br><span class="line"><span class="comment"> *      4.select  轮盘策略 选择适应度高的物种</span></span><br><span class="line"><span class="comment"> *      5.crossover 染色体交叉</span></span><br><span class="line"><span class="comment"> *      6.mutate 染色体变异</span></span><br><span class="line"><span class="comment"> *      7.getBest 获得适应度最大的物种</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">opt1</span>:</span> <span class="keyword">public</span> optimizer</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Swap</span><span class="params">(T &amp;a,T &amp;b)</span></span>&#123;</span><br><span class="line">T tmp=a;</span><br><span class="line">a=b;</span><br><span class="line">b=tmp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">SpeciesIndividual <span class="title">getBest</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">double</span> error=oo;</span><br><span class="line"><span class="function">SpeciesIndividual <span class="title">bestSpecies</span><span class="params">(xd)</span></span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;speciesNum;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(error&gt;population[i].error)&#123;</span><br><span class="line">bestSpecies=population[i];</span><br><span class="line">error=bestSpecies.error;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> bestSpecies;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//创建初始种群</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">createBeginningSpecies</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> randNum=SPECIES_NUM;</span><br><span class="line">speciesNum=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;randNum;i++)&#123;</span><br><span class="line"><span class="function">SpeciesIndividual <span class="title">species</span><span class="params">(xd)</span></span>;</span><br><span class="line">population[speciesNum++]=species;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//计算每一物种被选中的概率</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">calcRate</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//计算总误差</span></span><br><span class="line"><span class="keyword">double</span> totalERR=<span class="number">0.0f</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;speciesNum;i++)&#123;</span><br><span class="line">population[i].error=fun(population[i].genes,y);<span class="comment">//计算误差</span></span><br><span class="line">totalERR+=population[i].error;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//计算总适应度</span></span><br><span class="line"><span class="keyword">double</span> totalfitness=<span class="number">0.0f</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;speciesNum;i++)&#123;</span><br><span class="line">population[i].fitness=totalERR/population[i].error;<span class="comment">//计算适应度</span></span><br><span class="line">totalfitness+=population[i].fitness;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//计算选中概率</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;speciesNum;i++)&#123;</span><br><span class="line">population[i].rate=population[i].fitness/totalfitness;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//选择优秀物种（轮盘赌）</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">select</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//找出最大适应度物种</span></span><br><span class="line">SpeciesIndividual talentSpecies=getBest();</span><br><span class="line"><span class="comment">//将最大适应度物种复制talentNum个</span></span><br><span class="line"><span class="keyword">int</span> talentNum=(<span class="keyword">int</span>)(speciesNum/<span class="number">4</span>)+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;talentNum;i++)&#123;</span><br><span class="line"><span class="comment">//复制物种至子种群中</span></span><br><span class="line">subPopulation[subSpeciesNum++]=talentSpecies;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//轮盘赌list.speciesNum-talentNum次</span></span><br><span class="line"><span class="keyword">int</span> randNum=speciesNum-talentNum;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;randNum;i++)&#123;</span><br><span class="line"><span class="keyword">double</span> rate=randT(<span class="number">0.0</span>,<span class="number">1.0</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;speciesNum;j++)&#123;</span><br><span class="line">                <span class="comment">//如果不是最后一个，那么遇到最优个体或者指针没在该区域停下</span></span><br><span class="line"><span class="keyword">if</span>((rate-population[j].rate&gt;<span class="number">0</span>||population[j]==talentSpecies)&amp;&amp;j!=speciesNum<span class="number">-1</span>)&#123;</span><br><span class="line">rate=rate-population[j].rate;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">subPopulation[subSpeciesNum++]=population[j];</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//子代成长为父种群</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;subSpeciesNum;i++)&#123;</span><br><span class="line">population[i]=subPopulation[i];</span><br><span class="line">&#125;</span><br><span class="line">speciesNum=subSpeciesNum;</span><br><span class="line">subSpeciesNum=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">crossover</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//两两配对</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;speciesNum;i+=<span class="number">2</span>)&#123;</span><br><span class="line"><span class="keyword">if</span>(i+<span class="number">1</span>==speciesNum)<span class="keyword">break</span>;<span class="comment">//若个体数量为奇数，则最后一个个体为单身</span></span><br><span class="line"><span class="comment">//以概率pcl~pch进行</span></span><br><span class="line"><span class="keyword">double</span> rate=randT(<span class="number">0.0</span>,<span class="number">1.0</span>);</span><br><span class="line"><span class="keyword">if</span>(rate&gt;pcl&amp;&amp;rate&lt;pch)&#123;</span><br><span class="line"><span class="comment">//单点交叉</span></span><br><span class="line"><span class="keyword">int</span> begin=rand()%xd;</span><br><span class="line"><span class="comment">//取第i个个体和第i+1个个体进行交叉，形成新的两个染色体</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=begin;j&lt;xd;j++)&#123;</span><br><span class="line">Swap(population[i].genes[j],population[i+<span class="number">1</span>].genes[j]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mutate</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//每一物种都有变异的机会，以概率pm进行</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;speciesNum;i++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;xd;j++)&#123;</span><br><span class="line"><span class="keyword">double</span> rate=randT(<span class="number">0.0</span>,<span class="number">1.0</span>);</span><br><span class="line"><span class="keyword">if</span>(rate&lt;pm)&#123;</span><br><span class="line">                    <span class="comment">//基因变异在±Xrn的领域内浮动。</span></span><br><span class="line">                    <span class="keyword">double</span> x=population[i].genes[j];</span><br><span class="line">                    population[i].genes[j]+=randT(Xl/<span class="built_in">exp</span>(Temp),Xr/<span class="built_in">exp</span>(Temp));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">setOptimizer</span><span class="params">(<span class="keyword">double</span> (*foo)(<span class="keyword">double</span> *,<span class="keyword">double</span> *),<span class="keyword">double</span> *x1,<span class="keyword">double</span> *y1,<span class="keyword">int</span> xd1,<span class="keyword">int</span> yd1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">fun=foo;</span><br><span class="line">x=x1;</span><br><span class="line">y=y1;</span><br><span class="line">xd=xd1;</span><br><span class="line">yd=yd1;</span><br><span class="line"></span><br><span class="line"><span class="comment">//随机种子</span></span><br><span class="line">srand(time(<span class="literal">NULL</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">//开始遗传算法（选择算子、交叉算子、变异算子）</span></span><br><span class="line"><span class="comment">//创建初始种群</span></span><br><span class="line">createBeginningSpecies();</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;DEVELOP_NUM;i++)&#123;</span><br><span class="line"><span class="comment">//计算适应度</span></span><br><span class="line">calcRate();</span><br><span class="line"></span><br><span class="line"><span class="comment">//目前最优解</span></span><br><span class="line">            SpeciesIndividual bestAns=getBest();</span><br><span class="line">            <span class="keyword">if</span>(fun(x1,y)&gt;fun(bestAns.genes,y))&#123;</span><br><span class="line">                 <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;xd;i++)&#123;</span><br><span class="line">                    x1[i]=bestAns.genes[i];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//选择</span></span><br><span class="line">select();</span><br><span class="line"><span class="comment">//交叉</span></span><br><span class="line">crossover();</span><br><span class="line"><span class="comment">//变异</span></span><br><span class="line">mutate();</span><br><span class="line"></span><br><span class="line"><span class="comment">//缩小基因变异的范围</span></span><br><span class="line">Temp+=<span class="number">0.01</span>;</span><br><span class="line">&#125;</span><br><span class="line">calcRate();</span><br><span class="line"><span class="keyword">return</span> fun(x1,y);</span><br><span class="line">&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure></p><p><strong>测试代码</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"opt1.h"</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Matrix_4x4</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">int</span> **mat;</span><br><span class="line">Matrix_4x4()&#123;&#125;;</span><br><span class="line">Matrix_4x4(<span class="keyword">int</span> (&amp;a)[<span class="number">4</span>][<span class="number">4</span>])&#123;</span><br><span class="line">mat=<span class="keyword">new</span> <span class="keyword">int</span> *[<span class="number">4</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)&#123;</span><br><span class="line">mat[i]= <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">4</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;<span class="number">4</span>;j++)&#123;</span><br><span class="line">mat[i][j]=a[i][j];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">~Matrix_4x4()</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">delete</span>[] mat[i];</span><br><span class="line">mat[i]=<span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">delete</span>[] mat;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">int</span>* <span class="keyword">operator</span>[](<span class="keyword">int</span> idx)</span><br><span class="line"> &#123;</span><br><span class="line"><span class="keyword">return</span> mat[idx];</span><br><span class="line"> &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">f1</span><span class="params">(<span class="keyword">double</span> *x,<span class="keyword">double</span> *y)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> index=<span class="number">4</span>;</span><br><span class="line">    <span class="keyword">int</span> m[<span class="number">4</span>][<span class="number">4</span>]=&#123;&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;,&#123;<span class="number">2</span>,<span class="number">4</span>,<span class="number">7</span>,<span class="number">5</span>&#125;,&#123;<span class="number">6</span>,<span class="number">7</span>,<span class="number">3</span>,<span class="number">2</span>&#125;,&#123;<span class="number">1</span>,<span class="number">8</span>,<span class="number">4</span>,<span class="number">2</span>&#125;&#125;;</span><br><span class="line"><span class="function">Matrix_4x4 <span class="title">A</span><span class="params">(m)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//计算误差</span></span><br><span class="line"><span class="keyword">double</span> temp[<span class="number">4</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">double</span> err=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;index;i++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;index;j++)&#123;</span><br><span class="line">temp[i]+=<span class="number">1.0</span>*A[i][j]*x[j];</span><br><span class="line">&#125;</span><br><span class="line">err+=(y[i]-temp[i])*(y[i]-temp[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//for(int i=0;i&lt;4;i++)cout&lt;&lt;x[i]&lt;&lt;" ";</span></span><br><span class="line"><span class="comment">//cout&lt;&lt;endl;</span></span><br><span class="line"><span class="comment">//cout&lt;&lt;err&lt;&lt;endl;</span></span><br><span class="line"><span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">double</span> x[<span class="number">4</span>]=&#123;&#125;;</span><br><span class="line"><span class="keyword">double</span> y[<span class="number">4</span>]=&#123;<span class="number">6</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">8</span>&#125;;</span><br><span class="line"></span><br><span class="line">opt1 opti;</span><br><span class="line">optimizer *opt=&amp;opti;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">"The error is : "</span>&lt;&lt;opt-&gt;setOptimizer(f1,x,y,<span class="number">4</span>,<span class="number">4</span>)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>&lt;&lt;<span class="string">"The result is : "</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)<span class="built_in">cout</span>&lt;&lt;x[i]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h2><p><img src="基于C++的最优化算法——遗传算法/运行结果.png" alt="运行结果"></p><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>通过本次实验，让我很好地了解了几种最优化算法，并且深入了解了其中的遗传算法。<br>实验过程中，我在如何提升结果精度上花费一些功夫，并且最终借鉴模拟退火中的一些思路，将结果优化至满意的结果。</p>]]></content>
    
    <summary type="html">
    
       
    
    </summary>
    
      <category term="计算机" scheme="http://kxjzxc.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
      <category term="程序" scheme="http://kxjzxc.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E7%A8%8B%E5%BA%8F/"/>
    
      <category term="C/C++" scheme="http://kxjzxc.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E7%A8%8B%E5%BA%8F/C-C/"/>
    
    
      <category term="最优化算法" scheme="http://kxjzxc.github.io/tags/%E6%9C%80%E4%BC%98%E5%8C%96%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>基于C++的计算不同图形面积</title>
    <link href="http://kxjzxc.github.io/%E5%9F%BA%E4%BA%8EC++%E7%9A%84%E8%AE%A1%E7%AE%97%E4%B8%8D%E5%90%8C%E5%9B%BE%E5%BD%A2%E9%9D%A2%E7%A7%AF.html"/>
    <id>http://kxjzxc.github.io/基于C++的计算不同图形面积.html</id>
    <published>2020-01-17T14:25:38.000Z</published>
    <updated>2020-01-17T14:41:38.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="要求"><a href="#要求" class="headerlink" title="要求"></a>要求</h1><ol><li>定义抽象基类Shape，由它派生出5个派生类：Circle、Square、Rectangle、Trapezoid、Triangle。用虚函数分别计算多个不同类图形的面积，并求它们的面积和。</li><li>要求用基类指针数组，使它的每一个元素指向一个派生类的对象，使用一个循环完成对多个图像的面积计算与求和。</li><li>图型的数据在定义对象时给定</li><li>定义顶点Point类，并在5个派生类中使用</li><li>圆以圆心坐标，半径的方式给定，其余以顶点坐标的方式给定</li><li>各个派生类的构造函数中应判断给定顶点组合是否满足图形属性</li></ol><h1 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h1><ol><li>类的继承与派生</li><li>虚函数的使用</li></ol><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pi 3.1415926</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> eps 1e-6</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="comment">//点类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">double</span> x,y;</span><br><span class="line">    Point()&#123;&#125;;</span><br><span class="line">    Point(<span class="keyword">double</span> x,<span class="keyword">double</span> y):x(x),y(y)&#123;&#125;;</span><br><span class="line">    Point &amp;<span class="keyword">operator</span>=(<span class="keyword">const</span> Point &amp;p)&#123;</span><br><span class="line">        x=p.x;</span><br><span class="line">        y=p.y;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//基类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Shape</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Point *p;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">double</span> <span class="title">Area</span><span class="params">()</span></span>=<span class="number">0</span>;<span class="comment">//求面积</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">check_angle90</span><span class="params">(Point a,Point b,Point c)</span></span>&#123;<span class="comment">//判断是否垂直</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">fabs</span>((a.x-c.x)*(b.x-c.x)+(b.y-c.y)*(a.y-c.y))&lt;=eps;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">check_Parallel</span><span class="params">(Point a,Point b,Point c,Point d)</span></span>&#123;<span class="comment">//判断是否平行</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">fabs</span>((a.x-b.x)*(c.y-d.y)-(a.y-b.y)*(c.x-d.x))&lt;=eps;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">dis2</span><span class="params">(Point a,Point b)</span></span>&#123;<span class="comment">//求两点间距离</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">pow</span>(a.x-b.x,<span class="number">2</span>)+<span class="built_in">pow</span>(a.y-b.y,<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Swap</span><span class="params">(Point &amp;x,Point &amp;y)</span></span>&#123;<span class="comment">//交换两点</span></span><br><span class="line">        Point temp;</span><br><span class="line">        temp=x;</span><br><span class="line">        x=y;</span><br><span class="line">        y=temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//派生类：圆形</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Circle</span>:</span> <span class="keyword">public</span> Shape</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">double</span> r;</span><br><span class="line">    Circle(Point point,<span class="keyword">double</span> radius)&#123;</span><br><span class="line">        <span class="keyword">if</span>(r&lt;=<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;<span class="string">"Wrong parameter"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        p=<span class="keyword">new</span> Point(point);</span><br><span class="line">        r=radius;</span><br><span class="line">    &#125;</span><br><span class="line">    ~Circle()&#123;</span><br><span class="line">        <span class="keyword">delete</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">Area</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> r*r*pi;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//派生类：矩阵</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span>:</span> <span class="keyword">public</span> Shape</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">double</span> width,height;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(Point point[],<span class="keyword">bool</span> isSquare)</span></span>&#123;<span class="comment">//判断是否是矩形或者正方形</span></span><br><span class="line">        <span class="keyword">int</span> k=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(k&lt;<span class="number">3</span>)&#123;<span class="comment">//找到一个直角</span></span><br><span class="line">            <span class="keyword">if</span>(check_angle90(point[<span class="number">0</span>],point[<span class="number">1</span>],point[<span class="number">2</span>]))<span class="keyword">break</span>;</span><br><span class="line">            Swap(point[k],point[<span class="number">3</span>]);</span><br><span class="line">            k++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(k==<span class="number">3</span>)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        Swap(point[<span class="number">1</span>],point[<span class="number">2</span>]);</span><br><span class="line">        <span class="keyword">double</span> edge2[<span class="number">4</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)&#123;</span><br><span class="line">            edge2[i]=dis2(point[i],point[(i+<span class="number">1</span>)%<span class="number">4</span>]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//矩形两对边相等，正方形四边相等</span></span><br><span class="line">        <span class="keyword">if</span>(isSquare)<span class="keyword">return</span> <span class="built_in">fabs</span>(edge2[<span class="number">0</span>]-edge2[<span class="number">2</span>])&lt;=eps&amp;&amp;<span class="built_in">fabs</span>(edge2[<span class="number">1</span>]-edge2[<span class="number">3</span>])&lt;=eps&amp;&amp;<span class="built_in">fabs</span>(edge2[<span class="number">0</span>]-edge2[<span class="number">1</span>])&lt;=eps;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">fabs</span>(edge2[<span class="number">0</span>]-edge2[<span class="number">2</span>])&lt;=eps&amp;&amp;<span class="built_in">fabs</span>(edge2[<span class="number">1</span>]-edge2[<span class="number">3</span>])&lt;=eps;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">Area</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> width*height;</span><br><span class="line">    &#125;</span><br><span class="line">    Rectangle()&#123;&#125;;</span><br><span class="line">    Rectangle(Point point[])&#123;</span><br><span class="line">        <span class="keyword">if</span>(!check(point,<span class="number">0</span>))&#123;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;<span class="string">"Wrong parameter"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        p=<span class="keyword">new</span> Point[<span class="number">4</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)&#123;</span><br><span class="line">            p[i]=point[i];</span><br><span class="line">        &#125;</span><br><span class="line">        width=<span class="built_in">sqrt</span>(dis2(point[<span class="number">0</span>],point[<span class="number">1</span>]));</span><br><span class="line">        height=<span class="built_in">sqrt</span>(dis2(point[<span class="number">0</span>],point[<span class="number">3</span>]));</span><br><span class="line">    &#125;</span><br><span class="line">    ~Rectangle()&#123;</span><br><span class="line">        <span class="keyword">delete</span>[] p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//派生类：正方形</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Square</span>:</span> <span class="keyword">public</span> Rectangle</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">double</span> edge;</span><br><span class="line">    Square(Point point[])&#123;</span><br><span class="line">        <span class="keyword">if</span>(!check(point,<span class="number">1</span>))&#123;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;<span class="string">"Wrong parameter"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        p=<span class="keyword">new</span> Point[<span class="number">4</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)&#123;</span><br><span class="line">            p[i]=point[i];</span><br><span class="line">        &#125;</span><br><span class="line">        edge=<span class="built_in">sqrt</span>(dis2(point[<span class="number">0</span>],point[<span class="number">1</span>]));</span><br><span class="line">    &#125;</span><br><span class="line">    ~Square()&#123;</span><br><span class="line">        <span class="keyword">delete</span>[] p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">Area</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> edge*edge;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//派生类：三角形</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Triangle</span>:</span> <span class="keyword">public</span> Shape</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">double</span> edge[<span class="number">3</span>];</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(Point point[])</span></span>&#123;<span class="comment">//三角形只要判断是否有零边</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">3</span>;i++)&#123;</span><br><span class="line">            edge[i]=<span class="built_in">sqrt</span>(dis2(point[i],point[(i+<span class="number">1</span>)%<span class="number">3</span>]));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> edge[<span class="number">0</span>]&gt;eps&amp;&amp;edge[<span class="number">1</span>]&gt;eps&amp;&amp;edge[<span class="number">2</span>]&gt;eps;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">Area</span><span class="params">()</span></span>&#123;<span class="comment">//海伦公式</span></span><br><span class="line">        <span class="keyword">double</span> aver=(edge[<span class="number">0</span>]+edge[<span class="number">1</span>]+edge[<span class="number">2</span>])/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">sqrt</span>(aver*(aver-edge[<span class="number">0</span>])*(aver-edge[<span class="number">1</span>])*(aver-edge[<span class="number">2</span>]));</span><br><span class="line">    &#125;</span><br><span class="line">    Triangle(Point point[])&#123;</span><br><span class="line">        <span class="keyword">if</span>(!check(point))&#123;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;<span class="string">"Wrong parameter"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        p=<span class="keyword">new</span> Point[<span class="number">3</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">3</span>;i++)&#123;</span><br><span class="line">            p[i]=point[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ~Triangle()&#123;</span><br><span class="line">        <span class="keyword">delete</span>[] p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Trapezoid</span>:</span> <span class="keyword">public</span> Shape</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">     <span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(Point point[])</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;<span class="number">3</span>)&#123;<span class="comment">//找平行的一对边，为上下底</span></span><br><span class="line">            <span class="keyword">if</span>(check_Parallel(point[<span class="number">0</span>],point[<span class="number">1</span>],point[<span class="number">2</span>],point[<span class="number">3</span>]))<span class="keyword">break</span>;</span><br><span class="line">            Swap(point[i],point[<span class="number">3</span>]);</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(i==<span class="number">3</span>)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">//找高，且高不为零</span></span><br><span class="line">        <span class="keyword">double</span> y0=point[<span class="number">0</span>].y-point[<span class="number">1</span>].y,x0=point[<span class="number">0</span>].x-point[<span class="number">1</span>].x;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">fabs</span>(x0)&lt;=eps)height=<span class="built_in">fabs</span>(point[<span class="number">0</span>].x-point[<span class="number">2</span>].x);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">double</span> k=y0/x0;</span><br><span class="line">            <span class="keyword">double</span> b1=point[<span class="number">0</span>].y-k*point[<span class="number">0</span>].x;</span><br><span class="line">            <span class="keyword">double</span> b2=point[<span class="number">2</span>].y-k*point[<span class="number">2</span>].x;</span><br><span class="line">            height=<span class="built_in">fabs</span>(b1-b2)/<span class="built_in">sqrt</span>(<span class="number">1</span>+k*k);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> height&gt;eps;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">Area</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (topline+baseline)*height/<span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">double</span> height,topline,baseline;</span><br><span class="line">    Trapezoid(Point point[])&#123;</span><br><span class="line">        <span class="keyword">if</span>(!check(point))&#123;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;<span class="string">"Wrong parameter"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        p=<span class="keyword">new</span> Point[<span class="number">4</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)&#123;</span><br><span class="line">            p[i]=point[i];</span><br><span class="line">        &#125;</span><br><span class="line">        topline=<span class="built_in">sqrt</span>(dis2(point[<span class="number">0</span>],point[<span class="number">1</span>]));</span><br><span class="line">        baseline=<span class="built_in">sqrt</span>(dis2(point[<span class="number">2</span>],point[<span class="number">3</span>]));</span><br><span class="line">    &#125;</span><br><span class="line">    ~Trapezoid()&#123;</span><br><span class="line">        <span class="keyword">delete</span>[] p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Shape *p[<span class="number">5</span>];</span><br><span class="line">    <span class="comment">//圆心和半径</span></span><br><span class="line">    <span class="function">Point <span class="title">circlePoint</span><span class="params">(<span class="number">0.0</span>,<span class="number">0.0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">double</span> radius=<span class="number">5.5</span>;</span><br><span class="line">    <span class="comment">//长方形</span></span><br><span class="line">    Point rectVertex[<span class="number">4</span>]=&#123;&#123;<span class="number">0.0</span>,<span class="number">0.0</span>&#125;,&#123;<span class="number">1.0</span>,<span class="number">0.0</span>&#125;,&#123;<span class="number">1.0</span>,<span class="number">2.0</span>&#125;,&#123;<span class="number">0.0</span>,<span class="number">2.0</span>&#125;&#125;;</span><br><span class="line">    <span class="comment">//正方形</span></span><br><span class="line">    Point squVertex[<span class="number">4</span>]=&#123;&#123;<span class="number">0.0</span>,<span class="number">0.0</span>&#125;,&#123;<span class="number">4.8</span>,<span class="number">3.6</span>&#125;,&#123;<span class="number">1.2</span>,<span class="number">8.4</span>&#125;,&#123;<span class="number">-3.6</span>,<span class="number">4.8</span>&#125;&#125;;</span><br><span class="line">    <span class="comment">//三角形</span></span><br><span class="line">    Point triVertex[<span class="number">3</span>]=&#123;&#123;<span class="number">0.0</span>,<span class="number">0.0</span>&#125;,&#123;<span class="number">4.6</span>,<span class="number">8.9</span>&#125;,&#123;<span class="number">-4.3</span>,<span class="number">4.2</span>&#125;&#125;;</span><br><span class="line">    <span class="comment">//梯形</span></span><br><span class="line">    Point traVertex[<span class="number">4</span>]=&#123;&#123;<span class="number">0.0</span>,<span class="number">0.0</span>&#125;,&#123;<span class="number">5.0</span>,<span class="number">0.0</span>&#125;,&#123;<span class="number">1.0</span>,<span class="number">7.0</span>&#125;,&#123;<span class="number">9.0</span>,<span class="number">7.0</span>&#125;&#125;;</span><br><span class="line">    <span class="comment">//Circle cir()</span></span><br><span class="line">    <span class="function">Circle <span class="title">cir</span><span class="params">(circlePoint,radius)</span></span>;</span><br><span class="line">    <span class="function">Rectangle <span class="title">rect</span><span class="params">(rectVertex)</span></span>;</span><br><span class="line">    <span class="function">Square <span class="title">squ</span><span class="params">(squVertex)</span></span>;</span><br><span class="line">    <span class="function">Triangle <span class="title">tri</span><span class="params">(triVertex)</span></span>;</span><br><span class="line">    <span class="function">Trapezoid <span class="title">tra</span><span class="params">(traVertex)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//调用各种派生类</span></span><br><span class="line">    p[<span class="number">0</span>]=&amp;cir;</span><br><span class="line">    p[<span class="number">1</span>]=&amp;rect;</span><br><span class="line">    p[<span class="number">2</span>]=&amp;squ;</span><br><span class="line">    p[<span class="number">3</span>]=&amp;tri;</span><br><span class="line">    p[<span class="number">4</span>]=&amp;tra;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">double</span> sumArea=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)&#123;</span><br><span class="line">        sumArea+=p[i]-&gt;Area();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; sumArea &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h1><p><img src="基于C++的计算不同图形面积/运行结果.png" alt="运行结果"></p><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>本次实验的重点在于类之间的继承和组合，以及对于纯虚函数的应用和类的成员函数的重复利用。<br>花在这份代码的时间其实大部分在构思如何判断形状。</p>]]></content>
    
    <summary type="html">
    
       
    
    </summary>
    
      <category term="计算机" scheme="http://kxjzxc.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
      <category term="程序" scheme="http://kxjzxc.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E7%A8%8B%E5%BA%8F/"/>
    
      <category term="C/C++" scheme="http://kxjzxc.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E7%A8%8B%E5%BA%8F/C-C/"/>
    
    
      <category term="C++" scheme="http://kxjzxc.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>基于C++的矩阵类的编写 </title>
    <link href="http://kxjzxc.github.io/%E5%9F%BA%E4%BA%8EC++%E7%9A%84%E7%9F%A9%E9%98%B5%E7%B1%BB%E7%9A%84%E7%BC%96%E5%86%99.html"/>
    <id>http://kxjzxc.github.io/基于C++的矩阵类的编写.html</id>
    <published>2020-01-17T13:59:33.000Z</published>
    <updated>2020-01-17T14:28:40.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="要求"><a href="#要求" class="headerlink" title="要求"></a>要求</h1><p>本次实验是编写矩阵类 Matrix_4x4，使类满足以下要求：</p><ol><li>矩阵为 4*4，数据类型为 double</li><li>默认构造函数，初始化矩阵为单位阵</li><li>拷贝构造函数</li><li>带参数构造函数，可以用一个 4x4 的二维数组初始化</li><li>重载 加(+)，减(-)，乘(*)，幂次(^) ，输入，输出 等操作</li><li>重载 = 操作，可以实现矩阵间赋值，或者二维数组向矩阵赋值</li><li>重载( ), 实现矩阵元素访问, 例如矩阵类的对象 m 可以实现 m(1, 2)=2;</li><li>实现求逆功能，转置功能，求行列式功能</li></ol><h1 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h1><ol><li>构造函数</li><li>运算符重载</li><li>友元函数的使用</li></ol><h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><h2 id="矩阵求逆和求行列式的原理"><a href="#矩阵求逆和求行列式的原理" class="headerlink" title="矩阵求逆和求行列式的原理"></a>矩阵求逆和求行列式的原理</h2><p>矩阵求逆：通过高斯-若尔当消元法，通过初等行变换将矩阵 A 化为单位矩阵 E，将矩阵 E 化为 A^(-1)。对于每一行，首先判断对角方向的元素是否为 0，然后将对角位置转换为 1，接着将该列非对角位置转换为 0。最终可得矩阵 A 的逆矩阵<br><img src="基于C++的矩阵类的编写/矩阵求逆.png" alt="矩阵求逆"></p><p>行列式运算：使用高斯消去法，通过对矩阵 A 的一系列行变换，使之成为<br>上三角形矩阵，其主对角线上诸元素乘积即为行列式之值。判断每列的最大元素，<br>通过交换行放到主对角线，然后根据 $A[j][k] = A[j][k] - A[i][k] * A[j][i] / A[i][i]$，将每<br>一列下三角转化为 0，最终可得一个上三角行列式。<br><img src="基于C++的矩阵类的编写/求行列式.png" alt="求行列式"></p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p><strong>头文件</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> MATRIX_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MATRIX_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">double</span> matE[<span class="number">4</span>][<span class="number">4</span>]=&#123;&#123;<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>&#125;,</span><br><span class="line">                 &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>&#125;,</span><br><span class="line">                 &#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>&#125;,</span><br><span class="line">                 &#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>&#125;&#125;;<span class="comment">//单位矩阵</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Matrix</span>&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">double</span> mat[<span class="number">4</span>][<span class="number">4</span>];</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Matrix()&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;<span class="number">4</span>;j++)&#123;</span><br><span class="line">                mat[i][j]=<span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;;<span class="comment">//默认构造函数，零矩阵</span></span><br><span class="line">    Matrix(<span class="keyword">const</span> Matrix &amp;m)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;<span class="number">4</span>;j++)&#123;</span><br><span class="line">                mat[i][j]=m.mat[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;;<span class="comment">//拷贝构造函数，拷贝同类对象</span></span><br><span class="line">    Matrix(<span class="keyword">double</span> (&amp;m)[<span class="number">4</span>][<span class="number">4</span>])&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;<span class="number">4</span>;j++)&#123;</span><br><span class="line">                mat[i][j]=m[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;;<span class="comment">//拷贝构造函数，拷贝二维数组</span></span><br><span class="line"></span><br><span class="line">    Matrix <span class="keyword">operator</span>+(<span class="keyword">const</span> Matrix &amp;m)&#123;</span><br><span class="line">        Matrix ansM;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;<span class="number">4</span>;j++)&#123;</span><br><span class="line">                ansM.mat[i][j]=mat[i][j]+m.mat[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ansM;</span><br><span class="line">    &#125;;<span class="comment">//重载加法运算</span></span><br><span class="line">    Matrix <span class="keyword">operator</span>-(<span class="keyword">const</span> Matrix &amp;m)&#123;</span><br><span class="line">        Matrix ansM;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;<span class="number">4</span>;j++)&#123;</span><br><span class="line">                ansM.mat[i][j]=mat[i][j]-m.mat[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ansM;</span><br><span class="line">    &#125;;<span class="comment">//重载减法运算</span></span><br><span class="line">    Matrix <span class="keyword">operator</span>*(<span class="keyword">const</span> Matrix &amp;m)&#123;</span><br><span class="line">        Matrix ansM;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;<span class="number">4</span>;j++)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;<span class="number">4</span>;k++)&#123;</span><br><span class="line">                    ansM.mat[i][j]+=mat[i][k]*m.mat[k][j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ansM;</span><br><span class="line">    &#125;;<span class="comment">//重载乘法运算</span></span><br><span class="line">    Matrix <span class="keyword">operator</span>^(<span class="keyword">int</span> n)&#123;</span><br><span class="line">        <span class="function">Matrix <span class="title">ansM</span><span class="params">(matE)</span></span>;</span><br><span class="line">        <span class="keyword">bool</span> ifInverse=<span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(n&lt;<span class="number">0</span>)&#123;</span><br><span class="line">            n=-n;</span><br><span class="line">            ifInverse=<span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;n;k++)&#123;</span><br><span class="line">            ansM=ansM*(*<span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(ifInverse)ansM=ansM.Inverse();</span><br><span class="line">        <span class="keyword">return</span> ansM;</span><br><span class="line">    &#125;;<span class="comment">//重载幂运算</span></span><br><span class="line">    <span class="keyword">const</span> Matrix &amp;<span class="keyword">operator</span>=(<span class="keyword">const</span> Matrix &amp;m)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;<span class="number">4</span>;j++)&#123;</span><br><span class="line">                mat[i][j]=m.mat[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;;<span class="comment">//重载赋值运算</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">const</span> <span class="keyword">double</span> &amp;<span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(i&lt;<span class="number">0</span>||j&lt;<span class="number">0</span>||i&gt;=<span class="number">4</span>||j&gt;=<span class="number">4</span>)&#123;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;<span class="string">"Wrong index!"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> mat[i][j];</span><br><span class="line">    &#125;;<span class="comment">//重载取值运算</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">friend</span> istream &amp; <span class="keyword">operator</span>&gt;&gt;(istream &amp;is,Matrix &amp;m);<span class="comment">//友元，重载输入</span></span><br><span class="line">    <span class="keyword">friend</span> ostream &amp; <span class="keyword">operator</span>&lt;&lt;(ostream &amp;os,<span class="keyword">const</span> Matrix &amp;m);<span class="comment">//友元，重载输出</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Swap</span><span class="params">(<span class="keyword">double</span> &amp;a,<span class="keyword">double</span> &amp;b)</span></span>&#123;</span><br><span class="line">        <span class="keyword">double</span> tmp=a;</span><br><span class="line">        a=b;</span><br><span class="line">        b=tmp;</span><br><span class="line">    &#125;<span class="comment">//交换两个double变量</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">SwapRow</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)&#123;</span><br><span class="line">            Swap(mat[a][i],mat[b][i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="comment">//交换矩阵的两行</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">LineMultiK</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">double</span> k)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)mat[a][i]*=k;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">Matrix <span class="title">Inverse</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="function">Matrix <span class="title">tmpM</span><span class="params">(mat)</span></span>;</span><br><span class="line">        <span class="function">Matrix <span class="title">E</span><span class="params">(matE)</span></span>;</span><br><span class="line">        <span class="comment">//首先将tmpM转换为上三角矩阵</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)&#123;</span><br><span class="line">            <span class="comment">//判断对角方向的元素是否为0</span></span><br><span class="line">            <span class="keyword">int</span> j=i;</span><br><span class="line">            <span class="keyword">while</span>(mat[i][j]==<span class="number">0</span>&amp;&amp;j&lt;<span class="number">4</span>)j++;</span><br><span class="line">            <span class="keyword">if</span>(j==<span class="number">4</span>)&#123;</span><br><span class="line">                <span class="built_in">cout</span>&lt;&lt;<span class="string">"this matrix has no inverse!"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">                <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(i!=j)tmpM.SwapRow(i,j),E.SwapRow(i,j);</span><br><span class="line">            <span class="comment">//将对角位置转换为1</span></span><br><span class="line">            E.LineMultiK(i,<span class="number">1.0</span>/tmpM(i,i));</span><br><span class="line">            tmpM.LineMultiK(i,<span class="number">1.0</span>/tmpM(i,i));</span><br><span class="line">            <span class="comment">//将该列非对角位置转换为0</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;<span class="number">4</span>;k++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(k==i)<span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> t=i+<span class="number">1</span>;t&lt;<span class="number">4</span>;t++)&#123;</span><br><span class="line">                    tmpM.mat[k][t]-=tmpM(i,t)*tmpM(k,i);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> t=<span class="number">0</span>;t&lt;<span class="number">4</span>;t++)&#123;</span><br><span class="line">                    E.mat[k][t]-=E(i,t)*tmpM(k,i);</span><br><span class="line">                &#125;</span><br><span class="line">                tmpM.mat[k][i]=<span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> E;</span><br><span class="line">    &#125;<span class="comment">//矩阵求逆</span></span><br><span class="line"></span><br><span class="line">    <span class="function">Matrix <span class="title">Transpose</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Matrix ansM;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;<span class="number">4</span>;j++)&#123;</span><br><span class="line">                ansM.mat[i][j]=mat[j][i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ansM;</span><br><span class="line">    &#125;<span class="comment">//矩阵转置</span></span><br><span class="line"></span><br><span class="line">    <span class="function">Matrix <span class="title">Determinant</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="function">Matrix <span class="title">ansM</span><span class="params">(mat)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)&#123;</span><br><span class="line">            <span class="comment">//判断每列的最大元素，通过交换行放到主对角线</span></span><br><span class="line">            <span class="keyword">int</span> maxi=i;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=i;j&lt;<span class="number">4</span>;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(ansM(maxi,i)&lt;ansM(j,i))maxi=j;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(i!=maxi)ansM.SwapRow(i,maxi);</span><br><span class="line">            <span class="keyword">if</span>(ansM.mat[i][i]==<span class="number">0</span>)<span class="keyword">continue</span>;</span><br><span class="line">            <span class="comment">//根据A[j][k] = A[j][k] - A[i][k] * A[j][i] / A[i][i]，将每一列下三角转化为0</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k=i+<span class="number">1</span>;k&lt;<span class="number">4</span>;k++)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> t=i+<span class="number">1</span>;t&lt;<span class="number">4</span>;t++)&#123;</span><br><span class="line">                    ansM.mat[k][t]-=ansM(i,t)*ansM(k,i)/ansM(i,i);</span><br><span class="line">                &#125;</span><br><span class="line">                ansM.mat[k][i]=<span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ansM;</span><br><span class="line">    &#125;<span class="comment">//行列式化简</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">istream &amp; <span class="keyword">operator</span>&gt;&gt;(istream &amp;is,Matrix &amp;m)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;<span class="number">4</span>;j++)&#123;</span><br><span class="line">            is&gt;&gt;m.mat[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> is;</span><br><span class="line">&#125;;<span class="comment">//重载输入流</span></span><br><span class="line"></span><br><span class="line">ostream &amp; <span class="keyword">operator</span>&lt;&lt;(ostream &amp;os,<span class="keyword">const</span> Matrix &amp;m)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;<span class="number">4</span>;j++)&#123;</span><br><span class="line">            os&lt;&lt;m.mat[i][j]&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        os&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> os;</span><br><span class="line">&#125;;<span class="comment">//重载输出流</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// MATRIX_H</span></span></span><br></pre></td></tr></table></figure></p><p><strong>测试代码</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"matrix.h"</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Matrix a;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;a;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"a="</span>&lt;&lt;<span class="built_in">endl</span>&lt;&lt;a;</span><br><span class="line"></span><br><span class="line">    <span class="function">Matrix <span class="title">b</span><span class="params">(a^<span class="number">3</span>)</span></span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"a^3="</span>&lt;&lt;<span class="built_in">endl</span>&lt;&lt;b;</span><br><span class="line"></span><br><span class="line">    Matrix c=a^<span class="number">-2</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"a^-2="</span>&lt;&lt;<span class="built_in">endl</span>&lt;&lt;c;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"a^T="</span>&lt;&lt;<span class="built_in">endl</span>&lt;&lt;a.Transpose();</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;a.Determinant();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h2><p><img src="基于C++的矩阵类的编写/运行结果.png" alt="运行结果"></p><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>本次实验的重点在于运算符的重载、友元函数的使用和二维数组构造函数。<br>写这份代码的时候时间更多的是花在矩阵的求逆和求行列式上，其他倒还好。<br>重载输入输出流运算符时，普通的方法需要将cin与cout放在运算符的右边，不符合代码编写习惯。通过友元函数，可以自由定义cin和cout与输入对象的相对位置，改成符合编写习惯的代码。</p>]]></content>
    
    <summary type="html">
    
       
    
    </summary>
    
      <category term="计算机" scheme="http://kxjzxc.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
      <category term="程序" scheme="http://kxjzxc.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E7%A8%8B%E5%BA%8F/"/>
    
      <category term="C/C++" scheme="http://kxjzxc.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E7%A8%8B%E5%BA%8F/C-C/"/>
    
    
      <category term="C++" scheme="http://kxjzxc.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>基于C++的vector类的编写</title>
    <link href="http://kxjzxc.github.io/%E5%9F%BA%E4%BA%8EC++%E7%9A%84vector%E7%B1%BB%E7%9A%84%E7%BC%96%E5%86%99.html"/>
    <id>http://kxjzxc.github.io/基于C++的vector类的编写.html</id>
    <published>2020-01-17T09:46:36.000Z</published>
    <updated>2020-01-17T14:30:24.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="要求"><a href="#要求" class="headerlink" title="要求"></a>要求</h1><p>编写vector类，实现动态的建立，插入，删除等功能。</p><h1 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h1><ol><li>构造函数<br> 定义对象时调用该函数，可以定义许多个不同的构造函数</li><li>析构函数<br> 释放对象时调用该函数，只有一个</li><li>类模板 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ol><ol><li>重载运算符</li><li>const修饰词的运用</li><li>头文件的编写</li></ol><h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><p>在实验过程中，如何实现动态分配空间是最重要的点。为了使得分配的内存空间连续，我首先给对象分配一个固定长度的连续空间，一旦插入元素的个数大于容量，需要对数组进行扩容，即重新分配空间，都会将当前容量扩充至原先的两倍，实现动态数组的功能。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><h3 id="头文件"><a href="#头文件" class="headerlink" title="头文件"></a>头文件</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> VECTOR_SS_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> VECTOR_SS_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">vector_ss</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> v_size;<span class="comment">//元素个数</span></span><br><span class="line">    <span class="keyword">int</span> capacity;<span class="comment">//容量</span></span><br><span class="line">    T* buf;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector_ss()&#123;</span><br><span class="line">        v_size=<span class="number">0</span>;</span><br><span class="line">        capacity=<span class="number">1</span>;</span><br><span class="line">        buf=<span class="keyword">new</span> T;</span><br><span class="line">    &#125;;<span class="comment">//默认构造函数</span></span><br><span class="line">    vector_ss(<span class="keyword">int</span> n)&#123;</span><br><span class="line">        v_size=n;</span><br><span class="line">        capacity=n;</span><br><span class="line">        buf=<span class="keyword">new</span> T[n];</span><br><span class="line">    &#125;;<span class="comment">//构造函数，数组初始大小为n</span></span><br><span class="line">    vector_ss(<span class="keyword">int</span> n,T t)&#123;</span><br><span class="line">        v_size=n;</span><br><span class="line">        capacity=n;</span><br><span class="line">        buf=<span class="keyword">new</span> T[n];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)buf[i]=t;</span><br><span class="line">    &#125;;<span class="comment">//构造函数，数组初始大小为n，且元素均为t</span></span><br><span class="line">    vector_ss(<span class="keyword">const</span> vector_ss &amp;v)&#123;</span><br><span class="line">        v_size=v.size();</span><br><span class="line">        capacity=v.capacity;</span><br><span class="line">        buf=<span class="keyword">new</span> T[capacity];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;v_size;i++)</span><br><span class="line">            buf[i]=v.buf[i];</span><br><span class="line">    &#125;;<span class="comment">//拷贝构造函数</span></span><br><span class="line">    vector_ss(<span class="keyword">const</span> vector_ss &amp;v,<span class="keyword">int</span> start,<span class="keyword">int</span> end)&#123;</span><br><span class="line">        capacity=v.capacity;</span><br><span class="line">        v_size=end-start+<span class="number">1</span>;</span><br><span class="line">        buf=<span class="keyword">new</span> T[capacity];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;v_size;i++)</span><br><span class="line">            buf[i]=v.buf[start+i];</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">//拷贝构造函数，数组元素为v的start位置到end位置</span></span><br><span class="line"></span><br><span class="line">    ~vector_ss()&#123;</span><br><span class="line">        <span class="keyword">if</span>(buf)&#123;</span><br><span class="line">            <span class="keyword">delete</span>[] buf;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;<span class="comment">//析构函数</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">resize</span><span class="params">(<span class="keyword">int</span> newCapacity)</span></span>&#123;</span><br><span class="line">        T* buftmp=<span class="keyword">new</span> T[newCapacity];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;v_size;i++)buftmp[i]=buf[i];</span><br><span class="line">        <span class="keyword">delete</span>[] buf;</span><br><span class="line">        buf=buftmp;</span><br><span class="line">        capacity=newCapacity;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push_back</span><span class="params">(T t)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(v_size&gt;=capacity)</span><br><span class="line">            resize(capacity*<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">        buf[v_size++]=t;</span><br><span class="line">    &#125;;<span class="comment">//数组末尾插入元素</span></span><br><span class="line">    <span class="function">T <span class="title">pop_back</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(v_size)&#123;</span><br><span class="line">            <span class="keyword">return</span> buf[v_size--];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;<span class="comment">//删除并返回末尾元素</span></span><br><span class="line">    <span class="function">T <span class="title">front</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(v_size)&#123;</span><br><span class="line">            <span class="keyword">return</span> buf[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;<span class="comment">//返回数组首元素</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">delete</span>[] buf;</span><br><span class="line">        buf=<span class="keyword">new</span> T;</span><br><span class="line">        capacity=<span class="number">1</span>;</span><br><span class="line">        v_size=<span class="number">0</span>;</span><br><span class="line">    &#125;;<span class="comment">//清空数组</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> v_size?<span class="number">1</span>:<span class="number">0</span>;</span><br><span class="line">    &#125;;<span class="comment">//判断数组是否为空</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> pos,T data)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(pos&gt;=v_size||pos&lt;<span class="number">0</span>)&#123;<span class="comment">//报错</span></span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;<span class="string">"Wrong parameter!"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(v_size&gt;=capacity)</span><br><span class="line">            resize(capacity*<span class="number">2</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=v_size<span class="number">-1</span>;i&gt;pos;i--)</span><br><span class="line">            buf[i]=buf[i<span class="number">-1</span>];</span><br><span class="line">        buf[pos]=data;</span><br><span class="line">        v_size++;</span><br><span class="line">    &#125;;<span class="comment">//在数组的第pos个位置插入数据data</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">erase</span><span class="params">(<span class="keyword">int</span> pos)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(pos&gt;=v_size||pos&lt;<span class="number">0</span>)&#123;<span class="comment">//报错</span></span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;<span class="string">"Wrong parameter!"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=pos;i&lt;v_size<span class="number">-1</span>;i++)</span><br><span class="line">            buf[i]=buf[i+<span class="number">1</span>];</span><br><span class="line">        v_size--;</span><br><span class="line">    &#125;;<span class="comment">//删除pos位置的数据</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">erase</span><span class="params">(<span class="keyword">int</span> begin,<span class="keyword">int</span> end)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(begin&gt;=v_size||end&lt;<span class="number">0</span>||begin&gt;end)&#123;<span class="comment">//报错</span></span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;<span class="string">"Wrong parameter!"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i+end&lt;v_size;i++)</span><br><span class="line">            buf[begin+i]=buf[end+i];</span><br><span class="line">        v_size-=end-begin+<span class="number">1</span>;</span><br><span class="line">    &#125;;<span class="comment">//删除从begin位置到end位置的数据</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">const</span> <span class="keyword">int</span> &amp;<span class="title">size</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;<span class="keyword">return</span> v_size;&#125;;<span class="comment">//返回当前数组元素个数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> vector_ss&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> vector_ss &amp;v)&#123;</span><br><span class="line">        T* buftmp=<span class="keyword">new</span> T[v.capacity];</span><br><span class="line">        v_size=v.size();</span><br><span class="line">        capacity=v.capacity;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;v_size;i++)buftmp[i]=v.buf[i];</span><br><span class="line">        <span class="keyword">delete</span>[] buf;</span><br><span class="line">        buf=buftmp;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;;<span class="comment">//重载=运算符</span></span><br><span class="line"></span><br><span class="line">    T&amp; <span class="keyword">operator</span>[](<span class="keyword">int</span> n)&#123;</span><br><span class="line">        <span class="keyword">if</span>(n&lt;v_size&amp;&amp;n&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> buf[n];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">cout</span>&lt;&lt;<span class="string">"Wrong parameter!"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;;<span class="comment">//重载下标运算符</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> T&amp; <span class="keyword">operator</span>[](<span class="keyword">int</span> n) <span class="keyword">const</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n&lt;v_size&amp;&amp;n&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> buf[n];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">cout</span>&lt;&lt;<span class="string">"Wrong parameter!"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">display</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;v_size;i++)</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;buf[i]&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;;<span class="comment">//打印数组元素</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// VECTOR_SS_H</span></span></span><br></pre></td></tr></table></figure><h3 id="测试代码"><a href="#测试代码" class="headerlink" title="测试代码"></a>测试代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"vector_ss.h"</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector_ss&lt;<span class="keyword">char</span>&gt; v1;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;v1.size()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)</span><br><span class="line">        v1.push_back(<span class="string">'a'</span>+i);</span><br><span class="line">    v1.display();</span><br><span class="line"></span><br><span class="line">    vector_ss&lt;<span class="keyword">char</span>&gt; v2(v1,<span class="number">2</span>,<span class="number">5</span>);</span><br><span class="line">    v2.display();</span><br><span class="line"></span><br><span class="line">    v1.erase(<span class="number">2</span>,<span class="number">4</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;v1.size();i++)</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;v1[i]&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    v1.insert(<span class="number">2</span>,<span class="string">'c'</span>);</span><br><span class="line">    v1.display();</span><br><span class="line"></span><br><span class="line">    v1.clear();</span><br><span class="line">    v1.display();</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;v1.size()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    vector_ss&lt;<span class="keyword">char</span>&gt;v3;</span><br><span class="line">    v3=v2;</span><br><span class="line">    v3.display();</span><br><span class="line"></span><br><span class="line">    vector_ss&lt;<span class="keyword">double</span>&gt;v4(<span class="number">5</span>,<span class="number">5</span>);</span><br><span class="line">    v4.display();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h2><p><img src="基于C++的vector类的编写/运行结果.png" alt="运行结果"></p><h1 id="Q-amp-A"><a href="#Q-amp-A" class="headerlink" title="Q&amp;A"></a>Q&amp;A</h1><ol><li><p><strong>为什么要重载赋值运算符？</strong><br> 答：不重载赋值运算符直接赋值的话，要赋值的对象将简单拷贝原对象中的所有成员值。如果类成员中有指针变量，那么仅仅拷贝的是指针地址值，而非指针指向值。这样的做容易造成内存的二次释放，造成严重的错误。因此需要重载赋值运算符</p></li><li><p><strong>重载时需要注意哪些问题？</strong><br> 答：返回值的时候要返回引用，可以避免不必要的内存开销。</p></li><li><p><strong>为什么要有返回值？</strong><br> 答：可以允许连续赋值。</p></li><li><p><strong>如果出现类似于执行a=a的情况，代码应如何处理保证操作正确。</strong><br> 答：首先开辟一个新的动态空间，容量capacity与原对象相同，且将原对象中的数组值拷贝到新的动态空间中。然后释放当前对象的动态空间，并将数组指针指向刚刚开辟的新的动态空间首地址。</p></li><li><p><strong>说明重载下标操作[ ]的两个函数的异同，以及应用场景？</strong><br> 答：T&amp; operator<a href="int n"></a>返回第n个数组元素，允许通过返回的函数值修改所访问的数据。<br> const T&amp; operator<a href="int n"></a> const以常引用的方式返回第n个数组元素，返回的成员只读，不允许通过返回的函数值修改所访问的数据。一般不希望元素被修改的时候使用。</p></li><li><p><strong>针对自己的代码，考察插入和删除元素时的运行效率问题，动态分配空间的频率，以及可以如何提升效率？</strong><br> 答：插入元素时，需要n-pos+1次赋值，故时间复杂度为O(n)，其中在末尾插入时间复杂度是O(1)。但是一旦插入元素的个数大于容量，需要对数组进行扩容，即重新分配空间，该操作是O(n)的。<br> 删除元素时，需要n-pos次赋值，故时间复杂度也为O(n)，其中在末尾删除的时间复杂度为O(1)。删除元素的函数中没有释放多余空间，仅仅在清空函数中有释放所有空间的函数。<br> 所以由于每次当动态数组容量满了，都会将当前容量扩充至原先的两倍，所以动态分配空间的频率大约为logn。<br> 如果在删除时加上释放空间的代码，可以将节省空间利用率。也可以通过链表的方式提高插入删除元素时的效率。</p></li><li><p><strong>说明不同的构造函数中，初始化操作的方式以及意义。</strong><br> 答：vector_ss()是默认构造函数，开辟一个内存空间，v_size赋值为0，capacity赋值为1。<br> vector_ss(int n)是构造一个初始大小为n的数组的函数。分配n个连续的内存空间，v_size和capacity都赋值为n。<br> vector_ss(int n,T t)是构造一个初始大小为n的数组，且元素均为t的函数。分配n个连续的内存空间，且将每个变量赋值为t。v_size和capacity都赋值为n。<br> vector_ss(const vector_ss &amp;v)是拷贝对象v的构造函数。分配与对象v相同容量的连续内存，并拷贝v中数组的元素值。v_size和capacity分别赋值为v.size()与v.capacity。<br> vector_ss(const vector_ss &amp;v,int start,int end)是拷贝对象v中start位置到end位置的元素的构造函数。分配与对象v相同容量的连续内存，并拷贝v中数组的元素值。v_size和capacity分别赋值为end-start+1与v.capacity。</p></li></ol><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>类可以说是C++区别于C语言最重要的一个部分，也是我想要学习的重点。类和C语言中的结构体很相似，可以看作是在结构体的基础上改进的新东西。<br>这个实验本身并不要求算法或者什么需要理解的数据结构，仅仅是通过完成这样一个拥有多个功能的类的实验，来让我们更好的掌握C++这门语言。</p>]]></content>
    
    <summary type="html">
    
       
    
    </summary>
    
      <category term="计算机" scheme="http://kxjzxc.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
      <category term="程序" scheme="http://kxjzxc.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E7%A8%8B%E5%BA%8F/"/>
    
      <category term="C/C++" scheme="http://kxjzxc.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E7%A8%8B%E5%BA%8F/C-C/"/>
    
    
      <category term="C++" scheme="http://kxjzxc.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>基于C++的堆排序实现</title>
    <link href="http://kxjzxc.github.io/%E5%9F%BA%E4%BA%8EC++%E7%9A%84%E5%A0%86%E6%8E%92%E5%BA%8F%E5%AE%9E%E7%8E%B0.html"/>
    <id>http://kxjzxc.github.io/基于C++的堆排序实现.html</id>
    <published>2020-01-17T08:45:51.000Z</published>
    <updated>2020-01-17T14:01:34.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>大二上我选修了C++课，因为这门语言我从未学到其精妙之处，所以想要好好学一学。由于平时学业比较繁重，我没有时间将做过的四门实验与大作业发布到博客上。因此，趁着寒假空闲时间，我将落下的几篇博文一一补上。</p><p>第一个实验是用C++实现堆排序。虽然C++的STL库可以直接调用优先队列，实现与堆排序相同的功能，但是堆的思想还是有必要好好学一学。不过对我而言，都是学过的东西，稍微回忆一下也都记得个大概，敲起来也并不费事。</p><h1 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h1><p>首先将需要排序的所有元素建立成一个大顶堆。根据大顶堆的定义，父节点上的元素必然大于其子节点上的元素，因此在堆顶上的元素是堆中最大的。然后依次弹出堆顶的元素，即可得到一个有序的数组。</p><h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><p>建立大顶堆的时候，每次从堆底插入新元素，然后与其父节点比较，如果小于其父节点则不变。如果该节点大于其父节点，则与其父节点进行交换，然后再与新的父节点进行比较，重复上述操作直至小于父节点或者达到堆顶。<br><img src="基于C++的堆排序实现/堆排序.png" alt="建立堆"></p><p>删除堆顶元素时，将堆顶元素与堆底元素进行交换。然后维护剩下元素的大顶堆。将新的堆顶元素与其子节点中较大的那个进行比较，如果该元素比子节点小，则进行交换，然后重复上述操作，直到该元素比它的两个子节点都要大或者达到堆底。<br><img src="基于C++的堆排序实现/删除堆.png" alt="删除堆"></p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> n 6</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//函数模板，能够使得函数调用参数为任意类型</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="title">Swap</span><span class="params">(T &amp;a,T &amp;b)</span></span>&#123;</span><br><span class="line">    T t=a;</span><br><span class="line">    a=b;</span><br><span class="line">    b=t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//从堆底插入新的元素</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Insert</span><span class="params">(T h[],<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line"><span class="comment">//由于下标是从0开始，所以要在这里加一。</span></span><br><span class="line">k++;</span><br><span class="line"><span class="comment">//插入数从底部上升</span></span><br><span class="line">    <span class="keyword">while</span>(k&gt;<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">int</span> t=k/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(h[t<span class="number">-1</span>]&lt;h[k<span class="number">-1</span>])Swap(h[t<span class="number">-1</span>],h[k<span class="number">-1</span>]);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">        k=t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//删除堆顶的元素</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Delete</span><span class="params">(T h[],<span class="keyword">int</span> m)</span></span>&#123;</span><br><span class="line"><span class="comment">//将堆顶的元素与堆末尾的元素进行交换，即删除操作。</span></span><br><span class="line">Swap(h[<span class="number">0</span>],h[m]);</span><br><span class="line"></span><br><span class="line"><span class="comment">//调整堆，将堆顶的数下降。</span></span><br><span class="line">    <span class="keyword">int</span> k=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(k*<span class="number">2</span>&lt;m)&#123;</span><br><span class="line">        <span class="keyword">int</span> t=k*<span class="number">2</span>;</span><br><span class="line">        t--,k--;</span><br><span class="line">        <span class="keyword">if</span>(t+<span class="number">1</span>&lt;m&amp;&amp;h[t]&lt;h[t+<span class="number">1</span>])t++;</span><br><span class="line">        <span class="keyword">if</span>(h[t]&gt;h[k])Swap(h[t],h[k]);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">        k=t+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">heapSort</span><span class="params">(T h[])</span></span>&#123;</span><br><span class="line"><span class="comment">//通过插入过程实现建立堆</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)Insert(h,i);</span><br><span class="line"><span class="comment">//通过删除过程实现排序</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=n<span class="number">-1</span>;i&gt;<span class="number">0</span>;i--)Delete(h,i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出数组</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Print</span><span class="params">(T h[])</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)<span class="built_in">cout</span>&lt;&lt;h[i]&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>&lt;&lt;<span class="string">"====================="</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a[<span class="number">6</span>]=&#123;<span class="number">1</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">8</span>&#125;;</span><br><span class="line">    <span class="keyword">double</span> d[<span class="number">6</span>]=&#123;<span class="number">1.4</span>,<span class="number">4.3</span>,<span class="number">2.5</span>,<span class="number">3.7</span>,<span class="number">9.2</span>,<span class="number">0.8</span>&#125;;</span><br><span class="line">    <span class="keyword">char</span> c[<span class="number">6</span>]=&#123;<span class="string">'c'</span>,<span class="string">'d'</span>,<span class="string">'r'</span>,<span class="string">'a'</span>,<span class="string">'y'</span>,<span class="string">'b'</span>&#125;;</span><br><span class="line">    <span class="built_in">string</span> s[<span class="number">6</span>]=&#123;<span class="string">"hello"</span>,<span class="string">"yes"</span>,<span class="string">"byebye"</span>,<span class="string">"welcome"</span>,<span class="string">"good"</span>,<span class="string">"morning"</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//排序</span></span><br><span class="line">    heapSort(a);</span><br><span class="line">    heapSort(d);</span><br><span class="line">    heapSort(c);</span><br><span class="line">    heapSort(s);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>&lt;&lt;<span class="string">"排序结果："</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"======================"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    Print(a);</span><br><span class="line">    Print(d);</span><br><span class="line">    Print(c);</span><br><span class="line">    Print(s);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h2><p><img src="基于C++的堆排序实现/运行结果.png" alt="运行结果"></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>听说了函数模板这种东西之后，才惊觉stl库中的那些函数是通过这样的泛型编程实现的。<br>不过函数模板需要每个函数前都来那么一句，稍微有那么一点不是很舒服。<br>C++函数对于参数的灵活性调用也让我大吃一惊，虽然在此次实验中并没有体现到。</p>]]></content>
    
    <summary type="html">
    
       
    
    </summary>
    
      <category term="计算机" scheme="http://kxjzxc.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
      <category term="程序" scheme="http://kxjzxc.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E7%A8%8B%E5%BA%8F/"/>
    
      <category term="C/C++" scheme="http://kxjzxc.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E7%A8%8B%E5%BA%8F/C-C/"/>
    
    
      <category term="C++" scheme="http://kxjzxc.github.io/tags/C/"/>
    
      <category term="堆排序" scheme="http://kxjzxc.github.io/tags/%E5%A0%86%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>基于python的开机自动登陆网站</title>
    <link href="http://kxjzxc.github.io/%E5%9F%BA%E4%BA%8Epython%E7%9A%84%E5%BC%80%E6%9C%BA%E8%87%AA%E5%8A%A8%E7%99%BB%E9%99%86%E7%BD%91%E7%AB%99.html"/>
    <id>http://kxjzxc.github.io/基于python的开机自动登陆网站.html</id>
    <published>2019-11-03T01:52:06.000Z</published>
    <updated>2019-12-28T02:52:48.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>近日与同学聊天，我偶然了解到他写了一个自动登陆网站并且签到的脚本，马上有了兴趣。正好，我常常因每次开机都用登陆校园网而感到麻烦，索性就自己写一个能够自动登陆校园网的脚本。</p><h1 id="开发环境"><a href="#开发环境" class="headerlink" title="开发环境"></a>开发环境</h1><h2 id="系统"><a href="#系统" class="headerlink" title="系统"></a>系统</h2><p>window7<br>ubuntu18.04</p><h2 id="selenium库"><a href="#selenium库" class="headerlink" title="selenium库"></a>selenium库</h2><blockquote><p>Selenium 是一组软件工具集,每一个都有不同的方法来支持测试自动化。大多数使用 Selenium 的QA工程师只关注一两个最能满足他们的项目需求的工具上。然而，学习所有的工具你将有更多选择来解决不同类型的测试自动化问题。这一整套工具具备丰富的测试功能，很好的契合了测试各种类型的网站应用的需要。这些操作非常灵活，有多种选择来定位 UI 元素，同时将预期的测试结果和实际的行为进行比较。Selenium 一个最关键的特性是支持在多浏览器平台上进行测试。</p></blockquote><p><a href="https://www.kancloud.cn/wizardforcel/selenium-doc/102082" target="_blank" rel="noopener">中文文档</a></p><h3 id="安装库"><a href="#安装库" class="headerlink" title="安装库"></a>安装库</h3><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install selenium</span><br></pre></td></tr></table></figure><h3 id="查看库"><a href="#查看库" class="headerlink" title="查看库"></a>查看库</h3><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip show selenium</span><br></pre></td></tr></table></figure><h2 id="webdriver"><a href="#webdriver" class="headerlink" title="webdriver"></a>webdriver</h2><blockquote><p>Selenium 2.0 最主要的一个新特性就是集成了 WebDriver API。WebDriver 提供更精简的编程几口，以解决 Selenium-RC API 中的一些限制。WebDriver 为那些页面元素可以不通过页面重新加载来更新的动态网页提供了更好的支持。WebDriver 的目标是提供一套精心设计的面向对象的 API 来更好的支持现代高级 web 应用的测试工作。</p></blockquote><h3 id="win7-Chrome"><a href="#win7-Chrome" class="headerlink" title="win7+Chrome"></a>win7+Chrome</h3><p>我的window7系统上使用的浏览器是Chrome，所以我需要下载一个Chorme的webdriver<br>首先你需要知道知道你电脑上Chrome的版本，你可以在Chrome的help中找到。<br>然后进入下载的<a href="http://npm.taobao.org/mirrors/chromedriver/" target="_blank" rel="noopener">网站</a>，下载对应版本的webdriver。<br>我的Chrome是78版的，所以我也下载了78版<br><img src="基于python的开机自动登陆网站/webdriver.jpg" alt="webdriver下载"><br>接着将其解压，并移动到Chrome的安装目录（或者别的什么目录），并且添加的你的环境变量中的path中。</p><h3 id="ubuntu-firefox"><a href="#ubuntu-firefox" class="headerlink" title="ubuntu+firefox"></a>ubuntu+firefox</h3><p>我的ubuntu系统上使用的火狐浏览器，因此我需要下载火狐的驱动geckodriver<br>同样你需要知道知道你电脑上firefox的版本,然后进入下载的<a href="https://github.com/mozilla/geckodriver/releases" target="_blank" rel="noopener">网站</a>，下载对应版本。<br>下载到本地后，进入所在文件夹，打开终端并执行以下指令<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">tar -xvzf geckodriver*</span><br><span class="line">chmod +x geckodriver</span><br><span class="line">sudo mv geckodriver /usr/local/bin</span><br></pre></td></tr></table></figure></p><p>分别是解压，赋予权限，移动。</p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><p>开发环境搭建好了，接下来就可以代码了。<br>代码很简单，只有短短二十几行。<br>除了自动登陆校园网之外，我还增加了自动检测网络的功能。<br>如果网络尚未连接，那么程序将会不断地登陆校园网，直到检测到网络。<br>检测网络我用的是最简单的<code>ping</code>。<br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"><span class="comment">#linux的 ping 命令和windows不一样，会不断的发送包，所以使用ping -c 4 [ip/域名]来限制发包的次数</span></span><br><span class="line"><span class="keyword">while</span> os.system(<span class="string">'ping -c 4 www.kxjzxc.github.io'</span>):</span><br><span class="line"><span class="comment"># 打开浏览器，同时打开自己想要打开的网页</span></span><br><span class="line">url=<span class="string">'http://10.248.98.2/'</span></span><br><span class="line">driver=webdriver.Chrome(executable_path=<span class="string">"C:\\Program Files (x86)\\Google\\Chrome\\Application\chromedriver.exe"</span>)</span><br><span class="line"><span class="comment">#driver=webdriver.Firefox()</span></span><br><span class="line">driver.get(url) <span class="comment"># 打首登录页面，此处略去网址</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">username=<span class="string">"xxxxxxxxx"</span></span><br><span class="line">password=<span class="string">"xxxxxxxxxx"</span><span class="comment"># 用户名和密码是自己的</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 通过id定位搜索框，同时输入登录用户名密码</span></span><br><span class="line">driver.find_element_by_id(<span class="string">'username'</span>).clear()</span><br><span class="line">driver.find_element_by_id(<span class="string">'username'</span>).send_keys(username)</span><br><span class="line">driver.find_element_by_id(<span class="string">'password'</span>).clear()</span><br><span class="line">driver.find_element_by_id(<span class="string">'password'</span>).send_keys(password)</span><br><span class="line">driver.find_element_by_id(<span class="string">'login'</span>).click()</span><br><span class="line"></span><br><span class="line">driver.close();</span><br></pre></td></tr></table></figure></p><h1 id="设置开机自启"><a href="#设置开机自启" class="headerlink" title="设置开机自启"></a>设置开机自启</h1><p>脚本写完了，我们需要让它一开机就自动运行</p><h2 id="windows7"><a href="#windows7" class="headerlink" title="windows7"></a>windows7</h2><p>windows上的操作很简单。<br>首先打开启动文件夹（开始-&gt;所有程序-&gt;启动-&gt;右键打开）,然后自己新建一个bat文件，并以记事本的方式打开。<br>在bat文件中添加以下语句：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">python E:\Document\Autorun_program\network.py</span><br><span class="line">pause</span><br></pre></td></tr></table></figure></p><p>保存关闭，并且重启测试，完成。</p><h2 id="ubuntu"><a href="#ubuntu" class="headerlink" title="ubuntu"></a>ubuntu</h2><p>ubuntu上可能比较麻烦，我尝试了两种方法，但只实现了一种。</p><h3 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h3><p>第一个方法是通过设置rc.local开机启动命令/脚本来实现<br>这一篇<a href="http://www.r9it.com/20180613/ubuntu-18.04-auto-start.html" target="_blank" rel="noopener">博文</a>讲得比较详细，我这里就简单讲一下操作</p><ol><li><p>编辑以下脚本</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo gedit lib/systemd/system/rc.local.service</span><br></pre></td></tr></table></figure><p> 在末尾加上以下内容</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br><span class="line">Alias=rc-local.service</span><br></pre></td></tr></table></figure></li><li><p>创建并打开rc.local </p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo touch /etc/rc.local</span><br><span class="line">sudo gedit /etc/rc.local</span><br></pre></td></tr></table></figure><p> 在文件中写入指令</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">python /home/kermit/Documents/Autorun_program/network.py</span><br><span class="line"></span><br><span class="line">exit 0</span><br></pre></td></tr></table></figure></li><li><p>创建软链接</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ln -s /lib/systemd/system/rc.local.service /etc/systemd/system/</span><br></pre></td></tr></table></figure></li><li><p>重启测试</p></li></ol><p>不过以后还有脚本需要开机自启的话，应该只用编辑rc.local文件即可。<br>但是很可惜这种方法我并未实现，原因我也不是很清楚。</p><h3 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h3><p>第二个方法则是通过ubuntu自带的开机自启应用“Startup Application”来实现<br><img src="基于python的开机自动登陆网站/Startup.jpg" alt="Startup Application"><br>找到以上应用并打开，选择<code>Add</code>，即添加应用或脚本。<br><img src="基于python的开机自动登陆网站/addStartup.jpg" alt="Add Startup Application"><br>第一栏与第三栏添加名字和描述，可以随意填写。<br>在第二栏填写你想要运行的脚本命令。<br>点击保存，关闭。</p><p>此方法实测有效</p><h1 id="参考的资料"><a href="#参考的资料" class="headerlink" title="参考的资料"></a>参考的资料</h1><h2 id="ping命令"><a href="#ping命令" class="headerlink" title="ping命令"></a>ping命令</h2><h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ping(选项)(参数)</span><br></pre></td></tr></table></figure><h3 id="选项"><a href="#选项" class="headerlink" title="选项"></a>选项</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">-d：使用Socket的SO_DEBUG功能；</span><br><span class="line">-c&lt;完成次数&gt;：设置完成要求回应的次数；</span><br><span class="line">-f：极限检测；</span><br><span class="line">-i&lt;间隔秒数&gt;：指定收发信息的间隔时间；</span><br><span class="line">-I&lt;网络界面&gt;：使用指定的网络界面送出数据包；</span><br><span class="line">-l&lt;前置载入&gt;：设置在送出要求信息之前，先行发出的数据包；</span><br><span class="line">-n：只输出数值；</span><br><span class="line">-p&lt;范本样式&gt;：设置填满数据包的范本样式；</span><br><span class="line">-q：不显示指令执行过程，开头和结尾的相关信息除外；</span><br><span class="line">-r：忽略普通的Routing Table，直接将数据包送到远端主机上；</span><br><span class="line">-R：记录路由过程；</span><br><span class="line">-s&lt;数据包大小&gt;：设置数据包的大小；</span><br><span class="line">-t&lt;存活数值&gt;：设置存活数值TTL的大小；</span><br><span class="line">-v：详细显示指令的执行过程。</span><br></pre></td></tr></table></figure><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>ok，自动登陆校园网就那么完成了。<br>不得不说python是一个极其好用的工具，我甚至怀疑这门语言是面向非程序员开发的。<br>几个包，几行代码，就很好的辅助，真是舒服</p>]]></content>
    
    <summary type="html">
    
       
    
    </summary>
    
      <category term="计算机" scheme="http://kxjzxc.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
      <category term="程序" scheme="http://kxjzxc.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E7%A8%8B%E5%BA%8F/"/>
    
      <category term="Python" scheme="http://kxjzxc.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E7%A8%8B%E5%BA%8F/Python/"/>
    
    
      <category term="教程" scheme="http://kxjzxc.github.io/tags/%E6%95%99%E7%A8%8B/"/>
    
      <category term="python" scheme="http://kxjzxc.github.io/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>关于四害驱赶家用机器人声武器系统这个坑</title>
    <link href="http://kxjzxc.github.io/%E5%85%B3%E4%BA%8E%E5%9B%9B%E5%AE%B3%E9%A9%B1%E8%B5%B6%E5%AE%B6%E7%94%A8%E6%9C%BA%E5%99%A8%E4%BA%BA%E5%A3%B0%E6%AD%A6%E5%99%A8%E7%B3%BB%E7%BB%9F%E8%BF%99%E4%B8%AA%E5%9D%91.html"/>
    <id>http://kxjzxc.github.io/关于四害驱赶家用机器人声武器系统这个坑.html</id>
    <published>2019-09-02T09:45:02.000Z</published>
    <updated>2019-10-27T14:35:36.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script>    <div id="aplayer-bOUKeogU" class="aplayer aplayer-tag-marker meting-tag-marker" data-id="17822784" data-server="netease" data-type="song" data-mode="circulation" data-autoplay="false" data-mutex="true" data-listmaxheight="340px" data-preload="auto" data-theme="#555"></div><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>昨天早上，历时半年多的大一立项终于完成了最后的答辩。<br>“四害驱赶家用机器人声武器系统的研制”，这是去年年底我们的导师给毫无想法的我们选定的课题。在仓促的几天中完成立项并且答辩成功后，我们就在这个坑中渐行渐远。从一开始的一脸懵逼，充满怀疑，到最后的彻底绝望，自暴自弃，我们理所当然地并没有做出什么成果。<br>虽然这个项目做得一塌糊涂，而且无甚成果，但是……嗯，但是，好歹完成了答辩。心想着深压硬盘底也没什么用，倒不如发布到博客上，也算是给他人排排雷。</p><h1 id="课题背景"><a href="#课题背景" class="headerlink" title="课题背景"></a>课题背景</h1><p>自古以来，四害问题一直困扰着人类。<br>传统的驱逐和消灭方法效率低。经过网上国内外的查询，发现并没有较为有效的驱逐四害的方法，大多数是以人为驱逐的方式，但效率不高；也有药物驱逐，但对人体的身体健康有着危害。</p><p>我们小组决定使用人耳听觉频段范围外的声波驱逐四害，原因主要有：</p><ol><li>由于声波本身是无形的，所以并不会像化学药剂一样污染环境。</li><li>将声波调到合理的强度，对人的危害远小于化学药剂所造成的危害。</li><li>不会对人的日常生活工作造成影响。</li></ol><p>综上所述，我组决定制作出一种小型的，能够发出可以让四害感到不适却又在人耳听觉频段范围外的声波驱逐四害，且具有指向性的声武器装置，并将其装在可自动导航的小车之上，使其可以边运动边发出次声以驱逐四害。</p><h1 id="开始探索"><a href="#开始探索" class="headerlink" title="开始探索"></a>开始探索</h1><p>通过查阅资料以及导师的指导，我组在经过多次讨论之后，确定了两个不同的声武器驱逐四害的方案。<br>两个方案分别是次声波驱逐方案和高功率超声波驱逐方案。以下是两个方案的详细介绍。</p><h2 id="次声波驱逐方案"><a href="#次声波驱逐方案" class="headerlink" title="次声波驱逐方案"></a>次声波驱逐方案</h2><h3 id="研究"><a href="#研究" class="headerlink" title="研究"></a>研究</h3><p>根据了解，次声波频率与生物体自身的振荡频率相似，容易发生共振，产生极大能量，使四害感到不适，达到驱逐的效果。<br>因此，可以搭建一个可控次声装置，使其朝设定方向发射强次声波，达到驱除四害的目的。<br>在研究如何产生次声波方面，我组通过大量的资料查询以及数学公式推断，发现<strong>两束频率相近的声波可以在空气中线性叠加产生频率为差频的次声波</strong>。<br>公式推导如下：<br>假设两列振幅相同的，频率不同的次声波：<br>$φ1(t,x)＝Asin(ω1t＋k1x)φ2(t,x)＝Asin(ω2t＋k2x)$<br>相加并通过一系列三角变换可得：<br>$φ(t,x)＝2Acos(ωt＋kx)cos(ω′t＋k′x)$<br>$ω＝(ω1＋ω2)╱2ω′＝(ω1－ω2)╱2k＝(k1＋k2)╱2k′＝(k1－k2)╱2$</p><p>由此可得叠加后产生了一个振动频率为和频，振幅变化频率为差频的波形。</p><p>以下是在MATLAB仿真出来的两组结果：<br><img src="关于四害驱赶家用机器人声武器系统这个坑/图1.png" alt="图1.波频率1000hz和1020hz的MATLAB仿真程序"><br><img src="关于四害驱赶家用机器人声武器系统这个坑/图2.png" alt="图2.波频率1000hz和1020hz的仿真结果图"><br><img src="关于四害驱赶家用机器人声武器系统这个坑/图3.png" alt="图3.波频率22700hz和22720hz的MATLAB仿真程序"><br><img src="关于四害驱赶家用机器人声武器系统这个坑/图4.png" alt="图4.波频率22700hz和22720hz的仿真结果图"></p><p>仿真的结果验证了我们的猜测，两束频率相近的声波的确可以在空气中线性叠加产生频率为差频的次声波。根据这个性质，我们可以先产生两束高频波，然后通过一定的相位差，使其在空气中线性叠加产生次声波。</p><h3 id="难题"><a href="#难题" class="headerlink" title="难题"></a>难题</h3><p>在实施次声波方案的过程中，我组遇到了两个难以克服的困难：</p><ol><li><strong>难以产生两束频率相差小于20hz的超声波</strong><br> 我们产生次声波的方案是通过两束频率相近的超声波在空气中线性叠加后产生频率为差频的次声波。因此我们需要先产生两束频率相近的超声波。现有的产生超声波的方式为通过探头将正弦波或是方波转换为同频率的声波，然而这种方式非常依赖硬件，也就是探头。每一种探头的型号只能够加载相应频率的信号波，并发出同种频率的超声波。比如40khz的探头只能够加载40khz的信号波，发出40khz的超声波。<br> 市面上探头的种类有很多，我们能够找到23khz、25khz、40khz等型号的探头，但是大多相差好几k频率，与之相比20hz的差频几乎可以忽略不记。因此在如今硬件水平上，我们难以寻找适合我们的，可以产生两束频率差小于20hz的探头。</li><li><strong>市面上买不到合适且有效的次声波传感器</strong><br> 虽然我们的方案并不需要检测产生的次声波，但是在实验过程中检测次声波却是必不可少的。我们不仅需要通过检测次声波来验证我们是否成功产生我们所需要的次声波，还需要记录产生次声波的频率对于实验对象的影响程度。<br> 检测次声波需要相应的硬件，也就是次声传感器。不同于检测非次声的传感器，市面上几乎没有合适的次声波传感器。虽有极少数的商品贩卖，但是不仅价格昂贵，而且多为接触式传感器，完全不符合我们的需求。而网络上虽有许多关于次声波传感器研发的论文与专利，但是大多需要特殊的材料或者不是非常靠谱的理论，以我们的能力很难去自己搭建合适的次声传感器。</li></ol><p>因此次声波方案无法实现。</p><h2 id="高功率超声波驱逐方案"><a href="#高功率超声波驱逐方案" class="headerlink" title="高功率超声波驱逐方案"></a>高功率超声波驱逐方案</h2><h3 id="研究-1"><a href="#研究-1" class="headerlink" title="研究"></a>研究</h3><p>通过查阅资料，我组得知有特定频率的超声波会令害虫或者老鼠的听觉系统感到不适的声音（<strong>此已被证伪</strong>）。因此可以使用超声波来驱逐四害（基本上不行）。<br>根据我组的调查，市场上已有许多使用超声波驱逐四害的装置，像是超声波驱鼠器、超声波驱蚊器之类的，但是效果大多不够显著。我组认为是超声波的功率不够导致达到所需的目的。<br>已知超声波传播带来的能量与超声波的功率有关，如果能够将超声波的功率放大，发出的声场就可以具有高强度的能量，起到驱赶四害的效果。<br>所以如何产生高功率的超声波就成为了我组的研究内容。<br>在这方面，我组的想法是通过放大器模块放大由单片机和dds模块产生的正弦信号波，再加载到相应频率的探头上。<br>为此，我组制定了以下初步方案：</p><ol><li>首先通过程序使单片机发出频率控制字，分别输入到dds模块中。</li><li>由dds模块产生高频率的正弦波信号。</li><li>使用放大器模块将产生的正弦波信号放大功率，然后加载到相应频率的超声探头上。</li></ol><p>大致结构如下图所示：<br><img src="关于四害驱赶家用机器人声武器系统这个坑/图5.png" alt="图5. 高功率超声波电路结构"><br>我们采用的放大器模块为LM386，但是事实上，市面上的放大器模块的放大功率的效果并不是特别好，在限定工作电压范围内，大多无法满足放大到我们需求的倍数，所以我们需要寻找另一种放大超声波功率的方案。<br>受到我们的师兄正在研究基于相控阵的超声悬浮的启发，我组认为通过使用多个探头组成相控阵，发出相同频率的超声波，并且调整激励信号与声源的几何位置，使其满足一定的关系，可以将产生的超声波能够在某一固定点处相叠加，产生高强度的声波能量，从而达到放大功率的效果。<br>根据师兄提供的论文，该相列阵的电路结构大致如图所示：<br><img src="关于四害驱赶家用机器人声武器系统这个坑/图6.png" alt="图6. 超声阵列电路结构图"><br>用FPGA电路板作为控制模块，将信号传递给驱动板。然后由驱动板驱动相应的排成阵列的探头，产生相应频率的超声波。超声波将在空气中某一点聚焦，成为高功率的声波。<br>但是由于我组能力上的不足，尽管理论与方案都已给出，未能完成超声相控阵列，只能完成使用放大器模块放大超声波的方案。</p><h3 id="实验结果"><a href="#实验结果" class="headerlink" title="实验结果"></a>实验结果</h3><p>以下是我们通过示波器检测到波功率的结果。</p><div class="table-container"><table><thead><tr><th style="text-align:left">放大器外接电压/V</th><th style="text-align:center">波频率/HZ</th><th style="text-align:center">正弦波信号/接收到的超声波</th><th>峰值/V</th></tr></thead><tbody><tr><td style="text-align:left">5</td><td style="text-align:center">23k</td><td style="text-align:center">接收到的超声波</td><td>15.4</td></tr><tr><td style="text-align:left">5</td><td style="text-align:center">40k</td><td style="text-align:center">接受到的超声波</td><td>46.4</td></tr><tr><td style="text-align:left">5</td><td style="text-align:center">40k</td><td style="text-align:center">正弦波信号</td><td>10.8</td></tr><tr><td style="text-align:left">11</td><td style="text-align:center">23k</td><td style="text-align:center">正弦波信号</td><td>25.6</td></tr><tr><td style="text-align:left">11</td><td style="text-align:center">40k</td><td style="text-align:center">正弦波信号</td><td>44</td></tr><tr><td style="text-align:left">11</td><td style="text-align:center">40</td><td style="text-align:center">接收到的超声波</td><td>102</td></tr></tbody></table></div><p><img src="关于四害驱赶家用机器人声武器系统这个坑/图7.png" alt="图7. 外加11V电压时40khz正弦波信号，峰值为44V"><br><img src="关于四害驱赶家用机器人声武器系统这个坑/图8.png" alt="图8. 外加11V电压时接受到的40khz超声波波形，峰值为102V"><br>虽然我们利用放大器成功放大了产生的超声波，但是放大的倍数仅为原先的两倍，效果不是非常的好。<br>而且由于各种现实条件以及自身经验缺乏的原因，我组未能定制最后检验效果的实验方案，没有进行最终的检测。<br>首先是实验动物的缺失，学校里没有动物中心这类地方，我组也未能联系到提供实验动物的机构。如果自己捕获四害的话，没有合适的处理方式，会导致实验的正确性不高。再有我组并没有动物实验的经验，对于实验的步骤与实验结果的分析都毫无头绪。</p><p><strong>综上所述，我们的方案并没能经过实验的验证。</strong></p><h1 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h1><p>如果你看完了这篇博文，你自然可以明白我们的项目是多么的水，多么的不切实际。不仅硬件上碰到困难，理论上无法证实，动物实验不会做，本身能学到的东西也是少的可怜。<br>我们最初的方案就只有次声波，超声波的方案是次声波方案确认无法继续之后才临时决定的，虽然这个方案从原理上就是错误的。<br><a href="https://www.guokr.com/article/49122/" target="_blank" rel="noopener">声波驱蚊？一直在坑爹，从未生过效</a></p><p>做到最后，我们只剩下拿到这门课的学分这一目的。用尽全力充实自己的报告和ppt，将自己的项目包装成很丰富，很充实的样子。但无论再怎么充实，终究也只是伪物，看到别组诸如体感小车，寻物机器人之类的牛逼项目，还是忍不住叹气，感觉自己浪费了大一立项的大好机会。</p><p>说到底应该算是最初项目选择上的锅。<strong>本来就没有什么经验的大一学生，应该选择在已有的成熟的产品基础上进行二次开发，而不是愣头青一般往不怎么可靠的方向乱窜。</strong>虽然我们也是往小车上安装声武器，但是声武器本身就没有成熟的理论支持，而且极其依赖硬件设施。而这些都成为了阻挡我们的高墙，逐渐消磨我们的热情，也慢慢浪费着我们的时间，因为我们基本上没能从中获得的我们所需要的东西和热情。</p><p>相比于这个不适合我们的项目，我觉得我实习期间所做的机械臂项目都要有用高级的多。而有时我脑海中也会蹦出几个容易做且有趣的项目，像是自主移动的风扇机器人之类的，只可惜立项之时脑袋中空空如也。</p><p>事到如今，大一项目也已经结束，该水的也水完了，除了叹气并总结一下经验也没有什么可以改变的。听说大二还有大创，希望这次我能够做出个好东西来。</p>]]></content>
    
    <summary type="html">
    
       
    
    </summary>
    
      <category term="项目" scheme="http://kxjzxc.github.io/categories/%E9%A1%B9%E7%9B%AE/"/>
    
    
      <category term="项目" scheme="http://kxjzxc.github.io/tags/%E9%A1%B9%E7%9B%AE/"/>
    
  </entry>
  
  <entry>
    <title>基于OpenCV和Zbar的识别二维码控制机械臂</title>
    <link href="http://kxjzxc.github.io/%E5%9F%BA%E4%BA%8EOpenCV%E5%92%8CZbar%E7%9A%84%E8%AF%86%E5%88%AB%E4%BA%8C%E7%BB%B4%E7%A0%81%E6%8E%A7%E5%88%B6%E6%9C%BA%E6%A2%B0%E8%87%82.html"/>
    <id>http://kxjzxc.github.io/基于OpenCV和Zbar的识别二维码控制机械臂.html</id>
    <published>2019-08-13T08:55:14.000Z</published>
    <updated>2019-10-27T14:29:04.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在越疆实习的时候并没有问部门里的人自己该干什么，所以似乎也没有什么任务交给我做。由于在培训的时候接触到了ROS，也就顺水推舟地朝着这个方向学了下去。第一周学习用ROS控制机械臂，消息、服务、启动文件之类的也都了解了大概。接下来就试着朝Opencv这一方面研究，在完成打开摄像头，人脸识别等简单项目后，我脑中浮现出了这个项目，二维码控制机器人。<br>这个构思的诞生，说来也是意外之思。当时我做完人脸识别项目后，看到《ROS机器人开发实践》这本书上后面的二维码识别,联想到其他班的同学的一个轮式机器人编队的项目，听说他那个项目中是通过二维码来确定小车的位置。于是我就想，我是不是也可以通过二维码传输指令给机械臂，以此控制机械臂运动呢？深入思考之后，发现可行，网上也有识别二维码的代码，只要将两者合在一块就能实现了。<br>虽说书上是有二维码识别的讲述，但是我并没有采用上面的方法。原因很简单，因为我并没有向部门里的人要摄像头，所以我现有的设备除了机械臂和气泵装置外，只有我笔记本自带的摄像头了。而书上的方法第一步就将我卡住了，因为它需要标定摄像头。我寻思着我这破摄像头也没法标定啊，只能放弃这个方法。所幸，根据之前做人脸识别的经验，我想到只要对摄像头获取的每一帧进行图像处理，即视觉识别即可。<br>终于，经过几天的查资料，自己折腾，我顺利做出了一个简单的版本。</p><h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>运用OpenCV库调取摄像头的画面，然后使用Zbar库中的函数扫描画面，获取画面中存在的二维码的信息，并以ros消息的形式发布到话题上，由客户端节点订阅到话题上的消息后，调用加载到服务端的动态链接库来控制机械臂执行相应的命令</p><h1 id="搭建开发环境"><a href="#搭建开发环境" class="headerlink" title="搭建开发环境"></a>搭建开发环境</h1><h2 id="Linux系统"><a href="#Linux系统" class="headerlink" title="Linux系统"></a>Linux系统</h2><p>我使用的是Ubuntu 18.04。安装Linux系统的教程网上很多，自行寻找。</p><h2 id="机器人操作系统ROS"><a href="#机器人操作系统ROS" class="headerlink" title="机器人操作系统ROS"></a>机器人操作系统ROS</h2><p>从官网上安装对应linux系统的ROS，步骤很详细，一步一步照做即可</p><h2 id="OpenCV库"><a href="#OpenCV库" class="headerlink" title="OpenCV库"></a>OpenCV库</h2><p>ROS中已经集成了OpenCV库以及相关接口功能包，如果你安装的是全桌面版的ROS，那么电脑中大概已经有OpenCV了。如果电脑中并没有OpenCV，那么可以通过以下命令来安装：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt-get install ros-kinetic-vision-opencv libopencv-dev python-opencv</span><br></pre></td></tr></table></figure></p><p>其中ros-kinetic-vision-opencv中的kinetic可以替换成相应的ros版本</p><h2 id="Zbar库"><a href="#Zbar库" class="headerlink" title="Zbar库"></a>Zbar库</h2><blockquote><p>ZBar是一个开源库,用于扫描、读取二维码和条形码。</p></blockquote><p>通过Zbar，我们可以扫描图像，检测其中的二维码，并且解析出其中的消息。<br>要在Ubuntu中使用Zbar，我们首先要安装Zbar库。下面是安装步骤：</p><ol><li><p>通过命令行直接下载zbar</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ wget http://downloads.sourceforge.net/project/zbar/zbar/0.10/zbar-0.10.tar.gz</span><br></pre></td></tr></table></figure></li><li><p>进入压缩包所在的文件夹直接解压</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ tar -zvxf zbar-0.10.tar.gz</span><br></pre></td></tr></table></figure></li><li><p>安装相关依赖</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt-get install python-gtk2-dev</span><br><span class="line">$ sudo apt-get install libqt4-dev</span><br></pre></td></tr></table></figure></li><li><p>编译Zbar</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ ./configure --enable-shared --disable-video --without-python --without-gtk --without-qt --without-imagemagick CFLAGS=&quot;&quot;</span><br><span class="line">$make </span><br><span class="line">$sudo make install</span><br><span class="line">$sudo ldconfig</span><br></pre></td></tr></table></figure></li><li><p>运行examples</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$cd example</span><br><span class="line">$gcc scan_image.c -o scan_image -lzbar -lpng</span><br><span class="line">$./scan_image barcode.png</span><br></pre></td></tr></table></figure><p> 输出结果：</p><pre><code> decoded EAN-13 symbol &quot;9876543210128&quot;</code></pre></li></ol><h1 id="运行流程"><a href="#运行流程" class="headerlink" title="运行流程"></a>运行流程</h1><p>先由qrcode包中的my_pulisher节点打开摄像头，获取画面并且以消息的形式发布到话题“camera/image”上。<br>然后由my_subscriber节点扫描从话题“camera/image”上订阅到的图像。如果从图像中扫描到图像中的二维码，那么将解析出来的指令信息发布到话题“GetCtrl_msg”上。<br>最后由dobot包中的DobotClient_PTP节点订阅话题”GetCtrl_msg”上的指令，并根据指令，向服务端DobotServer节点请求相应的服务，控制机械臂。</p><h1 id="代码分析"><a href="#代码分析" class="headerlink" title="代码分析"></a>代码分析</h1><p><a href="https://github.com/kxjzxc/ROS_demo" target="_blank" rel="noopener">代码位置</a></p><h2 id="my-publisher"><a href="#my-publisher" class="headerlink" title="my_publisher"></a>my_publisher</h2><p>该节点是打开摄像头，并获取摄像头图像消息，发布到话题”camera/image”的代码。</p><p>程序1.1加载ROS、Opencv头文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;ros/ros.h&gt;  </span><br><span class="line">#include &lt;image_transport/image_transport.h&gt;  </span><br><span class="line">#include &lt;opencv2/highgui/highgui.hpp&gt;  </span><br><span class="line">#include &lt;cv_bridge/cv_bridge.h&gt;  </span><br><span class="line">#include &lt;sstream&gt; // for converting the command line parameter to integer</span><br></pre></td></tr></table></figure></p><p>程序1.2初始化节点<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ros::init(argc, argv, &quot;image_publisher&quot;);</span><br><span class="line">ros::NodeHandle nh;</span><br></pre></td></tr></table></figure></p><p>程序1.3注册话题到ROS Master上<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">image_transport::ImageTransport it(nh);  </span><br><span class="line">image_transport::Publisher pub = it.advertise(&quot;camera/image&quot;, 1);  //在发布图像消息时消息队列的长度只能是1</span><br></pre></td></tr></table></figure></p><p>程序1.4 打开摄像头<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">// Convert the passed as command line parameter index for the video device to an integer</span><br><span class="line">int video_source;  </span><br><span class="line">bool check=ros::param::get(&quot;/image_publisher/video&quot;,video_source);</span><br><span class="line"></span><br><span class="line">/*检查视频源是否已作为参数传递*/ </span><br><span class="line">if(check == 0)   </span><br><span class="line">&#123;  </span><br><span class="line">    ROS_INFO(&quot;no camera %d\n&quot;,video_source);  </span><br><span class="line">    return 1;  </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">cv::VideoCapture cap(video_source);  </span><br><span class="line">//判断视频读取或者摄像头调用是否成功</span><br><span class="line">if(!cap.isOpened())   </span><br><span class="line">&#123;  </span><br><span class="line">    ROS_INFO(&quot;can not opencv video device\n&quot;);  </span><br><span class="line">    return 1;  </span><br><span class="line">&#125;  </span><br><span class="line">程序1.5 发布摄像头图像消息到话题”camera/image”上</span><br><span class="line">//ROS中的图像消息类型</span><br><span class="line">sensor_msgs::ImagePtr msg;  </span><br><span class="line">ros::Rate loop_rate(5);  </span><br><span class="line">while (nh.ok()) </span><br><span class="line">&#123;  </span><br><span class="line">    cap &gt;&gt; frame;  </span><br><span class="line">    // Check if grabbed frame is actually full with some content  </span><br><span class="line">    if(!frame.empty()) </span><br><span class="line">    &#123;  </span><br><span class="line">     //将opencv格式的图像转化为ROS所支持的消息类型</span><br><span class="line">            msg = cv_bridge::CvImage(std_msgs::Header(), &quot;bgr8&quot;, frame).toImageMsg();  </span><br><span class="line">            pub.publish(msg);  </span><br><span class="line">            //cv::Wait(1);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="my-subscriber"><a href="#my-subscriber" class="headerlink" title="my_subscriber"></a>my_subscriber</h2><p>该节点则是将订阅到的图像消息进行图像处理，即二维码识别。<br>在识别到二维码后，将解析出来的信息以消息的形式发布到话题”GetCtrl_msg”上。<br>其中，wait这个变量是为了在识别过后等待一段时间在识别下一个二维码。</p><p>程序2.1 加载ROS，OpenCV，Zbar的头文件和命名空间<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;ros/ros.h&gt;  </span><br><span class="line">#include &quot;std_msgs/String.h&quot;</span><br><span class="line"></span><br><span class="line">#include &quot;iostream&quot;</span><br><span class="line">#include &quot;string.h&quot;</span><br><span class="line">#include &quot;fstream&quot;</span><br><span class="line">#include &quot;signal.h&quot;</span><br><span class="line">#include &lt;termios.h&gt;</span><br><span class="line">#include &lt;math.h&gt;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;sys/poll.h&gt;</span><br><span class="line">#include &lt;boost/thread/thread.hpp&gt;</span><br><span class="line"></span><br><span class="line">#include &quot;opencv2/core/core.hpp&quot; </span><br><span class="line">#include &quot;opencv2/highgui/highgui.hpp&quot; </span><br><span class="line">#include &quot;opencv2/imgproc/imgproc.hpp&quot; </span><br><span class="line">#include &lt;opencv2/opencv.hpp&gt;</span><br><span class="line"></span><br><span class="line">#include &lt;image_transport/image_transport.h&gt;  </span><br><span class="line">#include &lt;cv_bridge/cv_bridge.h&gt;  </span><br><span class="line">#include &lt;zbar.h&gt;</span><br><span class="line">#define oo 1e9+7</span><br><span class="line">using namespace std;</span><br><span class="line">using namespace zbar;  //添加zbar名称空间      </span><br><span class="line">using namespace cv;</span><br></pre></td></tr></table></figure></p><p>程序 2.2 初始化节点，窗口，并注册发布和订阅的话题<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ros::init(argc, argv, &quot;image_listener&quot;);  </span><br><span class="line">ros::NodeHandle nh;  </span><br><span class="line">cv::namedWindow(&quot;Source Image&quot;);  </span><br><span class="line">//开始窗口线程</span><br><span class="line">cv::startWindowThread();  </span><br><span class="line">image_transport::ImageTransport it(nh);  </span><br><span class="line">signal(SIGINT, MySigintHandler);</span><br><span class="line">ros::Publisher pub=nh.advertise&lt;std_msgs::String&gt;(&quot;GetCtrl_msg&quot;,1000);</span><br><span class="line">image_transport::Subscriber sub = it.subscribe(&quot;camera/image&quot;, 1,boost::bind(&amp;imageCallback,_1,boost::ref(pub)));</span><br></pre></td></tr></table></figure></p><p>程序2.3 订阅到图像消息后回调函数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">void imageCallback(const sensor_msgs::ImageConstPtr&amp; msg,ros::Publisher pub)  </span><br><span class="line">&#123;  </span><br><span class="line">    try  </span><br><span class="line">    &#123;  </span><br><span class="line">Mat image=cv_bridge::toCvShare(msg, &quot;bgr8&quot;)-&gt;image;</span><br><span class="line">imshow(&quot;Source Image&quot;, image);</span><br><span class="line">if(wait==100)&#123;</span><br><span class="line">wait=-1;</span><br><span class="line">ROS_INFO(&quot; Continue to identify &quot;);</span><br><span class="line">&#125; </span><br><span class="line">else if(wait!=-1)&#123;</span><br><span class="line">wait++;</span><br><span class="line">return;</span><br><span class="line">&#125;</span><br><span class="line">cvtColor(image, image, CV_RGB2GRAY);</span><br><span class="line"></span><br><span class="line">if(Scan(image,pub))&#123;</span><br><span class="line">wait=0;</span><br><span class="line">&#125;</span><br><span class="line">        //waitKey(30);  </span><br><span class="line">    &#125;  </span><br><span class="line">    catch (cv_bridge::Exception&amp; e)  //异常处理</span><br><span class="line">    &#123;  </span><br><span class="line">        ROS_ERROR(&quot;Could not convert from &apos;%s&apos; to &apos;bgr8&apos;.&quot;, msg-&gt;encoding.c_str());  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>程序2.4 使用Zbar库识别二维码并发布解析出来的消息<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">bool Scan(Mat image,ros::Publisher pub)&#123;</span><br><span class="line">//zbar类，定义扫描器</span><br><span class="line">ImageScanner scanner;</span><br><span class="line">//配置参数，初始化</span><br><span class="line">scanner.set_config(ZBAR_NONE, ZBAR_CFG_ENABLE, 1);</span><br><span class="line"></span><br><span class="line">int width = image.cols;</span><br><span class="line">int height = image.rows;</span><br><span class="line">uchar *raw = (uchar *)image.data;</span><br><span class="line">//封装图像数据 Y800单色图像格式</span><br><span class="line">Image imageZbar(width, height, &quot;Y800&quot;, raw, width * height);</span><br><span class="line"></span><br><span class="line">//扫描条码或者二维码</span><br><span class="line">scanner.scan(imageZbar);</span><br><span class="line"></span><br><span class="line">for (Image::SymbolIterator symbol = imageZbar.symbol_begin(); symbol != imageZbar.symbol_end(); ++symbol)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;类型：&quot; &lt;&lt; endl &lt;&lt; symbol-&gt;get_type_name() &lt;&lt; endl &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; &quot;二维码：&quot; &lt;&lt; endl &lt;&lt; symbol-&gt;get_data() &lt;&lt; endl &lt;&lt; endl;</span><br><span class="line">    //发布消息到话题“GetCtrl_msg”上</span><br><span class="line">std_msgs::String msg;</span><br><span class="line">msg.data=symbol-&gt;get_data();</span><br><span class="line">pub.publish(msg);</span><br><span class="line">imageZbar.set_data(NULL, 0);</span><br><span class="line">return 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//清除缓存</span><br><span class="line">imageZbar.set_data(NULL, 0);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="DobotClient-PTP"><a href="#DobotClient-PTP" class="headerlink" title="DobotClient_PTP"></a>DobotClient_PTP</h2><p>该节点是订阅话题”GetCtrl_msg”上的指令消息，并做出相应的行为。<br>程序3.1 初始化节点<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ros::init(argc, argv, &quot;DobotClient&quot;);</span><br><span class="line">ros::NodeHandle n;</span><br></pre></td></tr></table></figure></p><p>程序3.2 注册订阅器<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ros::Subscriber sub = n.subscribe&lt;std_msgs::String&gt;(&quot;GetCtrl_msg&quot;, 1000,messageCallback);</span><br></pre></td></tr></table></figure></p><p>程序3.3 回调函数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">void messageCallback(const std_msgs::String::ConstPtr &amp;msg)&#123;</span><br><span class="line">std::string cmd=msg-&gt;data.c_str();</span><br><span class="line">if(cmd==&quot;0&quot;)DobotHome();</span><br><span class="line">else if(cmd==&quot;1&quot;)Action();</span><br><span class="line">else if(cmd==&quot;2&quot;)getPoint();</span><br><span class="line">else if(cmd==&quot;3&quot;)Point.clear();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>以上DobotHome(),Action(),getPoint()函数中就是通过服务请求的方式向 DobotServer节点请求相应的服务，此处并未展现。</p><h1 id="结果测试"><a href="#结果测试" class="headerlink" title="结果测试"></a>结果测试</h1><p>启动ros master<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ roscore</span><br></pre></td></tr></table></figure></p><p>打开新终端，运行DobotServer<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ rosrun dobot DobotServer</span><br></pre></td></tr></table></figure></p><p>打开新终端，启动launch文件，可同时打开qrcode功能包中的my_subscriber和my_publisher节点，dobot功能包中的DobotClient_PTP和DobotClient_GetInfor。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ roslaunch qrcode camera.launch</span><br></pre></td></tr></table></figure></p><p>启动文件成功运行后，将含有指令信息的二维码对准摄像头，控制机械臂运动。<br>0 回零 1 执行 2 记录点位 3 清空点位<br>通过按下机械臂上的解锁按钮，手动移动机械臂。当松开按钮时，机械臂将自动记录末端点位。<br>以上操作也可以通过键盘来操控机械臂运动，按下0～3相应的按键可操作。按Ctrl+C可终止启动文件。<br><img src="基于OpenCV和Zbar的识别二维码控制机械臂/识别二维码成功.png" alt="识别二维码成功"></p><h1 id="不足之处"><a href="#不足之处" class="headerlink" title="不足之处"></a>不足之处</h1><ol><li>实现的功能过少</li><li>有时候会一下子识别好几次二维码，原因不明。</li><li>其实很多节点都可以合并成一处。不过分到不同节点上去也可以使人对于节点间的通讯更加了解。</li></ol><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>这个项目可以说是把我这一个月来所学的东西都揉在一块，ROS、OpenCV、Zbar……作为我本次实习出来的结果也算是令人满意。<br>原本作为一个大一刚刚结束的学生，其实根本没想过自己实习的时候能做些什么，毕竟一开始什么也不会，ROS,OpenCV这些也只不过是听过而已。但是经过三个周的自我探索，对这些东西也有了一个初步的了解，对于脑中时不时浮现的奇思妙想也有更加具体的构思，而并非以前那样的天马行空，形而上学。</p><p>大一实习生到底能做些什么呢？<strong>我觉得什么都做不了，但什么都能做</strong>。</p><p>毕竟大一接触的专业知识并不多，大多还只是通识教育。若是在实习初期就告诉我要做个balabala玩意我估计会一脸懵逼，不知所云。<br>但是我不会毫无办法，甚至逃避现实。因为我深知工作中所运用的大部分知识都根本没有必要非得在学校里学习，这些只是完全是可以通过自学来掌握的。没有学过的东西，只要不是必须需要非常高深的理论知识，我们完全可以现学现用。像是ROS和OpenCV这类东西，学校里一般是不会教学生的，基本上需要学生自学掌握。<br>在做项目的过程中也不一定非要完全掌握了某样东西才能去做。学海无涯，bug不止，哪有人能百分百的精通一个技能。人总会遇到自己无法解决的问题，这个时候只要百度，谷歌一下，总能找到解决方法。</p><p><strong>重要的，是耐下心来，脚踏实地，慢慢探索。</strong></p><p>我其实很感谢我高中学习竞赛的那段经历。<br>虽然我并没有获得完美的收场，但是我的确收获了很多。<br>编程的入门，算法的理解，搜索的方法，以及……自学的觉悟。<br>因为在看题解的时候，我常常会遇到一些我没有学过的，老师也没讲过（虽然老师很少讲东西）的新算法或者数据结构。一开始，我大惊小怪，感到很坑，怀着这玩意是高级货的心态去学习，弄得自己好像是刚出新手村就碰见四大天王的勇者。然而后来这种事情经历的多了，也就习以为常了，碰到不懂的东西？莽就完事了。对我而言，很少有东西是自学学不会的（动手操作除外），只要肯投入实践，到处查资料，自己折腾一番，最后总能搞出个所以然来。</p><p>此文到此结束，感谢观看。</p>]]></content>
    
    <summary type="html">
    
       
    
    </summary>
    
      <category term="计算机" scheme="http://kxjzxc.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
      <category term="程序" scheme="http://kxjzxc.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E7%A8%8B%E5%BA%8F/"/>
    
      <category term="OpenCv" scheme="http://kxjzxc.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E7%A8%8B%E5%BA%8F/OpenCv/"/>
    
    
      <category term="ROS" scheme="http://kxjzxc.github.io/tags/ROS/"/>
    
      <category term="OpenCv" scheme="http://kxjzxc.github.io/tags/OpenCv/"/>
    
  </entry>
  
  <entry>
    <title>关于我重装ubuntu系统后所做的那些事</title>
    <link href="http://kxjzxc.github.io/%E5%85%B3%E4%BA%8E%E6%88%91%E9%87%8D%E8%A3%85ubuntu%E7%B3%BB%E7%BB%9F%E5%90%8E%E6%89%80%E5%81%9A%E7%9A%84%E9%82%A3%E4%BA%9B%E4%BA%8B.html"/>
    <id>http://kxjzxc.github.io/关于我重装ubuntu系统后所做的那些事.html</id>
    <published>2019-08-07T03:52:18.000Z</published>
    <updated>2020-07-30T09:09:38.901Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script>    <div id="aplayer-EEZbGzUX" class="aplayer aplayer-tag-marker meting-tag-marker" data-id="503619284" data-server="netease" data-type="song" data-mode="circulation" data-autoplay="false" data-mutex="true" data-listmaxheight="340px" data-preload="auto" data-theme="#555"></div><h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><p>关于安装系统的具体过程，网络上有很多博客，私以为<a href="https://www.cnblogs.com/masbay/p/11627727.html" target="_blank" rel="noopener">这篇博客</a>讲得最为详细，基本上按顺序照做即可。<br>其中有几个注意点：</p><ul><li>硬盘方面用DiskGenuis处理一下即可。</li><li>UEFI模式电脑，U盘启动盘要制作成UEFI模式，否则很可能无法识别U盘。</li><li>重启电脑前，要注意关闭win10电源计划中的快速启动这个选项，否则可能无法进入启动盘。具体方法自行百度。</li><li>修改BIOS启动U盘时，除了常规操作外，要使Secure Boot不使能，而且Boot Mode必须选择Uefi模式。</li><li>关于分区设置，我设置了三个分区<ul><li>引导分区 efi 主分区 200MB</li><li>交换区域 swaparea 逻辑分区 4096MB（4G）</li><li>主目录 ext4 逻辑分区 挂载到/ 剩下空间（有些人会将/home从根目录里单独分出来，相当于文档盘。但是我觉得没必要）</li></ul></li></ul><p>我通常选择的是最小化安装，所以系统里最初就只有firefox，gedit，Teriminal以及一些系统工具等基本配置。<br>重新安装了Ubuntu，那么一切都得重新配置，接下来就让我谈谈我都在Ubuntu上做了什么吧。</p><h1 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h1><h2 id="更换下载源"><a href="#更换下载源" class="headerlink" title="更换下载源"></a>更换下载源</h2><p>到软件与更新中选择更换合适的下载源，默认下载源太慢了。</p><p>更新完后来一波操作<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-update</span><br><span class="line">sudo apt-upgrade</span><br></pre></td></tr></table></figure></p><h2 id="语言设置"><a href="#语言设置" class="headerlink" title="语言设置"></a>语言设置</h2><p>由于上次将系统设置成中文后，tty模式经常会乱码。这着实让我感到非常不爽，所以这次我索性将系统设置成英文，等习惯了说不定还能学好英文呢（笑）。<br>至于输入法，拼音绝对是必不可少的。无论是写博客，还是查资料，我都必须用中文。<br>这次我依旧选择的是ibus输入法。<br>首先安装拼音输入。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install ibus-pinyin</span><br></pre></td></tr></table></figure></p><p>然后打开设置选择Region&amp;Language，点击‘Manage Installed Languages’，在Install/Remove Languages中选择Chinese(simplified)，选择apply。<br>回到Region&amp;Language，在Input Source中点击加号，单击Chinese，选择Chinese(Pinyin)，设置完成。</p><h2 id="hexo-git（2019-8）"><a href="#hexo-git（2019-8）" class="headerlink" title="hexo+git（2019.8）"></a>hexo+git（2019.8）</h2><p>我用ubuntu的一大功能就是写blog，所以博客的环境必不可少。<br>由于之前写过<a href="https://kxjzxc.github.io/关于在linux环境下搭建博客这件事.html">教程</a>，所以这里就不再赘述了。</p><h2 id="百度网盘（2019-8）"><a href="#百度网盘（2019-8）" class="headerlink" title="百度网盘（2019.8）"></a>百度网盘（2019.8）</h2><p>重装系统前，我都是使用Aria2来下载百度网盘文件的。后来终端不能用了，又要下载win7镜像文件，所以就下载了百度网盘linux版本，却意外发现也许大概应该可能没有限速？所以索性这次就直接下载百度网盘的linux版，反正aria2也不快，而且还麻烦。<br>方法嘛，直接去官网下载压缩包喽。</p><h2 id="WPS-Office"><a href="#WPS-Office" class="headerlink" title="WPS-Office"></a>WPS-Office</h2><p>为了看word文档和ppt，就必须要有Office。这次因为是最小化安装，所以系统也就没装LibreOffice，而且我也不太喜欢用这玩意，打开个文件都要半天。<br>所以我去下载了WPS。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">wget http://kdl.cc.ksosoft.com/wps-community/download/6634/wps-office_10.1.0.6634_amd64.deb</span><br><span class="line">sudo dpkg -i wps-office_10.1.0.6634_amd64.deb</span><br></pre></td></tr></table></figure></p><p>第二条命令需要进入安装包所在目录</p><h2 id="ROS"><a href="#ROS" class="headerlink" title="ROS"></a>ROS</h2><p>ROS有需要就装，方法也不在这里赘述了，自己去官网找呗。</p><h2 id="音乐播放器"><a href="#音乐播放器" class="headerlink" title="音乐播放器"></a>音乐播放器</h2><p>到写这篇博文前，我才惊觉自己没有安装音乐播放器。Gnome桌面套件自带的Rhythmbox我是不打算用了，倒也不是有什么地方不好，只是想换换。虽然网易云也有Linux版，但最终我还是选择比较符合Ubuntu气质的播放器（其实我也不知道啥是Ubuntu气质）。于是在一众神奇的播放器中，我相中了被称为Ubuntu界的千千静音的Audacious。至于用法，我暂且不会，将来用习惯了，用会了，或许会提一下。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install audacious</span><br><span class="line">sudo apt-get install audacious-plugins</span><br></pre></td></tr></table></figure></p><p>第二条命令是安装解码器。</p><h2 id="grub界面"><a href="#grub界面" class="headerlink" title="grub界面"></a>grub界面</h2><h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>选择一张背景，移动到/boot/grub里即可<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo cp -v grub_background.jpg /boot/grub</span><br></pre></td></tr></table></figure></p><p>grub_background.jpg是你选择的背景图片</p><h3 id="修改默认启动项"><a href="#修改默认启动项" class="headerlink" title="修改默认启动项"></a>修改默认启动项</h3><p>打开并编辑/etc/default/grub，修改<code>GRUB_DEFAULT= 0</code>,修改的数字就是你想要默认启动的项的位置。例如Windows项在第三位，那我就改成2（0为第一位）。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo gedit /etc/default/grub</span><br></pre></td></tr></table></figure></p><h3 id="修改分辨率"><a href="#修改分辨率" class="headerlink" title="修改分辨率"></a>修改分辨率</h3><p>编辑/etc/default/grub文件，修改<code>GRUB_GFXMODE=800x640</code><br>把分辨率改为适合你的屏幕的大小,且支持的值。<br>可以在grub界面按<code>c</code>，然后输入<code>videoinfo</code>查看。</p><p>进行上述操作后，需要使用以下指令更新<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo update-grub</span><br></pre></td></tr></table></figure></p><h1 id="遇到的坑"><a href="#遇到的坑" class="headerlink" title="遇到的坑"></a>遇到的坑</h1><h2 id="第一坑-空间（2019-8）"><a href="#第一坑-空间（2019-8）" class="headerlink" title="第一坑-空间（2019.8）"></a>第一坑-空间（2019.8）</h2><p>前文讲分区的时候说了，感觉给根目录的分区太小，因为软件基本上是装在这上面的。我后来装了个ROS后，就只剩下几百MB了<br>这时摆在我面前的有两种做法<br>第一，压缩/home分区，划给根目录，也就是直接切割磁盘。为此我下载了Gparted，然而那似乎只能操作非当前系统。所以我得去win7上操作。但是这终究只是我的猜想，而且这几天的经历也给我留下心理阴影，不敢再对磁盘动手。<br>第二，将/usr目录和/opt目录移到/home目录下。<br>这是我上网找到的方法，还不错。</p><ol><li>尽量的关掉不用的程序</li><li><p>复制</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd / ; sudo tar cf - usr opt | (cd /home ; sudo tar xfv - )</span><br></pre></td></tr></table></figure></li><li><p>编辑fstab</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo vim /etc/fstab</span><br></pre></td></tr></table></figure><p> 没有vim用gedit。<br> 在带/usr 和/opt的行(如果有的话)最前面加上#号<br> 然后在紧接着 /home 的那行加上。</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/home/usr  /usr   none    bind    0       0</span><br><span class="line">/home/opt  /opt   none    bind    0       0</span><br></pre></td></tr></table></figure></li><li><p>保存并重启</p></li></ol><p>方法有效。<br>但是我后来想删掉根目录下的/usr时，系统又双叒叕崩溃了。<br>原因不明，方法无效，准备重装。<br>好吧，实际上这次我用启动盘启动后，没有选择install ubuntu，而是try ubuntu<br>于是我进入了在ubuntu系统后，检查了两个目录下的/usr目录，发现主目录下有缺失，于是用<code>sudo cp -r 源文件路径 要复制到的文件夹路径</code>将/usr有复制了一遍后，成功重启。<br>但是我不打算再碰根目录了。</p><h2 id="第二坑-wifi适配器"><a href="#第二坑-wifi适配器" class="headerlink" title="第二坑-wifi适配器"></a>第二坑-wifi适配器</h2><p>安装完之后发现无法连接无线网络，打开设置里的wifi，才发现显示未发现wifi适配器。</p><p>解决方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo modprobe -r ideapad_laptop</span><br></pre></td></tr></table></figure></p><h2 id="第三坑-比例问题"><a href="#第三坑-比例问题" class="headerlink" title="第三坑-比例问题"></a>第三坑-比例问题</h2><p>由于电脑分辨率比较高，系统显示的字体与界面都比较小。<br>可以到设置-&gt;设备-&gt;显示中修改比例</p><h1 id="Log"><a href="#Log" class="headerlink" title="Log"></a>Log</h1><h2 id="2019-08-07"><a href="#2019-08-07" class="headerlink" title="2019-08-07"></a>2019-08-07</h2><p>上周五，我搞完基础的ros，准备进军OpenCv了解了解图像处理。然而没意识到装ROS全桌面版时OpenCv早已跑到我电脑里的我傻乎乎地打算再装一个OpenCv。于是在漫长且无趣的安装途中，我一时心血来潮，查看了自己的python版本——2.7，于是果断打算升级一波。且不说我不知道系统本来就自带两个版本的python，等我心满意足地升级完后，意外地发现自家终端打不开了。这就是此次事故的万恶之源。<br>根据网上提供的方法，我进入tty3，输入<code>gnome-terminal</code>，回车，发现是什么<code>no module named &#39;gi&#39;</code>。我百度几下，再各种死马当活马医的折腾，却完全不见效果。最终恼羞成怒的我，决定莽过去，极其无脑地删掉了整个python3文件夹，于是乎，系统崩溃。而后随抢救回来，但是也不过是回到原点，而且输入法也消失了。</p><p>无计可施的我打算重装了。<br>但是完全没有经验的我打算先卸载移动硬盘里的ubuntu（我装在移动硬盘里），先搞grub引导。于是下载FreeBSD就是一通乱搞。<br>好了，我把win7也搞炸了。<br>win7上不去？那就只能暴力重装喽。但现在只有ubuntu是可以制作启动盘喽，于是又回到ubuntu制作win7的启动盘。结果最后有败在了引导上，连ubuntu都装不上去了。<br>好的，那么现在两个系统都白给了。浪费了整整一天的我求助了同学，最终意外的用PE修复了win7的引导，可喜可贺。（PE真是个好东西）</p><p>事到如今，我也改变了想法，将两个系统都装在电脑硬盘上，文件数据都放在移动硬盘上。如此一来我也不必费劲去卸载原先的ubuntu了。<br>怀着这等策略，我迎来了安装ubuntu的第二天，然而很快就迎来了第一个坑——启动盘无法启动我的电脑。<br>我的启动盘是用sd卡+读卡器制成的，理论上和U盘没什么区别，而我的电脑就是无法在开机时识别到此启动盘。确定一遍bios，没错。在别人电脑上试试，识别成功。用UltraISO制作，还是不行。就这样荒废了整个白天，我也没查出个所以然来。最终将原因归结为电脑型号太旧无法识别读卡器后，向同学借了个U盘，制成启动盘，成功启动。</p><p>接下来的安装ubuntu的过程倒是简单到令人感动。</p><p>经过这三天看似毫无意义的折腾后，我对系统修复和安装以及ubuntu的结构都上升了一个台阶，也算是不幸中的万幸。<br>这篇博文我打算时时更新，将我认为必要的软件和操作写到此处，以便以后重装系统时，能知道做什么。</p><h2 id="2020-7-30"><a href="#2020-7-30" class="headerlink" title="2020-7-30"></a>2020-7-30</h2><p>今年换了新电脑，我也从win7党变成了win10党。不过刚买来发现并没有安装ubuntu的必要，所以也就没有急着装双系统，博客什么的也都迁移到了windows上。然而下学期选了需要用ros的课程，所以最近把Ubuntu装了起来。</p><p>由于电脑比原先的高级一些，而系统也不再是win10，所以我这次安装系统也花费了不少时间，虽然最后发现都是启动盘制作工具的锅，我还是老老实实的用USBWriter吧。</p><p>至于grub，我原先只是想要改个启动顺序，毕竟主要还是使用windows，不想每次都手动选择。搜索的过程中发现了还可以更改背景这一操作，甚是惊喜。不过分辨率最终还是没有修改。倒不是没有用，而是其他分辨率比例不对，让人头痛。</p>]]></content>
    
    <summary type="html">
    
       
    
    </summary>
    
      <category term="教程" scheme="http://kxjzxc.github.io/categories/%E6%95%99%E7%A8%8B/"/>
    
    
      <category term="教程" scheme="http://kxjzxc.github.io/tags/%E6%95%99%E7%A8%8B/"/>
    
      <category term="Linux" scheme="http://kxjzxc.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>ROS第一坑之基本操作</title>
    <link href="http://kxjzxc.github.io/ROS%E7%AC%AC%E4%B8%80%E5%9D%91%E4%B9%8B%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C.html"/>
    <id>http://kxjzxc.github.io/ROS第一坑之基本操作.html</id>
    <published>2019-08-01T08:50:36.000Z</published>
    <updated>2019-08-02T03:58:20.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>作为自动化专业的学生，机器人操作系统ROS的大名如雷贯耳。</p><blockquote><p>ROS 是一个适用于机器人的开源的元操作系统。它提供了操作系统应有的服务，包括硬件抽象，底层设备控制，常用函数的实现，进程间消息传递，以及包管理。它也提供用于获取、编译、编写、和跨计算机运行代码所需的工具和库函数。在某些方面ROS相当于一种“机器人框架（robot frameworks）”——ROS Wiki</p></blockquote><p>早在今年年初，我与同学一起参观华强北的优艾智合公司的时候，为我们介绍公司的人（似乎是我们的师兄）就向刚结束大一上学期，尚不明所以的我们介绍了机器人学习之路，其中就提到了非常重要的ROS。虽然当时ROS在我心目中留下了深刻的印象，但是我并没有时间也没有机会去学习。</p><p>直到小学期，我深感自己在本专业的自我学习上完全不够，所以一时心血来潮安装了ROS，可惜知道小学期结束，我连打开都未曾打开过。<br>所幸暑期在越疆实习的时候，可以使用ROS操纵他们的机械臂。因而我便趁此机会借用公司的机械臂和其官网上的demo开始真正接触ROS。</p><p>然而我并不想写关于ROS的教程，该方面的书籍资料已经够多了，即使那些资料并非十分完美，但至少会比我自己写的要有用的多。所以在这篇文章中我也只想谈一谈我在学习ROS初级教程中所遇到的坑。</p><p><a href="http://wiki.ros.org/cn" target="_blank" rel="noopener">ROS Wiki中文 从安装到入门</a></p><h4 id="ROS-INFO不输出"><a href="#ROS-INFO不输出" class="headerlink" title="ROS_INFO不输出"></a>ROS_INFO不输出</h4><p>我从越疆官网上下载下来的demo是将所有的程序都写在一个main函数中，这使得稍微有点强迫症的我手动将main函数里的程序封装在不同的函数中。然而作为一个懵懂无知的新手，我的“莽撞”行为导致我在后期调试的时候,在跳出第一个调用的函数后，ROS_INFO都输出不了。我上网搜索原因，可似乎没有人遇到与我相同的问题，所以就暂且搁置。后来我一句一句的测试，发现我将第一个句柄的创建写在main函数中的这个函数调用前问题就解决了。<br>原因目前暂且不明，但是当我后来知道ROS节点是在第一个句柄被创建后才开始的，我就怀疑应该是这个原因了。<br>无论如何以后的ROS程序，句柄一定要写在初始化语句的后面。<br>当然，如果我们也可以选择使用ros::start()和ros::shutdown来启动和关闭节点。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">int main(int argc, char **argv)</span><br><span class="line">&#123;</span><br><span class="line">ros::init(argc, argv, &quot;Quit&quot;);//初始化节点</span><br><span class="line">ros::NodeHandle n;//创建句柄,节点开始</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="消息与服务"><a href="#消息与服务" class="headerlink" title="消息与服务"></a>消息与服务</h4><p>关于消息与服务的理解，srv文件与msg文件的创建，订阅器与发布器的编写，服务端和客户端的编写在官网上都写得非常清楚，这里我也就不再赘述。<br>服务端和客户端的编写我倒是没遇到什么大的问题，毕竟demo中有此两者的源代码。遇到问题也不过是我没有按照流程一步一步来。<br>但对于消息的订阅器与发布器编写我倒是经常遇到的坑，虽然大多由于我理解有误。</p><ol><li><p>订阅器与发布器的注册<br>编写订阅器和发布器的时候首先要向节点管理器（ros Master）进行注册，这是毋庸置疑的。但是要值得注意的是，要在main函数中启动节点后就注册，尤其是发布器，不能够在单独的函数中进行注册，要不然会无法发布消息。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ros::Publisher pub=n.advertise&lt;dobot::GetCtrl_msg&gt;(<span class="string">"GetCtrl_msg"</span>,<span class="number">1000</span>);<span class="comment">//注册发布器</span></span><br><span class="line">ros::Subscriber sub = n.subscribe&lt;dobot::GetCtrl_msg&gt;(<span class="string">"GetCtrl_msg"</span>, <span class="number">1000</span>,messageCallback);<span class="comment">//注册订阅器</span></span><br></pre></td></tr></table></figure></li><li><p>ros::spin()与ros::spinOnce()<br>对于这两个函数的详解，网上资料也有很多，像是<a href="https://www.cnblogs.com/liu-fa/p/5925381.html" target="_blank" rel="noopener">这个博客</a><br>简而言之，就是在你订阅消息的时候，只有遇到这两条语句的时候才会调用回调函数。<br>使用ros::spin()会进入自循环，也就是不断的调用自己，以使一接收到消息就进入回调函数。使用此语句，该语句下面的程序都不会再被执行。<br>而ros::spinOnce()只会调用一次回调函数，可以实现接下来的程序。</p></li><li><p>消息的发布订阅机制<br>消息会发布到注册的话题上，然后订阅器实时的订阅话题上的消息。这就等同于一个节点实时接受另一个节点的指令，而并非信息的传递，订阅器是无法接受之前发布的消息的。<br>举个例子：<br>我之前想让一个节点记录我机械臂末端的坐标，并发布到话题上。然后我开启另一个节点，先接受话题上的坐标信息，在执行操作。<br>然而实际上这么做是不可行的，当我开启另一个节点的时候，之前发布到话题上的消息已经过期了，新节点是无法订阅到坐标消息的。<br>所以后来我转变了思路，由第一个节点发布指令消息，第二个节点根据接受到的指令消息作出相应的操作，这样一来第二个节点就可以一接收到第一个节点发布的消息就执行操作或者记录节点。执行完后继续等待指令消息。</p></li></ol><h4 id="回调函数传递多个参数"><a href="#回调函数传递多个参数" class="headerlink" title="回调函数传递多个参数"></a>回调函数传递多个参数</h4><p>在ROS的节点程序中，经常会使用到许多回调函数，像是订阅到消息    的时候会自己调用回调函数。但这种时候传递到回调函数里的参数是固定的，所以我们需要使用boost::bind函数来使我们可以自由的传递参数。</p><blockquote><p>boost::bind是标准库函数std::bind1st和std::bind2nd的一种泛化形式。其可以支持函数对象、函数、函数指针、成员函数指针，并且绑定任意参数到某个指定值上或者将输入参数传入任意位置。</p></blockquote><p>boost::bind(f,1,2) —&gt; f(1,2)<br>boost::bind(f,_1,1) —&gt; f(x,1)<br><a href="https://www.cnblogs.com/benxintuzi/p/4862129.html" target="_blank" rel="noopener">具体用法参见此博客</a></p><p>此处举两个例子</p><ol><li>订阅消息<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ros::Subscriber sub = n.subscribe&lt;dobot::GetCtrl_msg&gt;(<span class="string">"GetCtrl_msg"</span>, <span class="number">1000</span>,messageCallback);<span class="comment">//单参数</span></span><br><span class="line">ros::Subscriber sub = n.subscribe&lt;dobot::GetCtrl_msg&gt;(<span class="string">"GetCtrl_msg"</span>, <span class="number">1000</span>,boost::bind(&amp;messageCallback,\_1,point);多参数</span><br></pre></td></tr></table></figure></li></ol><p>其中_1是占位符，代表回调函数中原先的参数<code>const dobot::GetCtrl_msg::ConstPtr &amp;msg</code>。</p><ol><li>多线程<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">boost::<span class="function">thread <span class="title">t</span><span class="params">(keboard)</span></span>;<span class="comment">//单参数</span></span><br><span class="line">boost::<span class="function">thread <span class="title">t1</span><span class="params">(boost::bind(&amp;keyboard,boost::ref(pub)))</span></span>;<span class="comment">//多参数</span></span><br></pre></td></tr></table></figure></li></ol><p>其中boost::ref(x)是向回调函数传递一个变量</p><h4 id="退出节点"><a href="#退出节点" class="headerlink" title="退出节点"></a>退出节点</h4><p>在未使用launch文件启动的情况下，每一个节点都是一个终端，所以通常只要按Ctrl+C即可取消命令，程序会调用ros::shutdown()来关闭节点。<br>但是有时候我们会需要在退出节点的时候进行一些处理，例如需要清空指令队列使机器人停下或者传递消息之类的。这时候我们就需要signal函数来覆盖原先的Ctrl+C，使得当用户按下Ctrl+C的时候，会调用相应的回调函数，作最后的处理。<br><a href="https://www.jianshu.com/p/7fb777e588a9" target="_blank" rel="noopener">这里是对信号处理函数的比较好的介绍</a><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"ros/ros.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"signal.h"</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MySigintHandler</span><span class="params">(<span class="keyword">int</span> sig)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//这里主要进行退出前的数据保存、内存清理、告知其他节点等工作</span></span><br><span class="line">ROS_INFO(<span class="string">"shutting down!"</span>);</span><br><span class="line">    <span class="comment">/*自己封装的函数</span></span><br><span class="line"><span class="comment">    StopQueueCmd();</span></span><br><span class="line"><span class="comment">ClearQueueCmd();</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">ros::shutdown();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">ros::init(argc, argv, <span class="string">"Quit"</span>);<span class="comment">//初始化</span></span><br><span class="line">ros::NodeHandle n;<span class="comment">//创建句柄</span></span><br><span class="line">signal(SIGINT, MySigintHandler);<span class="comment">//第一个参数是指Ctrl+C的指令，第二个参数是调用的函数</span></span><br><span class="line">ros::spinOnce();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>其实还有好多的东西没有写，像是我封装函数到服务端，launch文件启动，用键盘键入字符，多线程等，只是这些大多是基础教程或是与ros关系不大的知识，所以也就没写出来。<br>这几天用ros实现我所想要的功能时，也的的确确学到了不少东西，至少ros的初级用法都已明晰。虽然还有许多有待提升的地方，像是暂停功能、紧急停止功能、用栈优化指令队列之类的，不过意义不大，也就没有继续写下去了。</p>]]></content>
    
    <summary type="html">
    
       
    
    </summary>
    
      <category term="ROS" scheme="http://kxjzxc.github.io/categories/ROS/"/>
    
    
      <category term="ROS" scheme="http://kxjzxc.github.io/tags/ROS/"/>
    
  </entry>
  
  <entry>
    <title>基于C语言与EGE图形库的模拟地铁自动售票系统</title>
    <link href="http://kxjzxc.github.io/%E5%9F%BA%E4%BA%8EC%E8%AF%AD%E8%A8%80%E4%B8%8EEGE%E5%9B%BE%E5%BD%A2%E5%BA%93%E7%9A%84%E6%A8%A1%E6%8B%9F%E5%9C%B0%E9%93%81%E8%87%AA%E5%8A%A8%E5%94%AE%E7%A5%A8%E7%B3%BB%E7%BB%9F.html"/>
    <id>http://kxjzxc.github.io/基于C语言与EGE图形库的模拟地铁自动售票系统.html</id>
    <published>2019-07-08T19:04:35.000Z</published>
    <updated>2019-07-10T01:41:02.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>众所周知，期末考试周结束后，迎来的不是荒淫放荡的暑假生活，而是依旧忙碌的小学期。<br>小学期的第一周，全是高级语言设计课。说是上课，其实除了第一天讲了一天的软件工程之外，剩下四天全都是搬着笔记本待在教室里敲代码。为了提供笔记本的电源，助教还得向物业借许多排插。不是很明白为什么非得在教室敲，只要作业完成了在哪里其实都一样吧。<br>题目有两个，我的题目是模拟地铁自动售票系统，另一个是职工档案管理系统。第二个有点像是大一上C语言实验课做的学生成绩管理系统，不过要比那个多很多功能。两个题目都需要做用户交互界面。<br>我选到第一个还是比较幸运的，因为第一个核心代码并不是特别的多，主要程序还是在界面设计上，至少对我来说是这样的。而第二个题目之前也做过类似的，感觉并不能学到什么比较新的东西。<br>这一周感觉大部分时间都在各种乱七八糟的事情上折腾，像是安装图形库，配置sublime，设计交互界面之类的，作业一拖再拖，直到第一周周日才做好。第二周又马上要开始认知实习课程，前四天一天到晚就要往外跑，参观各种企业。加上社团的项目，robomaster的选拔培训，之类的，实验报告到周四才完成。到周五认知实习答辩结束，原以为可以休息一阵子，谁想突然又说这门课也要答辩，报告也需要修改。周末写了几篇博文，再把PPT做好，就过去了。报告是懒得改了……原先是这么想的，结果呢，终究还是逃不过去，答辩结束后还是要修改。好在这次比起之前要求修改多了一些要求，好下手。<br>说真的，每每想到这门课只有一个学分，而且还不是考察课，我总有一种随便做做就算了的想法。这一而再再而三的要求也着实令人厌烦，只想快点结束。若不是真的学到了一些东西，我必定不会写这篇博文。时到如今，多说也无益了。</p><h2 id="任务概述"><a href="#任务概述" class="headerlink" title="任务概述"></a>任务概述</h2><p>设计一个具有购买车票、地图查询、系统说明、退出等功能的模拟地铁自动售票的系统。<br>系统要求具有欢迎界面，界面显示作者信息和版权信息。进入系统主菜单后提供购票选项、地图查询选项、系统说明、退出系统四个选项。<br>系统说明界面详细的介绍了购票流程，并且附有用户须知。<br>购票系统实现通过键盘输入起止站和票价，并且以此计算阶梯票价。根据系统提示进入投币找币流程，购票成功后返回欢迎界面。<br>查询系统通过输入站台编号查询站台信息。查询成功后可选择继续查询、购票或是返回。</p><h2 id="运行环境"><a href="#运行环境" class="headerlink" title="运行环境"></a>运行环境</h2><p>操作系统：Windows7<br>开发环境：codeblocks+EGE图形库</p><h2 id="系统设计"><a href="#系统设计" class="headerlink" title="系统设计"></a>系统设计</h2><h3 id="总体架构设计"><a href="#总体架构设计" class="headerlink" title="总体架构设计"></a>总体架构设计</h3><p>整个系统分为地图查询系统和购买车票系统。<br>由于代码比较多，我将其分写到mian.cpp、map.cpp、data.cpp、sold.cpp、Welcome.cpp、Index.cpp、description.cpp共七个cpp文件中。然后新建了一个名为”kxj.h”的头文件，在里面声明多个文件共用的函数，结构体以及外部变量。<br>其中每个文件的作用如下：<br>Welcome.cpp：绘制欢迎界面。<br>Index.cpp：绘制系统主菜单界面。<br>description.cpp：绘制系统说明界面。<br>data.cpp：地铁信息初始化。<br>Map.cpp：绘制地图查询界面，以及实现查询地图的功能。<br>Sold.cpp：绘制购买车票界面，以及实现输入起止站和车票数与投币功能。<br>Main.cpp：调用各个功能以及界面，并提供主界面的按钮点击功能。</p><h3 id="模块分析与设计"><a href="#模块分析与设计" class="headerlink" title="模块分析与设计"></a>模块分析与设计</h3><h4 id="头文件"><a href="#头文件" class="headerlink" title="头文件"></a>头文件</h4><ol><li><p>公用函数分析</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DrawOpt</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> w,<span class="keyword">int</span> h,<span class="keyword">int</span> fnum,<span class="keyword">int</span> fh,<span class="keyword">char</span> optTitle[])</span></span>;<span class="comment">//绘制按钮键。</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Title</span><span class="params">()</span></span>;<span class="comment">//标题</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Copyright</span><span class="params">()</span></span>;<span class="comment">//版权信息，每一页的标配</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">checkClick</span><span class="params">(<span class="keyword">int</span> *x,<span class="keyword">int</span> *y)</span></span>;<span class="comment">//检测是否有点击，并且获取点击的位置</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Init</span><span class="params">()</span></span>;<span class="comment">//初始化页面，使之清空，并且有标题与版权信息</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">textBox</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> w,<span class="keyword">int</span> h,<span class="keyword">int</span> r)</span></span>;<span class="comment">//绘制输入框</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Input</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> n,<span class="keyword">int</span> fh,<span class="keyword">int</span> (*click)(<span class="keyword">int</span> x,<span class="keyword">int</span> y))</span></span>;<span class="comment">//在某输入框内输入。每次循环同时检测鼠标消息与键盘消息，确保键盘与鼠标都能够实现所需效果。</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Delete</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> w,<span class="keyword">int</span> h)</span></span>;<span class="comment">//使某一矩形变成背景色，实现删除效果</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">checkIn</span><span class="params">(<span class="keyword">int</span> mx,<span class="keyword">int</span> my,<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> w,<span class="keyword">int</span> h)</span></span>;<span class="comment">//检测点击位置是否在某处</span></span><br></pre></td></tr></table></figure></li><li><p>结构体STA是站台信息的存储类型，数组下标就是编号</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">STA</span>&#123;</span></span><br><span class="line"><span class="built_in">string</span> name;<span class="comment">//站点名称</span></span><br><span class="line"><span class="keyword">int</span> line;<span class="comment">//站点路线</span></span><br><span class="line"><span class="built_in">string</span> pre;<span class="comment">//上一站名称</span></span><br><span class="line"><span class="built_in">string</span> nxt;<span class="comment">//下一站名称</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol><h4 id="地铁信息初始化"><a href="#地铁信息初始化" class="headerlink" title="地铁信息初始化"></a>地铁信息初始化</h4><p>通过循环将站台信息整合到结构体STA数组中，数组下标即为编号。换乘点拥有多个编号，不同线路上编号不同。<br>将八条线路图建成无向连通图。其中每一个编号视为一个点。一条线路上相邻两站之间连通，距离直接打表写入文件。换乘点不同编号之间距离为零。不连通的点之间距离为oo（1000000007）。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Query_same</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=number;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(station[i].name==station[x].name)mp[x][i]=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">data</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=<span class="number">7</span>;i++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;sta_num[i];j++)&#123;</span><br><span class="line">number++;</span><br><span class="line">station[number]=(STA)&#123;sta_name[i][j],i+<span class="number">1</span>&#125;;</span><br><span class="line">station[number].pre=j?sta_name[i][<span class="number">0</span>]+<span class="string">"方向："</span>+sta_name[i][j<span class="number">-1</span>]:<span class="string">"此站为终点站"</span>;</span><br><span class="line">station[number].nxt=j&lt;sta_num[i]<span class="number">-1</span>?sta_name[i][sta_num[i]<span class="number">-1</span>]+<span class="string">"方向："</span>+sta_name[i][j+<span class="number">1</span>]:<span class="string">"此站为终点站"</span>;</span><br><span class="line"><span class="keyword">if</span>(j)mp[number][number<span class="number">-1</span>]=dismp[i][j<span class="number">-1</span>];</span><br><span class="line"><span class="keyword">if</span>(j&lt;sta_num[i]<span class="number">-1</span>)mp[number][number+<span class="number">1</span>]=dismp[i][j];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=number;i++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=number;j++)&#123;</span><br><span class="line"><span class="keyword">if</span>(!mp[i][j])mp[i][j]=oo;</span><br><span class="line">&#125;</span><br><span class="line">Query_same(i);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="欢迎界面，系统主菜单以及系统说明界面"><a href="#欢迎界面，系统主菜单以及系统说明界面" class="headerlink" title="欢迎界面，系统主菜单以及系统说明界面"></a>欢迎界面，系统主菜单以及系统说明界面</h4><p>通过EGE图形库的库函数设计。<br><a hrel="http://xege.org/manual/index.htm">官方文档</a></p><h4 id="地图查询系统"><a href="#地图查询系统" class="headerlink" title="地图查询系统"></a>地图查询系统</h4><p>通过EGE图形库中的库函数完成交互界面。<br>查询站台时，先检测所查询编号是否合理，然后通过暴力查询，遍历每个站台，寻找所有站台名称相等的元素，加入到Line数组中，最后输出。<br>查询的代码如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Query</span><span class="params">(<span class="keyword">int</span> num)</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;num&lt;=number&amp;&amp;i&lt;=number;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(station[num].name==station[i].name)&#123;</span><br><span class="line">Line[cnt++]=station[i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">InitMap();</span><br><span class="line">setfont(<span class="number">20</span>,<span class="number">0</span>,<span class="string">"微软雅黑"</span>);</span><br><span class="line"><span class="keyword">if</span>(!cnt)outtextxy(WIDTH<span class="number">-200</span>,<span class="number">30</span>,<span class="string">"对不起，您查询的站点并不存在！"</span>);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">char</span> * name=(<span class="keyword">char</span>*)(<span class="string">"站名："</span>+Line[<span class="number">0</span>].name).c_str();</span><br><span class="line">        outtextrect(WIDTH<span class="number">-200</span>,<span class="number">30</span>,<span class="number">100</span>,<span class="number">20</span>,name);</span><br><span class="line">        outtextxy(WIDTH<span class="number">-200</span>,<span class="number">60</span>,<span class="string">"所在线路："</span>);</span><br><span class="line">        <span class="keyword">while</span>(cnt--)&#123;</span><br><span class="line">            xyprintf(WIDTH<span class="number">-200</span>,<span class="number">90</span>+cnt*<span class="number">120</span>,<span class="string">"%d号线"</span>,Line[cnt].line);</span><br><span class="line">            xyprintf(WIDTH<span class="number">-200</span>,<span class="number">120</span>+cnt*<span class="number">120</span>,<span class="string">"下一站："</span>);</span><br><span class="line">            name=(<span class="keyword">char</span>*)Line[cnt].pre.data();</span><br><span class="line">            xyprintf(WIDTH<span class="number">-200</span>,<span class="number">150</span>+cnt*<span class="number">120</span>,name);</span><br><span class="line">            name=(<span class="keyword">char</span>*)Line[cnt].nxt.data();</span><br><span class="line">            xyprintf(WIDTH<span class="number">-200</span>,<span class="number">180</span>+cnt*<span class="number">120</span>,name);</span><br><span class="line">        &#125;</span><br><span class="line">        delay_fps(<span class="number">60</span>);</span><br><span class="line">        cnt=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="购买车票系统"><a href="#购买车票系统" class="headerlink" title="购买车票系统"></a>购买车票系统</h4><p>通过EGE库函数完成交互界面，实现输入功能。<br>计算阶梯票价时，先用无优化的最短路径dijstra算法计算出两者间的最短路径，然后将路径向上取整，根据规则计算出单价。<br>计算票价的代码如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">calcLine</span><span class="params">()</span></span>&#123;<span class="comment">//dijkstra计算最短路</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=number;i++)dis[i]=oo,mark[i]=<span class="number">0</span>;<span class="comment">//初始化</span></span><br><span class="line">dis[startStation]=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=number;i++)&#123;</span><br><span class="line"><span class="keyword">int</span> mi=oo,k=<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=number;j++)&#123;</span><br><span class="line"><span class="keyword">if</span>(!mark[j]&amp;&amp;dis[j]&lt;mi)&#123;</span><br><span class="line">mi=dis[j];</span><br><span class="line">k=j;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(k==<span class="number">-1</span>)<span class="keyword">return</span> ;</span><br><span class="line">mark[k]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=number;j++)&#123;</span><br><span class="line"><span class="keyword">if</span>(!mark[j]&amp;&amp;dis[j]&gt;dis[k]+mp[k][j])&#123;</span><br><span class="line">dis[j]=dis[k]+mp[k][j];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">price=calc(<span class="built_in">ceil</span>(dis[endStation]));<span class="comment">//calc是计算票价</span></span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="系统主菜单"><a href="#系统主菜单" class="headerlink" title="系统主菜单"></a>系统主菜单</h4><p>初始化窗口。<br>用EGE的库函数完成交互功能。点击“地图查询”“购买车票”“系统说明”直接调用相关函数。点击“退出系统”时则退出循环。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">initgraph(WIDTH,HEIGHT);<span class="comment">//初始化窗口</span></span><br><span class="line">data();<span class="comment">//站点信息初始化</span></span><br><span class="line"><span class="comment">//欢迎界面，任意键继续</span></span><br><span class="line">    Welcome();</span><br><span class="line">    <span class="keyword">int</span> num=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> ( ; is_run(); delay_fps(<span class="number">60</span>))</span><br><span class="line">    <span class="comment">//while(1)</span></span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//系统说明界面，任意键继续</span></span><br><span class="line">        <span class="comment">//description();</span></span><br><span class="line">        <span class="comment">//显示主界面</span></span><br><span class="line">        Index();</span><br><span class="line">        delay_fps(<span class="number">60</span>);</span><br><span class="line">        <span class="keyword">int</span> x,y;</span><br><span class="line">        xyprintf(<span class="number">0</span>,<span class="number">0</span>,<span class="string">"%d"</span>,num++);</span><br><span class="line">        <span class="keyword">while</span>(!checkClick(&amp;x,&amp;y));<span class="comment">//getch();</span></span><br><span class="line">        <span class="keyword">if</span>(checkIn(x,y,(WIDTH<span class="number">-160</span>)/<span class="number">2</span>, <span class="number">100</span>, <span class="number">160</span>, <span class="number">50</span>))sold();<span class="comment">//购买车票</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(checkIn(x,y,(WIDTH<span class="number">-160</span>)/<span class="number">2</span>, <span class="number">180</span>, <span class="number">160</span>, <span class="number">50</span>))Map();<span class="comment">//查询地图</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(checkIn(x,y,(WIDTH<span class="number">-160</span>)/<span class="number">2</span>, <span class="number">260</span>, <span class="number">160</span>, <span class="number">50</span>))description();<span class="comment">//说明介绍</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(checkIn(x,y,(WIDTH<span class="number">-160</span>)/<span class="number">2</span>, <span class="number">340</span>, <span class="number">160</span>, <span class="number">50</span>))<span class="keyword">break</span>;<span class="comment">//退出系统</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">closegraph();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="软件结构（流程图）"><a href="#软件结构（流程图）" class="headerlink" title="软件结构（流程图）"></a>软件结构（流程图）</h3><p><img src="流程图.png" alt></p><h2 id="调试过程"><a href="#调试过程" class="headerlink" title="调试过程"></a>调试过程</h2><p>我首先编写完系统的核心代码，如地图查询与购买车票。这一块没有遇到太大的问题。改正几处简单的错误之后，便通过了测试。<br>接下来我开始绘制图形界面。按钮、输入框、文字等只需要稍微计算一下便能够符合我的预期。<br>较为困难的是用户交互机制的设计。我先是设计键盘交互的部分，这一块较为简单。也没有需要调试的地方。但是当我加入鼠标交互功能是，却遇到了难题：当用户输入的时候，无法通过鼠标点击相应按钮实现功能。必须等到输入结束之后才能实现鼠标点击。而且需要鼠标点击的阶段也无法通过键盘操作。即无法同时用鼠标和键盘进行操作。<br>为了解决这一问题，我在需要用户操作的阶段设置了一个while(1)循环，里面先检测是否有键盘消息，如果没有再检测是否有鼠标消息。通过这样类似于多线程的方法，系统可以实现同时通过鼠标和键盘操作，代码如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(kbhit())&#123;</span><br><span class="line">            <span class="keyword">char</span> k=getch();</span><br><span class="line">            <span class="keyword">if</span>(k==<span class="string">'\r'</span>)<span class="keyword">break</span>;<span class="comment">//确定</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> x,y;</span><br><span class="line">        <span class="keyword">if</span>(checkClick(&amp;x,&amp;y))&#123;</span><br><span class="line">            <span class="keyword">if</span>(checkIn(x,y,WIDTH/<span class="number">2</span><span class="number">-210</span>, HEIGHT<span class="number">-340</span>, <span class="number">160</span>, <span class="number">50</span>))<span class="keyword">break</span>;<span class="comment">//确定</span></span><br><span class="line">            <span class="keyword">if</span>(checkIn(x,y,WIDTH/<span class="number">2</span>+<span class="number">50</span>, HEIGHT<span class="number">-340</span>, <span class="number">160</span>, <span class="number">50</span>))<span class="keyword">return</span> <span class="number">0</span>;<span class="comment">//返回</span></span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>但是此时又造成了另一个问题——页面无法及时的更新。在之前的代码中，程序只有到getch()，即等待用户按键的时候，才会更新页面。原先因为只有键盘输入所以不会造成影响。而如今只有检测到键盘消息，才读取键盘操作，导致页面无法及时更新。思考片刻后，我认为系统只有等待的时候才会更新界面，所以我在每一处改变页面的代码之后加了<code>delay_fps(60)</code>延时函数。正如我猜想，加入延时函数之后，问题成功解决。</p><h2 id="测试结果"><a href="#测试结果" class="headerlink" title="测试结果"></a>测试结果</h2><ol><li>进入系统后，显示欢迎界面：<br><img src="欢迎界面.png" alt></li><li>按任意键进入系统主菜单，点击对应按钮进入对应的功能界面。<br><img src="系统主菜单.png" alt></li><li>进入购买车票的界面后，出现起止站的输入框。首先通过键盘输入起始站，将在输入框中出现相应字符。最多输入3个字符，而且必须是数字。点击确定或者按下回车键后，可以在目的地的输入框中输入。点击刷新按钮后可以从起始站重新输入。点击返回或者按下esc键将回到主界面。起止站输入完成后，点击确定键或者回车键，如果站台编号符合要求将进入输入票数的界面。若是不符合将被要求重新输入站台编号。<br><img src="输入起止站.png" alt></li><li>输入票数的界面中，标题下方显示两个站点之间最短距离的票价。再下面是询问购买的票数，可通过键盘输入数字字符，最多可输入一个字符。点击返回或者按下esc键回到上一界面。点击确定或者按下回车键进入下一界面。<br><img src="输入票数.png" alt></li><li>显示总价格，并且最后询问是否购买车票。点击返回或者按下esc键回到上一界面。点击确定或者按下回车键进入下一界面。<br><img src="询问是否购买.png" alt></li><li>投币界面中标题下方出现提示。按数字键可以在界面右下方的输入框中输入数字字符，最多可输入两个字符。点击确定或者回车键，如果投入的钱币小于总价格，则显示“钱币不足，请再次投币”。直到投入钱币总和大于等于总价格，到下一界面。<br><img src="投币.png" alt></li><li>购买成功后，显示信息与提示，按任意键返回主界面。<br><img src="购票成功界面.png" alt></li><li>进入地图查询界面后，显示地铁线路图，并且在线路图下方有输入框，可以输入站点编号。只能输入数字，且最多三个字符。点击查询可以在线路图右侧显示查询的地图信息。在屏幕右下方出现“继续查询”与“购票”按钮。点击“继续查询”，可以继续输入站点编码。点击“购票”按钮直接进入购票界面。点击返回或者按下esc键返回系统主界面。<br><img src="地图查询界面.png" alt></li><li>系统说明界面显示购票流程与用户须知，按任意键返回系统主界面。<br><img src="系统说明.png" alt></li></ol><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><ol><li>无法输入中文字符。EGE自带的键盘输入字符函数是直接从读取按下的键盘按键，所以无法从输入法输入中文。唯一的解决方法是通inputbox_getline()函数，用对话框让用户输入一个字符串。但是因为对话框样式风格与系统界面不符，也没有找到改变对话框样式的方法，所以没有通过输入站台名称查询站台信息的功能。</li><li>没能清空鼠标缓存消息。不过好在这一点因为点击之后能够马上切换到新的界面，所以没有构成什么问题。</li></ol><h2 id="可提升空间"><a href="#可提升空间" class="headerlink" title="可提升空间"></a>可提升空间</h2><ol><li>当鼠标移到或点击按钮时，出现动画。</li><li>输入站名查询站点信息。</li><li>提供点击站点即可查询信息的功能。</li></ol><h2 id="分析总结与心得体会"><a href="#分析总结与心得体会" class="headerlink" title="分析总结与心得体会"></a>分析总结与心得体会</h2><p>本次程序设计，不仅让我复习巩固了许久未用的最短路径算法，并且让我熟悉了使用库函数设计用户交互界面。而且将代码写在不同文件中，自己写一个头文件也是第一次尝试。虽然在新事物上折腾了很多时间，但结果还是非常令人满意的。经过此次课程，我的确获得了极大的进步。</p>]]></content>
    
    <summary type="html">
    
       
    
    </summary>
    
      <category term="计算机" scheme="http://kxjzxc.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
      <category term="程序" scheme="http://kxjzxc.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E7%A8%8B%E5%BA%8F/"/>
    
      <category term="C/C++" scheme="http://kxjzxc.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E7%A8%8B%E5%BA%8F/C-C/"/>
    
    
      <category term="dijkstra" scheme="http://kxjzxc.github.io/tags/dijkstra/"/>
    
  </entry>
  
  <entry>
    <title>关于Codeblocks下安装EGE图形库这件事</title>
    <link href="http://kxjzxc.github.io/%E5%85%B3%E4%BA%8ECodeblocks%E4%B8%8B%E5%AE%89%E8%A3%85EGE%E5%9B%BE%E5%BD%A2%E5%BA%93%E8%BF%99%E4%BB%B6%E4%BA%8B.html"/>
    <id>http://kxjzxc.github.io/关于Codeblocks下安装EGE图形库这件事.html</id>
    <published>2019-07-05T14:26:23.000Z</published>
    <updated>2019-07-07T15:43:48.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h5 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h5><p>估计大部分需要学习C/C++语言的大学生都会被要求用该语言设计小游戏或者某某系统，然后就需要用到C++专有的图形库来设计人机交互界面。Windows下有许多图形库供我们选择，其中比较出名的就是EasyX。不过EasyX只适用于VC6或者VS系列的开发环境。由于懒得下载VS，又不适应VC6那古老的界面，所以我不打算用EasyX。在Windows环境中，我一般使用sublime text3编辑代码。可惜的是，我找寻了老长时间，也未曾找到可以在该编辑器中使用图形库的方法。因此，我打算使用原先便已安装的Codeblocks。在Codeblocks开发环境下，我使用的是EGE这种轻量级的图形库。虽然依旧为安装花费了半天时间，但最终结果也算是圆满的。</p><hr><h5 id="准备工具"><a href="#准备工具" class="headerlink" title="准备工具"></a>准备工具</h5><p>Codeblocks：最好安装最新版本。<br>EGE：我使用的是15.0.4版本，更高级的版本我实在用不来。反正我也不打算再用这玩意做图形界面了，就凑和着用。</p><h5 id="安装流程"><a href="#安装流程" class="headerlink" title="安装流程"></a>安装流程</h5><ol><li>找到Codeblock的文件夹，打开其中的MinGW文件夹<br><img src="cb-mingw.png" alt></li><li>将下载下来的EGE压缩包解压后，打开文件夹。<br><img src="EGE.png" alt></li><li>打开include文件夹,将里面的东西复制到之前打开的MinGW文件夹中的include文件夹里<br><img src="EGE-include.png" alt></li><li>打开lib文件夹，选择mingw4.8.1，将里面lib文件夹里的东西复制到MinGW文件夹中的lib中。<br><img src="EGE-lib.png" alt><br><img src="EGE-lib1.png" alt></li><li>打开codeblocks，新建一个项目，点击Project-&gt;Build options-&gt;Linker settings。在Link libraries中点击Add，选择添加文件的图标。进入MinGW下lib文件夹，寻找以下一系列文件”libgraphics.a””libgdi32.a” “libimm32.a” “libmsimg32.a””libole32.a” “liboleaut32.a” “libwinmm.a””libuuid.a”，可以直接全部粘贴上去，系统会自动生成路径。<br>然后在右边Other linker options中写上-mwindows。点击ok完成。<br><img src="Compiler-setting.png" alt><br>以上，EGE配置完成。之后你只要在敲代码是写上<code>#include&lt;graphics.h&gt;</code>就能使用图形库了。</li></ol><h5 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h5><ol><li>上述方法仅适用于当前设置的项目。如果要有新建了一个项目，要使用EGE图形库的话，需要再次进行第五步的配置。</li><li>如果觉得每次都设置很麻烦，可以自己新建一个模板，以后使用EGE的时候直接调用模板即可。<a href="https://blog.csdn.net/lx_asymmetric/article/details/78156734" target="_blank" rel="noopener">新建模板的方法点此</a>。 </li><li>使用时可能会遇到中文乱码的问题，可以自己去网上找解决方案，我也是糊里糊涂才调好的。</li><li>设置完成后，该项目就变成了绘图模式。在该模式下寻常的输入输出是无法在终端中显示的，无论是否调用了<code>#include&lt;graphics.h&gt;</code>头文件。这也是为什么我们不选择一劳永逸的配置方法。</li></ol>]]></content>
    
    <summary type="html">
    
       
    
    </summary>
    
      <category term="教程" scheme="http://kxjzxc.github.io/categories/%E6%95%99%E7%A8%8B/"/>
    
    
      <category term="教程" scheme="http://kxjzxc.github.io/tags/%E6%95%99%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>关于使用sublime-text3编译C++程序这件事</title>
    <link href="http://kxjzxc.github.io/%E5%85%B3%E4%BA%8E%E4%BD%BF%E7%94%A8sublime-text3%E7%BC%96%E8%AF%91C++%E7%A8%8B%E5%BA%8F%E8%BF%99%E4%BB%B6%E4%BA%8B.html"/>
    <id>http://kxjzxc.github.io/关于使用sublime-text3编译C++程序这件事.html</id>
    <published>2019-07-05T14:24:27.000Z</published>
    <updated>2019-07-07T15:30:40.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h5 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h5><p>在Windows环境下，我比较喜欢使用sublime-text3作为代码编辑器。界面简洁舒适，敲代码的体验也非常好。<br>不过平时用sublime写写js还好，想要编译C++的话，就需要自己手动配置。配置的教程其实网上很多，也说的很明白。不过网上大部分的方法都有一点小问题，那就是无法用<code>scanf</code>或者<code>cin</code>输入，只能显示输出结果。因为它并没有调用终端，直接在底栏输出。<br>好在上周写作业的时候，偶然在网上找到了一份有效的教程，或者说有效的代码，能够调用系统终端运行程序。教程如下。</p><h5 id="教程"><a href="#教程" class="headerlink" title="教程"></a>教程</h5><ol><li>想要编译C++程序，必须要有<strong>编译器</strong>，像是gcc和g++。如果你的电脑上有可以编译C++的软件，像是C-free、dev-c、codeblocks、vs之类的，那么软件的文件中肯定有编译器。如果你的电脑上没有这些，那要么从网上下载一种C++编译软件，要么直接去下载MinGW。</li><li>右键<strong>我的电脑</strong>-&gt;属性-&gt;高级系统设置-&gt;高级-&gt;环境变量，在用户变量或者系统变量（两者都行，具体区别自行百度）中找到path，点击编辑，将你编译器所在的文件夹路径添加上去，然后点击确定。<br><img src="环境变量设置.png" alt></li><li>环境变量设置完成后，打开sublime，新建编译系统。由于我的sublime是汉化过的，所以选项是工具-&gt;编译系统-&gt;新建编译系统。</li><li>将下面的代码复制粘贴到配置文件后保存，保存到的文件夹不要改动。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;cmd&quot;: [&quot;g++&quot;, &quot;$&#123;file&#125;&quot;, &quot;-fexec-charset=gbk&quot;, &quot;-o&quot;, &quot;$&#123;file_path&#125;/$&#123;file_base_name&#125;&quot;],</span><br><span class="line">    &quot;file_regex&quot;: &quot;^(..[^:]*):([0-9]+):?([0-9]+)?:? (.*)$&quot;,</span><br><span class="line">    &quot;working_dir&quot;: &quot;$&#123;file_path&#125;&quot;,</span><br><span class="line">    &quot;selector&quot;: &quot;source.c, source.c++&quot;,</span><br><span class="line">    &quot;variants&quot;:</span><br><span class="line">    [</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;name&quot;: &quot;Run&quot;,</span><br><span class="line">            &quot;cmd&quot;: [&quot;cmd&quot;, &quot;/c&quot;, &quot;g++&quot;, &quot;$&#123;file&#125;&quot;, &quot;-o&quot;, &quot;$&#123;file_path&#125;/$&#123;file_base_name&#125;&quot;, &quot;&amp;&amp;&quot;, &quot;cmd&quot;, &quot;/c&quot;, &quot;$&#123;file_path&#125;/$&#123;file_base_name&#125;&quot;]</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;name&quot;: &quot;RunInCommand&quot;,</span><br><span class="line">            &quot;cmd&quot;: [&quot;cmd&quot;, &quot;/c&quot;, &quot;g++&quot;, &quot;$&#123;file&#125;&quot;, &quot;-o&quot;, &quot;$&#123;file_path&#125;/$&#123;file_base_name&#125;&quot;, &quot;&amp;&amp;&quot;, &quot;start&quot;, &quot;cmd&quot;, &quot;/c&quot;, &quot;$&#123;file_path&#125;/$&#123;file_base_name&#125; &amp; pause&quot;]</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这一步是关键一步，也是不同教程中不同的一步。</p><ol><li>如此一来就配置好了，写一份C++代码，按<code>shift+ctrl+b</code>，选择<code>RunIncmd</code>那一项就可以了。以后编译也只用按<code>ctrl+b</code>。当然，你想的话也可以自己设置热键。</li></ol>]]></content>
    
    <summary type="html">
    
       
    
    </summary>
    
      <category term="教程" scheme="http://kxjzxc.github.io/categories/%E6%95%99%E7%A8%8B/"/>
    
    
      <category term="教程" scheme="http://kxjzxc.github.io/tags/%E6%95%99%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>日渐颓废的平凡之路</title>
    <link href="http://kxjzxc.github.io/%E6%97%A5%E6%B8%90%E9%A2%93%E5%BA%9F%E7%9A%84%E5%B9%B3%E5%87%A1%E4%B9%8B%E8%B7%AF.html"/>
    <id>http://kxjzxc.github.io/日渐颓废的平凡之路.html</id>
    <published>2019-06-24T11:56:39.000Z</published>
    <updated>2020-04-18T01:56:47.352Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script>    <div id="aplayer-ZKJjBXkf" class="aplayer aplayer-tag-marker meting-tag-marker" data-id="28018269" data-server="netease" data-type="song" data-mode="circulation" data-autoplay="false" data-mutex="true" data-listmaxheight="340px" data-preload="auto" data-theme="#555"></div><p>高代考试的那天，正值夏至。<br>从那天起，白昼开始缩短，黑夜将逐渐变得漫长。就如同我的高等代数试卷被交上去地那一刻，一个学期结束，新的学期将至。</p><p>复(yu)习高代，我只用了一天时间。上午我还能将书上的课后习题一道一道地看过去，脑中想想解决方法，再看一眼答案验证思路。到了下午，一觉醒来之后突然就没了学习的热情，和室友有一搭没一搭地聊着，复习进度龟速前进。好在考试前也完成了复习任务，怀着表面自信，内心慌张地态度踏进考场，开始我的最后一门考试。其实不只是高等代数，像是之前的数学分析和大学物理，我也只在上面投入一两天的时间，而语文英语之流甚至片刻未学。并非我过于自信，不屑于这些考试，事实上这些课我学得都不是特别扎实，听课效率低到令人叹息。这笔记基本也没怎么做，后期全靠导图支撑。然而导图还是比较适合复习阶段，在学习方面并无太大作用。我之所以这么跳，除了考试周考试频率高外，大部分原因还是我的自控力太差，难以长时间专心致志地投入到枯燥的复习当中(或许有女朋友一起复习会比较有趣，然而我并没有)。或许正是因为复习的时候很颓废，所以考试周结束后并没有解放的感觉吧。</p><p>其实我的颓废也并非一日两日的事，而是从这个学期初便早有迹象。</p><p>暂且不谈上课的时候日常走神，本身投入到学业中的时间就很少。除了考试周之外，也只有自习课才会写一会作业。原本打算语文课上看书，英语课上看英文版的《傲慢与偏见》的计划也基本上没完成过，反倒是在知乎的碎片化阅读与爽文类的漫画中浪费了大把时间。前些天的六级让我意识到自己的英语已经退步到一种可悲的境地，甚至连初中时代都难以企及。至于大一的项目，磕磕绊绊，进度缓慢，一开始的方案也被推翻。前路迷茫，有时根本不知道该如何是好。自己的信心也在这一次一次的挫折前消磨，只想着早些结束。</p><p>最为颓废的是，曾经自诩为从不玩游戏的我也掉进了游戏的坑洞。最初接触游戏其实只是因为自己加入了社团里的游戏项目组，偶尔会接一些谜题设计的任务。不过那时候只是作为一个单纯的云玩家，在B站上云游戏视频。由于undertale、女神异闻录5、风之旅人这些剧情经常或是理念绝佳的游戏，让我对游戏的观念大大改变，可还是很少自己亲自玩游戏。主要还是觉得自己手残，而且没钱买正版和主机。一次偶然的机会，我在一家微信公众号上被推荐了一个游戏网站。该网站上都是从红白机上移植到PC上的经典街机游戏，像马里奥、魂斗罗之类的。因《高分少女》的影响，我对上个世纪的街机游戏黄金时代充满了好奇，所以不由自主地点了进去。不过很可惜，网站上大多都是战斗类游戏，正是我最不擅长且最无兴趣的种类，因而一两天就厌弃了。不过从那时起，我开始玩的游戏也越来越多：扫雷，俄罗斯方块、Nazo解谜网站、密室逃脱类游戏、仙剑奇侠传一、植物大战僵尸，deemo……不得不承认，我对游戏因此加深不少，甚至有以后干脆进入游戏行业的念头，但是耗费的时间还是颇让人吃惊。好在贫穷和电脑配置阻止了我痴迷游戏，止步于极少数优质的免费游戏。而由于四月份加入了桌游社，也有机会接触这个我一直以来都想加入的圈子。虽然到目前为止，也就只参与了两次活动，不过在社里的两位大佬的带领下，我也玩了不少从前前所未闻的游戏，像是烧脑的《推翻苏丹》《犯罪现场》，克苏鲁风格的跑团桌游《诡镇奇谈》《疯狂诡宅》，而我自己也购买了两款轻松简单的卡牌游戏《UNO》《爆炸猫咪》。我有种预感，或许将来我会有一大笔消费花在购买桌游上面呢。不过那些大桌游，动辄便是三四百，恐怕还得好好斟酌一二。</p><p>比起玩游戏，对于游戏的解构更让我感兴趣。像是游戏的核心机制，游戏的风格，游戏元素的组合……其主要原因还是我现在正在做游戏。当然，我说的不只是社团里的那个解谜RPG类游戏，还有另外一个基于前端语言的网页游戏。该游戏是我在六月初突发灵感且脑洞大开产生的，目前也只处在大纲设计完成，刚刚开始写HTML的阶段。我是打算将这个游戏作为我学习前端的一个项目来做。我是从这学期开始才打算学习前端的。最初不过是从github上找一些前端小项目，一边读着代码一边实现效果。这样虽然能学会很多，但并没发真正转变为自己的知识。后来又注册codewars，在上面刷了十来道js的题目，但效果依旧有限。想来想去，还是自己动手写项目会好一些，可惜并没有特别有兴趣的想法。直到这个游戏的构思诞生，我对学习前端有出现了动力，打算在此路上渐行渐远。</p><p>虽然感觉这学期事情不少，但实际上却觉得非常水。学习学得一般般，项目的进度缓慢无比，社团游戏没做多少，前端也没学到什么，还将一大堆时间浪费到碎片化阅读和游戏中……当真是日渐颓废。唯一比上学期有进步的大概就属小说写作。这大抵要归功于创意写作课和友人的激励。为了累积灵感，我还特意买了许多小本子随身携带，一有灵感就及时记录。不过说到底，我也只不过写了两篇，其中一篇还只是练笔。我真的担心自己对于写小说的热情会逐渐被繁重的事务所淹没，从而遗忘自己的初心。世上众人大多有志，却只有堪堪数人得以实现，着实令我焦虑。</p><p>不管怎么说，夏至已过，我的春季学期也随之结束。本学期的成绩还算平庸，门门八十几，既没有挂科，也没有很优秀。作为如此浪荡的复习结果，我已经是非常满意的了。愿来日漫长，岁月静好，路漫漫其修远兮，吾将上下而求索。</p><p>PS：以下是这几门的思维导图，不多，且不全，自取。<br> <a href="/2019/06/24/日渐颓废的平凡之路/思维导图.zip">点击下载</a><br>还有那个红白机网站<br><a href="https://yikm.net/" target="_blank" rel="noopener">点此穿越上世纪</a><br>以下是nazo解谜网站，有兴趣可以试一试，反正我到第三十四关玩不下去了。顺便一说，这个不让写攻略。<br><a href="nazo.one-story.cn/">点此烧脑</a></p>]]></content>
    
    <summary type="html">
    
       
    
    </summary>
    
      <category term="杂" scheme="http://kxjzxc.github.io/categories/%E6%9D%82/"/>
    
    
      <category term="杂" scheme="http://kxjzxc.github.io/tags/%E6%9D%82/"/>
    
  </entry>
  
  <entry>
    <title>【练笔】家有史莱姆</title>
    <link href="http://kxjzxc.github.io/%E3%80%90%E7%BB%83%E7%AC%94%E3%80%91%E5%AE%B6%E6%9C%89%E5%8F%B2%E8%8E%B1%E5%A7%86.html"/>
    <id>http://kxjzxc.github.io/【练笔】家有史莱姆.html</id>
    <published>2019-06-22T14:32:10.000Z</published>
    <updated>2019-06-24T12:41:06.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script>    <div id="aplayer-UEphgrbD" class="aplayer aplayer-tag-marker meting-tag-marker" data-id="1368227452" data-server="netease" data-type="song" data-mode="circulation" data-autoplay="false" data-mutex="true" data-listmaxheight="340px" data-preload="auto" data-theme="#555"></div><p>“哇，好可爱的荧光兔！”<br>“这就是植入荧光基因的新品种吗，好漂亮的孩子！”<br>“软乎乎的，毛茸茸的，真想吸一辈子！”<br>“下班后，我也要去萌即正义旗舰店买一只回来！”<br>……<br>不远处充满兴奋的讨论声使得木友人有些心烦意乱，原本就很疲惫的他难以专心地继续调式bug。他那熊猫般的双眼略带不满地投向噪音的源头——几个女同事围绕着一只浑身散发着蓝色荧光的兔子像麻雀般叽叽喳喳个不停。而那只作为罪魁祸首的兔子正毫无自觉地趴在桌子上享受着女同事们的抚摸。<br>“女孩子向来对可爱的事物没有抵抗力，不是吗？”一旁的同事无精打采地以龟速敲打着键盘，显然也被那恼人的吵闹声影响到了。“嘛，虽然那只兔子是挺可爱的。”<br>木友人对这个话题并没有太大的兴趣，只是随便回应了一句表示赞同对方的话语。<br>“其实呢，我也挺想养只宠物的，”可惜无心工作的同事并没有打算放过这个话题，“像猫啊，狗啊之类的，每天回到家抱起来吸几口，治愈一下都市人疲惫的心灵。可恶，好羡慕！”<br>“等你回家的时候，你家宠物估计都躺在窝中做着美梦呢……”木友人吐槽道。<br>“……说的也是，这该死的工作什么时候能结束啊！”同事双手胡乱揉了揉头发，然后一脸颓废地将头垂在桌上。忽然同事侧过头望向木友人问道，“话说，你有养宠物吗？”<br>“没……”刚想否认的木友人突然想起了什么，改口道：“我好像养了一只……虽然不知道是不是还活着……”<br>“突然有些同情你家宠物了……你养的啥？”<br>“史莱姆。”<br>同事眨了眨眼睛，“史莱姆？”<br>木友人点了点头。<br>“生物清道夫有线公司买的那种？”<br>“我可买不起高级品种。”木友人一边敲着代码，一边缓缓说道，“只是因为我每天下班回家太晚，没时间打扫房间，这才去店里买了只史莱姆回来。之后也就完全没管它了。毕竟房间天天都需要清理，饿不死它。大概。”<br>“你这根本就不算是宠物吧，完全是当仆人来用的吧。”同事有些无奈地叹了口气，然后靠在椅背上，用手指按摩着自己的鼻梁，“我敢说你连名字都没给它取。”<br>木友人沉默地看着电脑屏幕，并没有反驳同事。说到底他的确只是把那只史莱姆当做家用清理机器人来用，而且关于史莱姆这种人造产品能否真的作为一个生命来看待也是个迷。</p><p>回到家的时候已经是第二天凌晨一两点钟，房间里寂静无声，漆黑一片。这几天连着加班，无论是身体还是心灵都早已疲惫不堪，所幸今天拼了老命终于完成了手头的工作，明天周日也能够稍微休息休息。想到此处，木友人顿时觉得生活充满了希望，眼前无尽的黑暗中仿佛出现了一点荧光，然后一阵晕眩袭来，整个人瘫倒在某种软乎乎的凉丝丝的事物上，疲惫感如潮水般将他淹没，陷入了香甜的睡梦之中。</p><p>再次从慵懒的睡梦中醒来时，木友人眼中是自己熟悉中待着陌生的卧室。他这一觉睡了足有十来个小时，温暖的阳光已将卧室照得通明。他感到自己怀里似乎有什么软乎乎的东西，惺忪的睡眼低头一看，那是一个光溜溜的富有弹性的半固态流体，在明亮的阳光照射下呈现出透明的淡蓝色。流体中间有一颗拳头大小的透明圆球，缓慢而安稳地跳动着。<br>毫无疑问，这是他的史莱姆。<br>史莱姆是不需要睡眠的。作为人造生物，人类只赋予了它清理污渍的使命。估计是感受到他几天没有洗澡，身上全是脏东西才依靠本能靠过来的。木友人苦笑着伸了个懒腰，决定先去洗个澡，然后开始他美好且轻松的假日时光。<br>似乎是感到自己的主人已经苏醒，史莱姆一蹦一蹦地来到阳台上，在明亮的阳光下缩成一个水珠状的椭球。借助太阳光，史莱姆正在消化积攒在它体内的污渍。若有若无的气体在如同蓝宝石般光滑的表面上飘动着，甚是漂亮。<br>洗完澡出来后，史莱姆的的踪影已消失不见了。想来是消化完成，跑去清理屋子里。木友人也没放在心上，穿上松松垮垮的家居服，便走到零食柜前，打算拿上几包零食去客厅打游戏。可惜计划赶不上变化，木友人看着空空如也的柜子，心里疑惑着自己前不久刚买的零食怎么那么快就吃完了，感觉他平时好像也没吃多少。想来想去，也只能把锅扣到繁忙的加班让他变得有些健忘。<br>在网上购入了一箱新零食后，木友人走到客厅里以最舒服最慵懒的姿势陷入柔软的沙发上，打开电视播放起这个季度的新番。这部新番倒也不是那么精彩，不过是一群人嘻嘻哈哈的日常生活，但对于身心俱疲的木友人来说却是极佳的疗品。相比之下，那些精彩万分，富有深度的动画却渐渐很难吸引他的兴趣了，毕竟作为休息的假日时光他可不想在调动自己的脑袋。<br>正当他津津有味地看着动画时，他家的史莱姆君不知何时也坐到了沙发上，就像是在同他一起观看这部动画。木友人的注意力瞬间被这个有趣的小家伙吸引住了。只见他那颗圆润的核心以一种欢快轻松的跃动着，蓝色透明的流体时不时地荡起一阵不规律的涟漪，仿佛是因为有趣的剧情而发笑。史莱姆也会看动画吗？这种事情倒是第一次听说，不，倒不如说他从来就没有关心过自家的史莱姆。正如他同事所说的那样，他连名字都没给它取。<br>突然，某样东西让他瞪大了眼睛——那是一片黄灿灿的薄薄的像是薯片的东西。观察了足足五秒后，他无比确信地把“像是”二字去掉了。这就是一片薯片。待到那片薯片逐渐溶解在那透明的液体中，一只蓝色的触手从史莱姆身上伸了出来，伸向玻璃茶几上的一包不知何时出现的开封的薯片袋，卷起一片薯片后猛地缩回体内。整套动作行云流水，流畅无比，让人难以置信。木友人吃惊地看着自家史莱姆，一个大胆的想法逐渐在他脑海中成型。<br>“我说，”木友人用手扭着史莱姆富有弹性的身体向两边拉扯，后者立刻变成了一个可笑的形状，“我的零食不会都是被你偷吃光的吧！”<br>“您好，您的快递已送达，快递员正在门口等候。”此时手机一阵振动，传来了优雅悦耳的女声。木友人只得暂时松开自己的双手，起身走到门口取快递。<br>“好嘞，现在没有人打扰了，我的死宅生活正式开启！”木友人将零食箱放在客厅的地上，从电视底下拿出尘封……已久的游戏手柄？木友人看着手上光滑干净如同新品的游戏机，若不是上面有许多划痕之类的痕迹，他真的很怀疑这是不是自己的手柄。木友人回头望了一眼沙发上若无其事地“吃”薯片的史莱姆，然后猛地甩了甩头，拍了拍自己的脸颊：“说不定只是它经常清理过……”<br>话音未落，便见听见一阵熟悉的音乐响起，吓得他赶忙向后退了几步，却看见自家史莱姆不知何时来到了电视机前，像个老司机般熟练地连接手柄，选择游戏，点击开始，然后在富有节奏感的背景音乐声中，淡蓝柔软的触手在黑色的手柄上快速地按动，控制着屏幕上的游戏角色在华丽炫目的弹幕中穿梭，杀怪，闯关……那模样，完全不像是一个智能有限，只会清理的人造生物，而像是一个拥有多年玩游戏经验的老手，在自己的领域中叱咤风云。<br>“这……这家伙不会趁我不在家的时候把我的游戏都玩了一遍吧！”由于眼前的事实过于令人震惊，木友人呆呆站在原地，顿时有些不知所措。回想起刚刚自家史莱姆看动画，吃薯片的场景，木友人觉得自己完全小瞧了眼前这个花一千块钱买来的小家伙。自从买到家里已经有半年多了，这期间木友人回家的次数屈指可数，而且每次都是疲惫地到头就睡，一觉睡到天明后又匆匆忙忙地感到公司，对这家伙算是完全不了解。原以为不过是只是打扫房间的清道夫，却万万没想到竟成长为一个连他都比不过的老司机。说不定，每天都宅在家中看动画，玩游戏，吃零食，过着令人羡慕，呸，无比堕落的宅男生活……<br>正当木友人沉浸在自己杂乱忽然他感到脚踝处传来一阵冰冰凉凉的触感，下意识地低头一看，是自家史莱姆的触手。木友人疑惑地望着史莱姆，然后似乎明白了些什么地看了一眼屏幕。屏幕上是双人模式中选择角色的界面，其中一方已经选定，而另一方则迟迟未动。史莱姆安静地持着游戏手柄，仿佛，不，就是在等待着木友人选择角色。<br>原先脸上阴晴不定的木友人愣了愣，不由自主地发出奇怪地笑声，脑中乱七八糟的想法全都烟消云散。<br>“算了，难得的休息日，不想那么多了。”他深深地吸了一口气，决定放弃了思考，认命般地盘腿坐下，拿着手柄开始挑选角色。<br>“你是想和我一起玩一局吗？”<br>“……”<br>“事先说明，我可是人称独孤求败的游戏小王子。”<br>“……”<br>“让你见识见识我的厉害，emmm……就叫你波奇好了！”<br>“……”<br>“波奇，看招……”</p><hr><p>其实这一篇是十天前就已经完成的练笔，只不过今天才有时间发布到博客上。<br>关于这篇练笔的题目来源于创意写作书系中《开始写吧！虚构文学创作》中的第三篇《我的宠物》。由于我这人没有幻想元素的故事完全没有兴趣写，所以宠物从一开始就设定成现实世界中没有的动物。最初我是打算写玄武型宠物机器人的，一种好养又宅的宠物。与此对应，它的主人则是一个被996的生活压迫着的社畜，虽然内心是一个喜欢看动画玩游戏宅在家中不动弹的宅男，但却被繁重的工作所压迫连续好几天都没有回家。后来玄武机器人改成了史莱姆，其他设定却没怎么改。毕竟软萌软萌的史莱姆配上死宅的生活方式，感觉会很有趣呢。<br>然而，这篇文章前面写的时候还行，到了最后却明显地感到后劲不足，像是主人公内心的转变就完全没有写到位。如今，虽然对此略加修改，加了一些心理活动，却依旧感到不尽如人意。看来还是自身修炼未曾达标。</p>]]></content>
    
    <summary type="html">
    
       
    
    </summary>
    
      <category term="我的小说" scheme="http://kxjzxc.github.io/categories/%E6%88%91%E7%9A%84%E5%B0%8F%E8%AF%B4/"/>
    
      <category term="练笔" scheme="http://kxjzxc.github.io/categories/%E6%88%91%E7%9A%84%E5%B0%8F%E8%AF%B4/%E7%BB%83%E7%AC%94/"/>
    
    
      <category term="我的小说" scheme="http://kxjzxc.github.io/tags/%E6%88%91%E7%9A%84%E5%B0%8F%E8%AF%B4/"/>
    
      <category term="练笔" scheme="http://kxjzxc.github.io/tags/%E7%BB%83%E7%AC%94/"/>
    
  </entry>
  
</feed>
