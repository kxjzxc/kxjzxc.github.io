<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[MIT6.S081之实用程序]]></title>
    <url>%2FMIT6-S081%E4%B9%8B%E5%AE%9E%E7%94%A8%E7%A8%8B%E5%BA%8F.html</url>
    <content type="text"><![CDATA[前言第一个实验是在XV6系统上实现五个实用程序。虽然不难，但是我写了好久…… 实验sleepsleep本身不需要实现，只需要运行即可。 源代码12345678910111213#include "kernel/types.h"#include "user.h"int main(int argc,char* argv[])&#123; if(argc != 2)&#123; printf("Sleep needs one argument!\n"); //检查参数数量是否正确 exit(-1); &#125; int ticks = atoi(argv[1]); //将字符串参数转为整数 sleep(ticks); //使用系统调用sleep printf("(nothing happens for a little while)\n"); exit(0); //确保进程退出&#125; 编译运行 修改Makefile 123456789101112131415161718UPROGS=\ $U/_cat\ $U/_echo\ $U/_forktest\ $U/_grep\ $U/_init\ $U/_kill\ $U/_ln\ $U/_ls\ $U/_mkdir\ $U/_rm\ $U/_sh\ $U/_stressfs\ $U/_usertests\ $U/_grind\ $U/_wc\ $U/_zombie\ $U/_sleep\ # 添加sleep 运行 1sudo make qume pingpong要求实现两个进程在管道两侧来回通信。父进程将”ping”写入管道，子进程从管道将其读出并打印。子进程从父进程收到字符串后，将”pong“写入另一个管道，然后由父进程从该管道读取并打印。 原理通过定义两个管道fp和sp，实现父子进程传输消息 注意，进程通常只持有某个管道的读出端或者写入端，因此使用的时候需要将另一端关闭。 源代码12345678910111213141516171819202122232425262728293031323334353637383940#include "kernel/types.h"#include "user.h"int main(int argc,char* argv[])&#123; int fp[2],sp[2]; pipe(fp);//父进程写入，子进程读取 pipe(sp); printf("program start!\n"); int pid = fork(); if(pid&lt;0) &#123; printf("error!"); &#125; else if(pid == 0) &#123; /*子进程 */ char *buffer = " "; close(fp[1]); // 关闭写端 read(fp[0], buffer, 4);//阻塞等待 printf("%d: received %s\n",getpid(),buffer); close(fp[0]); // 读取完成，关闭读端 char *intput = "pong"; close(sp[0]); // 关闭读端 write(sp[1], intput, 4); close(sp[1]); // 写入完成，关闭写端 &#125; else&#123; /*父进程*/ char *buffer = "ping"; close(fp[0]); // 关闭读端 write(fp[1], buffer, 4); close(fp[1]); // 写入完成，关闭写端 close(sp[1]); // 关闭写端 read(sp[0], buffer, 4); printf("%d: received %s\n",getpid(),buffer); close(sp[0]); // 读取完成，关闭读端 &#125; exit(0);&#125; 运行结果 primes要求使用管道实现“质数筛选”, 输出2~35之间的而所有质数。 原理筛选思路： 主进程将所有数据输入到管道的左侧 子进程从管道读出并筛选出第一个数字x，排除掉x的倍数，其他数字再写入下一管道； 重复步骤二，直到管道中没有数字源代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include "kernel/types.h"#include "user.h"#include &lt;stddef.h&gt;void mapping(int n, int fd[])&#123; close(n);//关闭文件描述符n，令n映射到fd[n] dup(fd[n]); close(fd[0]); close(fd[1]);&#125;void primes()&#123; int fd[2]; pipe(fd); int prime;//当前的质数 int ref = read(0, &amp;prime, sizeof(int)); if(ref == 0)return;//没有质数了 printf("prime %d\n", prime); int pid = fork(); if(pid == 0) &#123; int num; mapping(1, fd);//将管道映射到1上 while(read(0,&amp;num, sizeof(int))) &#123; if(num%prime == 0)continue; write(1, &amp;num, sizeof(int)); &#125; &#125; else &#123; wait(NULL); mapping(0, fd);//将管道映射到0上 primes(); &#125;&#125;int main(int argc,char* argv[])&#123; int fd[2]; pipe(fd);//父进程写入，子进程读取 printf("program start!\n"); int pid = fork(); if(pid&lt;0) &#123; printf("error!"); &#125; else if(pid == 0) &#123; /*子进程 */ mapping(1,fd); for(int i = 2;i &lt;= 35; i++)//将所有数字塞入管道 write(1, &amp;i, sizeof(int)); &#125; else&#123; /*父进程*/ wait(NULL);//等待子进程结束 mapping(0, fd); primes(); &#125; exit(0);&#125; 运行结果 find要求在目录树中查找名称与字符串匹配的所有文件，输出文件的相对路径。 原理借鉴ls指令的写法，读取路径下的文件名，如果是文件，就与寻找的文件名比较，如果是文件夹，就递归继续寻找该文件夹。 源代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788#include "kernel/types.h"#include "kernel/stat.h"#include "user/user.h"#include "kernel/fs.h"char* fmtname(char *path)&#123; char *p; // Find first character after last slash. for(p=path+strlen(path); p &gt;= path &amp;&amp; *p != '/'; p--) ; p++; return p;&#125;void find(char *path, char *file_name)&#123; char buf[512], *p; int fd; struct dirent de; struct stat st; if((fd = open(path, 0)) &lt; 0)&#123; fprintf(2, "find: cannot open %s\n", path); return; &#125; if(fstat(fd, &amp;st) &lt; 0)&#123; fprintf(2, "find: cannot stat %s\n", path); close(fd); return; &#125; if(st.type != T_DIR) &#123; fprintf(2, "find: cannot find in %s\n", path); close(fd); return; &#125; if(strlen(path) + 1 + DIRSIZ + 1 &gt; sizeof buf)&#123;//路径太长了 return; &#125; strcpy(buf, path); p = buf+strlen(buf); *p++ = '/'; while(read(fd, &amp;de, sizeof(de)) == sizeof(de))&#123; if(de.inum == 0) continue; memmove(p, de.name, DIRSIZ); p[DIRSIZ] = 0; if(stat(buf, &amp;st) &lt; 0)&#123; printf("find: cannot stat %s\n", buf); continue; &#125; char *name = fmtname(buf); switch (st.type) &#123; case T_FILE: if(strcmp(name, file_name) == 0) &#123; printf("%s\n", buf); &#125; break; case T_DIR: if(strcmp(name, ".") == 0 || strcmp(name, "..") == 0) continue;//不能是本层或者上层 find(buf, file_name); break; default: break; &#125; &#125; close(fd);&#125;int main(int argc, char *argv[])&#123; if(argc &lt; 3)&#123; printf("please input find [path] [file_name]\n"); exit(0); &#125; find(argv[1], argv[2]); exit(0);&#125; 运行结果 xargs要求从标准输入中读取行并 为每行运行一次 指定的命令，且将该行作为命令的参数提供。 原理这个小实验主要是对于实现效果的理解。 |命令行中的|会将左边的命令的输出通过管道传递到右侧，可以直接从标准输入中读取字符串。 exec函数exec接收的二维参数数组argv，argv[0]必须是该命令本身，最后一个参数argv[size-1]必须为0，否则将执行失败。12char *argv[]=&#123;"echo","hello",0&#125;;exec(argv[0],argv); 源代码12345678910111213141516171819202122232425262728293031323334353637#include "kernel/types.h"#include "user/user.h"#include "kernel/param.h"int main(int argc, char* argv[]) &#123; if(argc &lt; 2)&#123; printf("error inputs"); exit(0); &#125;//参数不够 char *cmd = argv[1]; char *argvs[MAXARG]; for(int i=1;i&lt;argc;i++) &#123; argvs[i-1]=argv[i]; &#125; char buff[1024]; while(read(0,&amp;buff,sizeof(buff)))//读取|右边的命令输出或者等待输出 &#123; int len = strlen(buff); argvs[argc-1]=&amp;buff[0]; for(int i=0;i&lt;len;i++) &#123; if(buff[i]=='\n')// 默认 -n1 &#123; if(fork()==0) &#123; buff[i]=0; argvs[argc]=0;//命令的最后一个参数为0 exec(cmd,argvs);//执行每一行命令 &#125; wait(0);//等待子进程结束 argvs[argc-1]=&amp;buff[i+1];//下一行命令的首地址 &#125; &#125; &#125; exit(0);&#125; 运行结果运行命令 xargstest.sh123456mkdir aecho hello &gt; a/bmkdir cecho hello &gt; c/becho hello &gt; bfind . b | xargs grep hello 结语第一个实验就耗费了大量的时间，有几个实验还借鉴了别人的写法。考虑到我不是科班出身，之后的实验不如趁早观看别人的写法，能学到东西就好。]]></content>
      <categories>
        <category>计算机</category>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MIT6-S081之环境配置]]></title>
    <url>%2FMIT6-S081%E4%B9%8B%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE.html</url>
    <content type="text"><![CDATA[前言本人虽然不是计科的学生，但是想做一做操作系统的实验，权当作学习操作系统的知识。 我校的操作系统实验是基于MIT6.S081实验，在XV6上进行教学： XV6是由麻省理工学院(MIT)开发的一个教学目的的操作系统，它是在x86处理器上用ANSI标准C重新实现的Unix第六版(即v6)，课程编号为6.828。2019年被移植到RISC-V之上，并设置了6.S081。XV6的主要特征：1) 开源，精简，代码仅两万行左右；2) 功能完善，可全面理解操作系统的原理及实现；3) 基于RISC-V、X86等架构，有利于深入理解体系结构；4) 类Unix系统，可延伸学习其他常见操作系统，例如Linux、MacOS等。 本课程将从开源操作系统 xv6-labs-2020 的实验课程中选取4个实验，根据我们学校的操作系统课程要求进行修改， 请大家从以下网站下载代码，在这套代码上完成实验。 环境配置操作系统Ubuntu20.04 工具以下内容照搬学校实验指导书： RISC-V工具链 下载安装包并解压 12$ git clone --recursive https://github.com/riscv/riscv-gnu-toolchain$ tar zxvf riscv-gnu-toolchain.tar.gz 安装 1234$ cd riscv-gnu-toolchain$ sudo ./configure --prefix=/usr/local$ sudo make$ cd .. 检测是否安装成功 12$ riscv64-unknown-elf-gcc --versionriscv64-unknown-elf-gcc (GCC) 10.2.0 QEMU模拟器 下载QEMU并解压 12$ wget https://download.qemu.org/qemu-5.1.0.tar.xz$ tar xf qemu-5.1.0.tar.xz 安装 12345$ cd qemu-5.1.0$ sudo ./configure --disable-kvm --disable-werror --prefix=/usr/local --target-list="riscv64-softmmu"$ sudo make$ sudo make install$ cd .. 检测是否安装成功 12$ qemu-system-riscv64 --versionQEMU emulator version 5.1.0 XV6源码 下载XV6源码我是从学校实验中心的gitee上下载的,各凭渠道 运行12$ cd xv6-labs-2020$ sudo make qemu 当可以看到“init: starting sh”的字样表示xv6已经正常启动。 qemu退出方法：先按Ctrl+a组合键，接着全部松开，再按下x键 至此，XV6已经能够正常运行了。 结语由于写这篇博文的时候，环境已经搭建好了，而且也没有什么记录，所以就直接照搬实验指导书了。本文仅当作记录。]]></content>
      <categories>
        <category>计算机</category>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于CMAKE项目生成多个可执行文件以及调用第三方库这件事]]></title>
    <url>%2F%E5%85%B3%E4%BA%8ECMAKE%E9%A1%B9%E7%9B%AE%E7%94%9F%E6%88%90%E5%A4%9A%E4%B8%AA%E5%8F%AF%E6%89%A7%E8%A1%8C%E6%96%87%E4%BB%B6%E4%BB%A5%E5%8F%8A%E8%B0%83%E7%94%A8%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93%E8%BF%99%E4%BB%B6%E4%BA%8B.html</url>
    <content type="text"><![CDATA[需求 CMake工程中多个cpp文件分别生成exe可执行文件 调用第三方静态和动态库 方法先上CMakeLists.txt吧 123456789101112131415161718192021222324252627282930313233343536373839404142cmake_minimum_required (VERSION 3.10)project(Mosquitto)# specify the C++ standardset(CMAKE_CXX_STANDARD 11)set(CMAKE_CXX_STANDARD_REQUIRED True)set(CMAKE_CXX_FLAGS &quot;$&#123;CMAKE_CXX_FLAGS&#125; -g&quot;)# 设置变量set(Mosquitto_DLL_DIR D:\\Program_Files\\Mosquitto)set(Mosquitto_DIR D:\\Program_Files\\Mosquitto\\devel)set(CMAKE_RUNTIME_OUTPUT_DIRECTORY $&#123;CMAKE_BINARY_DIR&#125;) # 生成时拷贝dll到Bin中file(GLOB dll_src &quot;$&#123;Mosquitto_DLL_DIR&#125;/*.dll&quot; )file(COPY $&#123;dll_src&#125; DESTINATION $&#123;CMAKE_RUNTIME_OUTPUT_DIRECTORY&#125;)# find_package(OpenCV REQUIRED) 如果第三方库里有.cmake文件可以直接调用find_package找路径# 头文件目录include_directories($&#123;Mosquitto_DIR&#125;)# 库目录link_directories( $&#123;Mosquitto_DIR&#125;)# 找到所有含有mian函数的cpp文件，保存在mians里file( GLOB_RECURSE mains RELATIVE &quot;$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;&quot; &quot;$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;/subscribe.cpp&quot; &quot;$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;/publish.cpp&quot;)# 循环遍历每个含main的文件，分别编译生成exe文件foreach(mainfile IN LISTS mains) # Get file name without directory get_filename_component(mainname $&#123;mainfile&#125; NAME_WE) add_executable($&#123;mainname&#125; $&#123;mainfile&#125;) # 添加库文件目录 target_link_libraries($&#123;mainname&#125; mosquitto mosquittopp)# 链接库文件endforeach() 关于生成多个可执行文件主要就是对于每个cpp分别进行操作，链接库之类的我Cmake里使用了file和foreach，可以减少行数。 关于调用第三方库代码中注释也说了，如果第三方库里有.cmake文件可以直接调用find_package找路径，具体可以打开.cmake文件看看如果没有的话就需要自己也用set设置路径变量一般来说用link_directories、target_link_libraries就能够链接库文件了。但我出现了以下问题通过网上查询资料，猜测是没找到dll文件的位置。此时需要将dll添加到build文件夹里，详情见cmakelists文件。理论上添加环境变量也是可以的，但是我并没有成功，原因未知。 结语说实话，到最后CMakeLists还是一头雾水，莫名其妙地成功了，很多东西都是囫囵吞枣，能用就不深究，这样属实不行，将来必然吃亏。有时间还是得多多了解多多写。]]></content>
      <categories>
        <category>教程</category>
      </categories>
      <tags>
        <tag>教程</tag>
        <tag>CMake</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于不同仓库部署到同一个Github这件事]]></title>
    <url>%2F%E5%85%B3%E4%BA%8E%E4%B8%8D%E5%90%8C%E4%BB%93%E5%BA%93%E9%83%A8%E7%BD%B2%E5%88%B0%E5%90%8C%E4%B8%80%E4%B8%AAGithub%E8%BF%99%E4%BB%B6%E4%BA%8B.html</url>
    <content type="text"><![CDATA[前言一直以来，我做出来的web小项目，如我的第一个网站、贪吃蛇等都是直接塞到博客里和博客一起上传到网站，但是上传上一篇博文时，发现即使跳过渲染，js文件在hexo g之后还是会出问题，研究了半天猜测是我之前安装的aplayer插件引起的bug，因为在js文件前总会出现这样几行代码： 123&lt;link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"&gt;&lt;script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"&gt;&lt;/script&gt;&lt;script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"&gt;&lt;/script&gt; 最后索性改变策略，将Vue项目上传到一个新的仓库，然后部署到kxjzxc.github.io的子网站kxjzxc.gitub.io/Vue-Image-tool上 方法关于Github Pages这里就不赘述了，仅仅谈论对于一个已经有一个博客或者个人网站的人怎么部署。 点击新仓库的Setting 选择pages选项 选择分支并点击Save关于这一步，选择的分支的根目录下必须有且只有你想要显示的页面的html或者md文件。如果你的仓库包括源文件和最后编译生成的文件，建议将这两部分分到两个分支中 结语其实搞完后发现以前我朋友帮我搞过这种操作，就是adarkroom和candybox这两个网站，可惜我当时并没有问他咋搞的。]]></content>
      <categories>
        <category>教程</category>
      </categories>
      <tags>
        <tag>Github</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基于Vue的图片处理网站]]></title>
    <url>%2F%E5%9F%BA%E4%BA%8EVue%E7%9A%84%E5%9B%BE%E7%89%87%E5%A4%84%E7%90%86%E7%BD%91%E7%AB%99.html</url>
    <content type="text"><![CDATA[前言很早之前看过某位大佬制作的蒸汽波图片生成网站，无论是网站的功能还是风格都深得我意，于是就Ctrl+S保存了这个网站的代码（后来发现作者在GitHub上开源了）。由于时间原因，我一直没怎么去看这份代码。正好最近前段时间刚考完期末，公司实习又恰好顺延，再加上我一直想学习学习Vue-Cli手脚架的使用，所以就打算套用Vue-Cli实现一遍这份代码。代码本身这篇博客就不讲解了，毕竟不是我的代码。所以在这里我主要想谈谈在复刻网站的过程中我觉得有必要记录下来的知识点。 Vue知识点集合Vue-Cli环境搭建以及项目生成在使用Vue-Cli之前需要先安装node.js以及npm等环境或者工具，此处不赘述，从Cli手脚架讲起。好吧，我之前就装过环境了，所以不想讲官方教程 1npm install -g @vue/cli 然后用以下指令创建项目 1vue create hello-world 官方还提供了图形化界面来调试管理 1vue ui 在图像化界面中可以对项目进行编译、热更新、压缩等操作 Vue-Cli手脚架结构123456789101112131415├─dist 输出文件夹：build之后生成的文件夹│ ├─css │ ├─img│ └─js├─ node_modules node.js中的一些包├─public 静态文件夹│ └─img 图片文件夹└─src 源码文件夹 ├─assets 动态资源文件夹 │ └─css 样式文件夹：用于存放网页的样式文件 ├─components 组件文件夹：用于存放一些可重复利用的组件 ├─script js脚本文件夹：用于存放网站的js脚本 ├─views 页面文件夹：用于存放单个网页页面的组件 ├─App.vue 入口组件 └─main.js 入口脚本：代码从此处开始 导入外部js变量或方法在外部的extra.js文件最下方导出 1234export &#123; variable, method&#125; 然后在需要导入的组件vue中 12345678910111213141516171819202122232425javascript&lt;script&gt;import &#123;variable&#125; from '../script/extra.js'//导入外部js变量import &#123;method&#125; from '../script/extra.js'//导入外部函数import Components from '../components/components.vue'//导入外部组件export default &#123; name: 'thisVue', data: function () &#123; return &#123; localVar:'',//本地变量 variable//外部变量 &#125;; &#125;, components:&#123; Components, &#125;, methods: &#123; method &#125;, &#125;&lt;/script&gt; 读取本地图片在需要的组件中调用以下js脚本中的chooseImage函数，其中参数callback是用于在需要的组件中赋值读取的图片，因为vue不像原生js那样不同文件中的变量共用。这部分代码，说实话我不太想讲，虽然很有意思，但是js的语法实在……不适合用文字来分析（大概）。 12345678910111213141516171819202122232425262728293031323334353637383940const readFileToURL = (file,onOver)=&gt;&#123; var reader = new FileReader(); reader.onload = ()=&gt;&#123; const src = reader.result; onOver(src); &#125;; reader.readAsDataURL(file);&#125;;const readFileAndSetIMGSrc = (file,callback)=&gt;&#123; readFileToURL(file,src=&gt;&#123; const img = new Image(); img.src = src; img.onload = ()=&gt;&#123; callback(img); &#125; &#125;);&#125;;const chooseFile = (callback)=&gt;&#123; chooseFile.form.reset(); chooseFile.input.onchange = function()&#123; if(!this.files||!this.files[0])return; callback(this.files[0]); &#125;; chooseFile.input.click();&#125;;chooseFile.form = document.createElement('form');chooseFile.input = document.createElement('input');chooseFile.input.type = 'file';chooseFile.form.appendChild(chooseFile.input);const chooseImage = (callback)=&gt; &#123; chooseFile(file=&gt;&#123; readFileAndSetIMGSrc(file,callback); &#125;);&#125;export &#123; chooseImage&#125; 加载图片资源加载本地图片资源有两种方法，第一种动态加载，第二种是静态加载 动态加载动态加载就是将图片资源放在src/assets文件夹中。由于vue在编译的时候会用webpack将src下的所有东西转换成base64，所以不能直接通过路径来导入图片，需要使用require来以模块的形式导入 1require("@/"+path); @/是src根目录，path就是剩下的路径 静态加载静态加载则是将图片资源放在public静态文件夹中，由于打包时静态目录下的东西是原封不动地移到输出目录中，所以直接用public文件夹下的路径，比如/public/img/*.jpg，导入时路径为/img/*jpg。在打包时，比起动态加载我更倾向于用这个方法来导入图片，因为打包后src下的东西都乱作一团，难以导入图片（可能是我写得不对），而静态目录不受影响。但显而易见的是，调试的时候用动态加载会方便很多。 父子组件通信父子间通信网络上有很多很多的教程，而且大同小异，我也不赘述了。不过网上的方法基本上都是从父组件传值到子组件，子组件里修改了的话需要再传到父组件，这时候父组件需要写一个函数来更新这个值，而我一开始想要的并不是这种方法，而是类似于C/C++那种引用或者原生js里的变量通用，即在子组件里修改了某个值，父组件里的那个值也改变，但很可惜能力有限，并没有找到解决方案，最后还是放弃了这个想法。 结束语最终做出来的成品与原网站不能说很像，只能说一模一样。好吧，其实我还是修改了样式改得更丑了，以及换了图片（不如原先）。其实我是想要在此基础上制作一个拥有更多功能得图像处理网站，不过短暂的假期（就当是假期吧）结束了，我得去实习了其实还有考研，所以就留给下个假期了吧。顺带一提，虽然我之前说这不是我的代码，但图像处理的部分也着实有趣，有时间还是想写一写这一部分的解析。 最后是我的成品，如有bug欢迎提出。图片处理网站]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基于OpenCV和图像金字塔的模板匹配——火花塞间隙尺寸测量]]></title>
    <url>%2F%E5%9F%BA%E4%BA%8EOpenCV%E5%92%8C%E5%9B%BE%E5%83%8F%E9%87%91%E5%AD%97%E5%A1%94%E7%9A%84%E6%A8%A1%E6%9D%BF%E5%8C%B9%E9%85%8D%E2%80%94%E2%80%94%E7%81%AB%E8%8A%B1%E5%A1%9E%E9%97%B4%E9%9A%99%E5%B0%BA%E5%AF%B8%E6%B5%8B%E9%87%8F.html</url>
    <content type="text"><![CDATA[介绍本项目为基于OpenCV的火花塞间隙尺寸测量，主要是运用模板匹配技术定位火花塞间隙尺寸，然后寻找火花塞间隙并测量其尺寸。 算法说明程序主要分成四个部分： 预处理：在此部分中，将完成模板的创建和待处理图片的路径读取。程序将从文件夹中读取model.png图片作为模板。如果文件夹中没有该图片，则将从第一张待处理图片中截取所需区域作为模板。 匹配：此函数主要调用OpenCV库中的matchTemplate函数以及相关函数寻找各种角度的图片中与模板的最佳匹配点，并且根据该点找寻区域的中心位置。模板匹配算法根据需要决定，本项目使用平均方差。 旋转图像为了匹配旋转的图像，所以在匹配时要将图像进行旋转。旋转使用的是仿射变换，仿射矩阵可用getRotationMatrix2D()得到M1。由于在旋转图像后，图像的大小也会改变，所以不能直接使用M1进行变换，而是要用getAffineTransform()函数再获得一个大小变换矩阵M2最后将M1的旋转部分和M2的大小变换部分相结合变成一个新的变换矩阵M，使用warpAffine()函数就能完成图像的仿射变换。由于代码需要，还需要写坐标变换的函数，公式如下M就是一个3*2的矩阵 图像金字塔如果单纯使用模板匹配，时间复杂度将爆炸，但我们可以使用图像金字塔来进行优化 建立n层图像金字塔，对于每一层金字塔，将图像向下采样，每$2^n$行$2^n$列取一个像素。由此获得$\frac{1}{2^n}$倍的图像和模板。采样完后的图像可用高斯滤波器滤波（本项目没有） 从高层开始将该层模板对该层图像进行模板匹配，所有匹配度高于某一阈值的点都将用一个矩形框住，并记录下旋转角度变换范围。 下一层在上一层截取的区域和角度中进行模板匹配，依次类推逐渐获得一个比较小的匹配区域和角度范围。 对n-1层图像金字塔依次进行匹配后，在源图像中找到得到的区域，并在相应角度范围中进行最终的模板匹配，获得中心点的位置。 尺寸计算：当找到匹配区域的中心点位置后，垂直向下寻找火花塞间隙。将图片变换成灰度图之后，就可以发现向下直线上的两处灰度值突变的点便是间隙边缘上的点，计算两点间距离就是火花塞间隙的开度。 绘制输出测量处相关函数之后就可以在图片上绘制测量区域，并且显示开度的数值 代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291#include &lt;opencv2/opencv.hpp&gt;#include &lt;iostream&gt;#include &lt;vector&gt;using namespace cv;using namespace std;////////////其他函数///////////////void Min(int &amp;a,int b)&#123; if(a&gt;b)a = b;&#125;void Max(int &amp;a,int b)&#123; if(a&lt;b)a = b;&#125;Point GetCenter(int x,int y,int w,int h)&#123; return Point(x+w/2,y+h/2);&#125;/*获取仿射矩阵*/Mat GetMatrix(int cols,int rows,int newCols,int newRows,int degree)&#123; Point2f center(cols / 2, rows/2);//中心 Mat M1 = getRotationMatrix2D(center, degree, 1);//计算旋转的仿射变换矩阵 Point2f srcPoints1[3]; Point2f dstPoints1[3]; srcPoints1[0] = Point2i(0, 0); srcPoints1[1] = Point2i(0, rows); srcPoints1[2] = Point2i(cols, 0); dstPoints1[0] = Point2i((newCols - cols)/2 , (newRows - rows)/2); dstPoints1[1] = Point2i((newCols - cols)/2 , (newRows + rows)/2); dstPoints1[2] = Point2i((newCols + cols)/2, (newRows - rows)/2); Mat M2 = getAffineTransform(srcPoints1, dstPoints1); M1.at&lt;double&gt;(0, 2) = M1.at&lt;double&gt;(0, 2) + M2.at&lt;double&gt;(0, 2); M1.at&lt;double&gt;(1, 2) = M1.at&lt;double&gt;(1, 2) + M2.at&lt;double&gt;(1, 2); return M1;&#125;//旋转图像内容不变，尺寸相应变大 Mat Rotate(Mat src, int degree) &#123; double angle = degree * CV_PI / 180.; double a = sin(angle), b = cos(angle); int rows=src.rows; int cols=src.cols; //旋转后的新图尺寸 int width_rotate= int(rows * fabs(a) + cols * fabs(b)); int height_rotate=int(cols * fabs(a) + rows * fabs(b)); Mat M = GetMatrix(cols,rows,width_rotate,height_rotate,degree); Mat dst= Mat::zeros(width_rotate, height_rotate, src.type()); warpAffine(src, dst, M, Size(width_rotate, height_rotate));//仿射变换 return dst;&#125; /* 坐标变换*/void TransCoor(Point &amp;point,int degree,int rows,int cols,bool dir = 1)&#123; double angle = degree * CV_PI / 180.; double a = sin(angle), b = cos(angle); //旋转后的新图尺寸 int width_rotate= ceil(rows * fabs(a) + cols * fabs(b)); int height_rotate=ceil(cols * fabs(a) + rows * fabs(b)); Mat M; if(dir == 0)//顺时针 &#123; M = GetMatrix(cols,rows,width_rotate,height_rotate,degree); &#125; else //逆时针 &#123; M = GetMatrix(width_rotate,height_rotate,cols,rows,-degree); &#125; point = Point(point.x*M.at&lt;double&gt;(0, 0)+point.y*M.at&lt;double&gt;(0,1)+M.at&lt;double&gt;(0,2), point.x*M.at&lt;double&gt;(1, 0)+point.y*M.at&lt;double&gt;(1, 1)+M.at&lt;double&gt;(1,2));&#125; int level = 3;//金字塔层级int degreeMin,degreeMax;//旋转范围int degree;//最终的旋转角度/* 在ROI图像中匹配模板model*/Point Match(Mat src,Mat model)&#123; Point temLoc;//最佳匹配点 double Min = 1; for(int d = degreeMin;d&lt;=degreeMax;d++)//旋转角度 &#123; Mat img = Rotate(src,d); int row = img.rows; int col = img.cols; Mat result(col, row, CV_32FC1); if(row &lt; model.rows || col &lt; model.cols)continue; matchTemplate(img, model, result, TM_SQDIFF_NORMED);//匹配模板 //normalize(result, result, 0, 1, NORM_MINMAX, -1, Mat());//归一化 Point minLoc; Point maxLoc; double min, max; //找到最匹配点（函数说明：在一个数组中找到全局最小值和全局最大值） minMaxLoc(result, &amp;min, &amp;max, &amp;minLoc, &amp;maxLoc, Mat()); if(min&lt;Min) &#123; temLoc = minLoc;//TM_SQDIFF_NORMED是最小值 degree = d;//最佳匹配角度 Min = min; &#125; &#125; return GetCenter(temLoc.x, temLoc.y, model.cols, model.rows);&#125;/* 获得第level层金字塔图像*/Mat GetPyramid(Mat src,int level)&#123; int sample = 1&lt;&lt;level;//采样率为2^level Mat dst = Mat::zeros(Size(src.cols/sample,src.rows/sample),src.type()); for(int i=0;i&lt;dst.rows;i++) for(int j=0;j&lt;dst.cols;j++) &#123; dst.at&lt;Vec3b&gt;(i,j) = src.at&lt;Vec3b&gt;(i*sample,j*sample); &#125; return dst;&#125;/* 缩小寻找范围*/void FindROI(Mat src,Rect &amp;ROI,int level,Mat model)&#123; Mat pyramidSrc = GetPyramid(src,level); Mat pyramidModel = GetPyramid(model,level); Point topLeftP = Point(pyramidSrc.cols,pyramidSrc.rows); Point ButtonRightP = Point(0,0); bool isMatch = false; int dmin = 359,dmax = 0; for(int d = degreeMin;d&lt;=degreeMax;d+=10*level)//旋转角度 &#123; Mat img = Rotate(pyramidSrc,d); int row = img.rows; int col = img.cols; if(row &lt; pyramidModel.rows || col &lt; pyramidModel.cols)continue; Mat result(col, row, CV_32FC1); matchTemplate(img, pyramidModel, result, TM_SQDIFF_NORMED);//匹配模板 Point minLoc; Point maxLoc; double min, max; //找到最匹配点（函数说明：在一个数组中找到全局最小值和全局最大值） minMaxLoc(result, &amp;min, &amp;max, &amp;minLoc, &amp;maxLoc, Mat()); if(min&lt;0.1*level) &#123; isMatch = true; //匹配到的四个点 Point point[4] = &#123; minLoc, Point(minLoc.x,minLoc.y+pyramidModel.rows), Point(minLoc.x+pyramidModel.cols,minLoc.y), Point(minLoc.x+pyramidModel.cols,minLoc.y+pyramidModel.rows) &#125;; //寻找左上角和右下角 for(int i = 0;i&lt;4;i++) &#123; TransCoor(point[i],d,pyramidSrc.rows,pyramidSrc.cols); Min(topLeftP.x,point[i].x); Min(topLeftP.y,point[i].y); Max(ButtonRightP.x,point[i].x); Max(ButtonRightP.y,point[i].y); &#125; Min(dmin,d); Max(dmax,d); &#125; &#125; if(isMatch == false)return ;//如果没匹配到则返回 //更新感兴趣区域 topLeftP*=1&lt;&lt;level; ButtonRightP*=1&lt;&lt;level; Max(ROI.x,topLeftP.x+ROI.x); Max(ROI.y,topLeftP.y+ROI.y); Min(ROI.width,ButtonRightP.x-topLeftP.x); Min(ROI.height,ButtonRightP.y-topLeftP.y); Max(ROI.x,0); Max(ROI.y,0); Min(ROI.width,src.cols); Min(ROI.height,src.rows); degreeMax = dmax; degreeMin = dmin;&#125;Point FindTemplate(Mat src,Mat model)&#123; Rect ROI = Rect(0,0,src.cols,src.rows); degreeMin = 0,degreeMax = 359; for(int i=level;i&gt;=1;i--) &#123; FindROI(src(ROI),ROI,i,model); &#125; cout&lt;&lt;degreeMax&lt;&lt;" "&lt;&lt;degreeMin&lt;&lt;endl; //原始图像中匹配 Point center = Match(src(ROI),model); //还原中心坐标 TransCoor(center,degree,ROI.height,ROI.width); center.x+=ROI.x; center.y+=ROI.y; TransCoor(center,degree,src.rows,src.cols,false); return center;&#125;/* 寻找直线端点*/void FindLinePoint(Mat src,Point startP,Point &amp;firstP,Point &amp;secondP,int &amp;dis)&#123; int y = startP.y; Mat gray; cvtColor(src,gray,COLOR_RGB2GRAY); while(y&lt;src.rows) &#123; int deri = (int)gray.at&lt;uchar&gt;(y,startP.x)- (int)gray.at&lt;uchar&gt;(y+1,startP.x); if( deri &lt; -65)//像素变大且跨度大于阈值则为第一个点 &#123; firstP = Point(startP.x,y+1); &#125; if( deri &gt; 65)//像素变小且跨度大于阈值则为第二个点 &#123; secondP = Point(startP.x,y+1); break; &#125; y++; &#125; dis = abs(firstP.y-secondP.y);//计算尺寸 return ;&#125;void Deal(Mat src,Mat model)&#123; //寻找匹配到的区域的中心点 Point center = FindTemplate(src,model); //寻找火花塞间隙的两个端点，并计算尺寸 Point firstP,secondP; int dis; FindLinePoint(Rotate(src,degree),center,firstP,secondP,dis); // //标记并输出图像 Mat dst; src.copyTo(dst); // //将坐标变换为原图 TransCoor(center,degree,src.rows,src.cols); TransCoor(firstP,degree,src.rows,src.cols); TransCoor(secondP,degree,src.rows,src.cols); circle(dst,center,3,Scalar(0,0,255)); line(dst,firstP,secondP,Scalar(0,0,255)); putText(dst,"d:"+to_string(dis),(secondP+firstP)/2+Point(10,0), FONT_HERSHEY_COMPLEX,0.5,Scalar(0,0,255)); imshow("dst",dst); &#125;int main()&#123; string pattern_jpg; vector&lt;String&gt; image_files; pattern_jpg = ".\\img\\*.png"; glob(pattern_jpg, image_files);//读取图片路径 //创建模板 string mode_path = ".\\img\\model.png"; Mat model = imread(mode_path);//模板 if(model.empty())//读取不到图片 &#123; Mat img=imread(image_files[0]); model = img(Rect(250,150,120,80)); &#125; //处理图片 for(int i=0;i&lt;image_files.size();i++) &#123; cout &lt;&lt; image_files[i] &lt;&lt; endl; if(image_files[i]==".\\img\\model.png")continue; Mat img=imread(image_files[i]); Deal(img,model); waitKey(); &#125; return 0;&#125; 实验结果 结论在这个项目中我们学到了如何基于opencv库中的模板匹配实现待识别器件的定位，以及根据位置信息测量所需的参数。该技术可用于简单环境下的零件尺寸测量。由于需要旋转角度匹配时可以匹配旋转的图片，所以速度非常的慢。但使用图像金字塔进行优化后，速度提升非常之大。]]></content>
      <categories>
        <category>计算机</category>
        <category>程序</category>
        <category>OpenCV</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>OpenCV</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数字图像处理之基于opencv的人腿跟踪检测]]></title>
    <url>%2F%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E4%B9%8B%E5%9F%BA%E4%BA%8Eopencv%E7%9A%84%E4%BA%BA%E8%85%BF%E8%B7%9F%E8%B8%AA%E6%A3%80%E6%B5%8B.html</url>
    <content type="text"><![CDATA[前言本项目是数字图像处理课程的大作业，选题为人腿跟踪的机器人。与之前实验不同的是本次实验将应用到机器人平台进行验证，所以使用了ROS系统控制。 开发环境 Ubuntu18.04 ROS melodic Opencv3 研究目标1、实现机器小车识别并跟踪人腿的功能 研究内容1、采用颜色分割算法，实现对黑色的提取功能。2、采用特征提取算法，实现对已分割图像的有效轮廓提取。3、采用运动决策算法，实现依据有效轮廓对小车的运动控制。 算法实现针对颜色分离功能1.1 先对图像进行伽马变换，使从摄像头获得的图片变亮，利于后续的颜色选择1.2 对图片进行高斯模糊，消去噪声，1.3 将图片从RGB色度空间转换到HSV色度空间，利于图像的颜色分割。1.4 对提取的图片进行灰度变换并进行开运算，减少其他区域干扰。源程序：伽马校正(网上复制粘贴的) 123456789101112131415161718192021222324252627282930313233void GammaCorrection(Mat src, Mat &amp;dst, float fGamma)&#123; // build look up table unsigned char lut[256]; for( int i = 0; i &lt; 256; i++ ) &#123; lut[i] = saturate_cast&lt;uchar&gt;(pow((float)(i/255.0), fGamma) * 255.0f);//防止颜色溢出操作 &#125; dst = src.clone(); const int channels = dst.channels(); switch(channels) &#123; case 1: &#123; MatIterator_&lt;uchar&gt; it, end; for( it = dst.begin&lt;uchar&gt;(), end = dst.end&lt;uchar&gt;(); it != end; it++ ) *it = lut[(*it)]; break; &#125; case 3: &#123; MatIterator_&lt;Vec3b&gt; it, end; for( it = dst.begin&lt;Vec3b&gt;(), end = dst.end&lt;Vec3b&gt;(); it != end; it++ ) &#123; (*it)[0] = lut[((*it)[0])]; (*it)[1] = lut[((*it)[1])]; (*it)[2] = lut[((*it)[2])]; &#125; break; &#125; &#125;&#125; 颜色分割 12345678910111213141516171819void Separate(Mat src,Mat &amp;dst)&#123; GammaCorrection(src,src,1/1.6);//伽马变换 imshow("src",src); GaussianBlur(src,src,Size(7,7),7,7);//高斯模糊 //转换到HSV色度空间 Mat hsv; cvtColor(src,hsv,COLOR_BGR2HSV);// //提取黑色 //thre.convertTo(thre,CV_8UC1,-1,255); inRange(hsv, Scalar(0,0, 0),Scalar(180,255, 46), dst);//颜色分割 //开运算 Mat element=getStructuringElement(MORPH_RECT, Size(15,15)); Mat opened; morphologyEx(dst, dst, MORPH_OPEN, element);; imshow("black",dst); &#125; 针对特征识别功能2.1 对处理后的灰度图进行寻找轮廓，绘画轮廓边框和轮廓中心点，判断边框是否是所需要的轮廓边框。2.2 判断依据有矩形的长宽比是否为长边形，边框是否是大致竖直状态，边框大小是否处于面积阈值范围。2.3 得到人腿的准确边框。源程序： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768//两点间距离double SideCalc(Point a,Point b)&#123; return sqrtf(powf(a.x-b.x,2)+powf(a.y-b.y,2));&#125;//直线的斜率double Grad(Point a,Point b)&#123; if(a.x==b.x)return oo; return fabs(a.y-b.y)/fabs(a.x-b.x);&#125;void Command(Mat src,geometry_msgs::Twist &amp;cmd_red)//根据分离出来的图像决定dashgo的行动&#123; //寻找轮廓 vector&lt;vector&lt;Point&gt;&gt; contours; vector&lt;Vec4i&gt; hierarchy; findContours(src, contours, hierarchy, CV_RETR_TREE, CV_CHAIN_APPROX_SIMPLE, Point(0, 0)); //对每个找到的轮廓创建可倾斜的边界框 vector&lt;RotatedRect&gt; minRect(contours.size()); for (int i = 0; i &lt; contours.size(); i++) &#123; minRect[i] = minAreaRect(Mat(contours[i])); &#125; bool flag=false;//是否有且仅有一个符合条件的边框 Point center(0,0);//轮廓中心点 double Area=-1; //筛选边框并且根据有效轮廓决定运动参数（如果有多个，则参数无意义） //绘出有效轮廓及其可倾斜的边界框 Mat drawing = Mat::zeros(src.size(), CV_8UC3); for (int i = 0; i&lt; contours.size(); i++) &#123; Point2f rect_points[4]; //轮廓四个拐点 minRect[i].points(rect_points); //计算方框相邻边长和面积 double side1=SideCalc(rect_points[0],rect_points[1]); double side2=SideCalc(rect_points[1],rect_points[2]); double area=side1*side2; //cout&lt;&lt;"area:"&lt;&lt;area&lt;&lt;endl; //判断轮廓形状是否是要求长方形 //cout&lt;&lt;"WHratio:"&lt;&lt;side1/side2&lt;&lt;" "&lt;&lt;side2/side1&lt;&lt;endl; if(side1/side2&gt;WHRATIO&amp;&amp;side2/side1&gt;WHRATIO)continue; //判断长方形长边的斜率 double longGrad; if(side1&gt;side2)longGrad=Grad(rect_points[0],rect_points[1]); else longGrad=Grad(rect_points[1],rect_points[2]); //cout&lt;&lt;"longGrad:"&lt;&lt;longGrad&lt;&lt;endl; if(longGrad&lt;GRAD)continue;//如果过于平缓，则淘汰该矩形 //判断轮廓的大小，并且根据可能轮廓判断轮廓与机器人距离 if(area&gt;=130000||area&lt;15000)continue;//如果距离过远或者过近则不运动，同时排除掉过小的边框 //寻找轮廓中心点，并绘制边框 for (int j = 0; j &lt; 4; j++) &#123; line(drawing, rect_points[j], rect_points[(j + 1) % 4], Scalar(0, 0, 255), 1, 50); center.x+=rect_points[j].x; center.y+=rect_points[j].y; &#125; center.x/=4; center.y/=4; circle(drawing,center,2,Scalar(0,0,255)); …… &#125; ……&#125; 针对运动决策功能3.1 对得到的边框进行筛选，并依据边框的大小进行判断目标的远近，边框中心点与图像中心点比较得到目标的左右偏离位置3.2 依据具体大小，偏离距离进行角速度和线速度的规划，并设置阻尼函数，使小车运行，线速度随远近而变大或变小，角速度随偏离距离增加或减小。3.3 最终实现机器人的人腿跟踪识别。源程序：运动规划 123456789101112131415161718192021222324252627282930313233343536double vec=0;double angle_vec=0;void Command(Mat src,geometry_msgs::Twist &amp;cmd_red)//根据分离出来的图像决定dashgo的行动&#123; …… for (int i = 0; i&lt; contours.size(); i++) &#123; …… if(Area&gt;-1)//已有有效边框 &#123; Area=-1; break; &#125; else Area=area; &#125; imshow("Contours",drawing); //制定机器人指令 if(Area==-1)//视野没有有效轮廓 &#123; return ; &#125; //判断机器人速度 double ref_vec=1.0f*(130000-Area)/260000.0f;//目标速度 vec=Damp(ref_vec,vec);//算出阻尼后的速度 cmd_red.linear.x=vec; //判断机器人前进的方向 double centerL=drawing.cols*5/11; double centerR=drawing.rows*6/11; double ref_angle_vec=0; if(center.x&lt;=centerL)ref_angle_vec=(centerL-center.x)/centerL;//左边 else if(center.x&gt;centerR)ref_angle_vec=(centerR-center.x)/centerL;//右边 angle_vec=Damp(ref_angle_vec,angle_vec);//算出阻尼后的速度 cmd_red.angular.z=angle_vec;&#125; 阻尼函数 123456#define Kp 0.1double Damp(double vec,double last_vec)&#123; double error=vec-last_vec; double output=last_vec+error*Kp; return output;&#125; 实验结果分别对颜色分割、特征提取、运动决策功能进行了实验验证，实验过程介绍结果1：对色度空间的转换和伽马变换实现了对黑色较好的的颜色分割。结果图：结果2：对已分割完成后的图片进行轮廓绘画并标出其中心点，并依据判断条件去除不符合条件的边框。结果图：结果3：根据轮廓中心点与图像中心点的坐标判断，得到机器人左右控制的速度指令。根据轮廓面积的大小控制机器人前进的速度大小。结果图： 结论本文设计了颜色分离，特征提取，运动决策算法，实现了对黑色的提取、对分离图片的边框选取、对机器人小车的运动控制功能，取得了有效提取并分离出黑色、对已分割图片轮廓的完好提取并绘画边框、较良好的控制小车的运动的效果。实验过程说明了颜色分割效果较好、轮廓边框判断选取准确、小车速度转速控制稳定。本文设计的算法具有如下优缺点：优点：使用最基础的算法和代码实现了较为良好的效果；算法条理清晰，并可以消除大量黑色干扰物体；消除了小车突然启动时的速度突变现象。缺点：背景中不能有大块的黑色干扰，否则会与人腿形状融合导致无法成为有效边框；只能识别纯色裤子的人腿，非常花哨的裤子可能会干扰；多个轮廓直接停止运动，不会继续跟随可以通过哪些方法进行改进：通过深度学习或者模式识别，直接针对人腿进行识别，可以较为良好的避免背景中的干扰，并且不再收到颜色的干扰；刚出现多个轮廓时，直接跟踪最大轮廓。]]></content>
      <categories>
        <category>计算机</category>
        <category>数字图像处理</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>OpenCV</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数字图像处理之目标颜色识别]]></title>
    <url>%2F%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E4%B9%8B%E7%9B%AE%E6%A0%87%E9%A2%9C%E8%89%B2%E8%AF%86%E5%88%AB.html</url>
    <content type="text"><![CDATA[实验要求找到目标颜色所在区域 算法实现 色度空间转换1.1 读取图像并滤波1.2 根据公式将图像从rgb转换到hsv色度空间 颜色分割2.1 利用 createTrackbar()函数建立滑动条，对颜色空间转换后的各通道进行阈值分割2.2 根据阈值分割的结果，判断各种颜色的对应阈值2.3 针对不同颜色，分别对图像进行阈值分割2.4 对阈值分割结果进行数学统计，判断图像的颜色并输出分类结果 目标颜色检测3.1 对图像进行预处理，消除噪声并获取二值化图3.2 对二值图进行轮廓检测；3.3 根据任务目标选择合适的多边形描述轮廓；3.4 获取多边形区域后，从原图中截取该区域图像；3.5 对多边形区域的图像进行颜色分割，对分割结果进行统计，判断图像的颜色并输出分类结果 代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239#include &lt;stdlib.h&gt;#include &lt;opencv2/opencv.hpp&gt;#include &lt;opencv2/core/core.hpp&gt;#define LINEAR_X 0#define SIZE 3#define PI 3.1415926#define HMaxValue 255#define SMaxValue 255#define VMaxValue 255#define oo 1e9+7using namespace std;using namespace cv;int H_min=100, H_max=124, S_min=43, S_max=255, V_min=46, V_max=255;Mat img_in;void Gaussian(Mat input, Mat output, double sigma)&#123; double weight;//权重 double sum = 0; double Gaussian_Temp[SIZE][SIZE] = &#123;0&#125;;//模板 weight = (2*PI*sigma*sigma); for(int i =0;i &lt;SIZE;i++) &#123; for(int j = 0;j &lt; SIZE;j++) &#123; int x = i - SIZE/2; int y = j - SIZE/2; Gaussian_Temp[i][j] =exp(-(x*x+y*y)/(2.0*sigma*sigma))/weight; sum += Gaussian_Temp[i][j]; &#125; &#125; for(int i = 0; i &lt; SIZE;i++) &#123; for(int j = 0;j &lt; SIZE;j++) &#123; Gaussian_Temp[i][j] = Gaussian_Temp[i][j]/sum;//归一化处理 //printf("%f ",Gaussian_Temp[i][j]); &#125; //printf("\n"); &#125; int rows = output.rows; int cols = output.cols; int channels = input.channels(); for(int i=0;i&lt;rows;i++) &#123; for(int j=0;j&lt;cols;j++) &#123; int sum3[3]=&#123;0&#125;; int sum1 = 0; for(int k=0;k&lt;SIZE;k++) for(int t=0;t&lt;SIZE;t++) &#123; int x=i+k-SIZE/2; int y=j+t-SIZE/2; if(x&lt;0||y&lt;0||x&gt;=rows||y&gt;=cols)continue; double m=Gaussian_Temp[k][t]; if(channels == 1)sum1+=m*input.at&lt;uchar&gt;(x,y); else if(channels == 3) &#123; Vec3b rgb = input.at&lt;Vec3b&gt;(x,y); sum3[0]+=m*rgb[0]; sum3[1]+=m*rgb[1]; sum3[2]+=m*rgb[2]; &#125; &#125; if(channels == 3)&#123; for(int k=0;k&lt;3;k++)&#123; if(sum3[k]&gt;255)sum3[k]=255; if(sum3[k]&lt;0)sum3[k]=0; output.at&lt;Vec3b&gt;(i,j)[k]=sum3[k]; &#125; &#125; else &#123; if(sum1&gt;255)sum1=255; if(sum1&lt;0)sum1=0; output.at&lt;uchar&gt;(i,j)=sum1; &#125; &#125; &#125;&#125;void RBG2HSV(Mat input,Mat output)&#123; int rows=input.rows; int cols=input.cols; //cout&lt;&lt;rows&lt;&lt;" "&lt;&lt;cols&lt;&lt;endl; for(int i=0;i&lt;rows;i++)&#123; for(int j=0;j&lt;cols;j++)&#123; Vec3b pix=input.at&lt;Vec3b&gt;(i,j);//012:BGR float b=1.0*pix[0]/255; float g=1.0*pix[1]/255; float r=1.0*pix[2]/255; float maxrgb=max(r,max(g,b)); float minrgb=min(r,min(g,b)); float diff=maxrgb-minrgb; float v=maxrgb; float s=(diff/v); float h; if(maxrgb-minrgb&lt;1e-5)h=0; else if(maxrgb==r)h=60*(g-b)/diff; else if(maxrgb==g)h=60*(b-r)/diff+120; else if(maxrgb==b)h=60*(r-g)/diff+240; if(h&lt;0)h+=360; else if(h&gt;359)h-=360; output.at&lt;Vec3b&gt;(i,j)[0]=(int)(h*180/360); output.at&lt;Vec3b&gt;(i,j)[1]=(int)(s*255); output.at&lt;Vec3b&gt;(i,j)[2]=(int)(v*255); &#125; &#125;&#125;/*画颜色统计图*/void Statistical(Mat input)&#123; int weigth=210,height=300; Mat output=Mat::zeros(height,weigth,CV_8UC3); int rows=input.rows; int cols=input.cols; int colorNum[7]=&#123;0&#125;; int sum=rows*cols; for(int i=0;i&lt;rows;i++)&#123; for(int j=0;j&lt;cols;j++)&#123; Vec3b pix=input.at&lt;Vec3b&gt;(i,j);//012:HSV if(pix[1]&lt;43||pix[2]&lt;46)continue; //pix[0]=pix[0]*180/255; int color=0; if((pix[0]&gt;=0&amp;&amp;pix[0]&lt;=10)||(pix[0]&gt;=156&amp;&amp;pix[0]&lt;=180))color=0; else if(pix[0]&gt;=11&amp;&amp;pix[0]&lt;=25)color=1; else if(pix[0]&gt;=26&amp;&amp;pix[0]&lt;=34)color=2; else if(pix[0]&gt;=35&amp;&amp;pix[0]&lt;=77)color=3; else if(pix[0]&gt;=78&amp;&amp;pix[0]&lt;=99)color=4; else if(pix[0]&gt;=100&amp;&amp;pix[0]&lt;=124)color=5; else if(pix[0]&gt;=125&amp;&amp;pix[0]&lt;=155)color=6; colorNum[color]++; &#125; &#125; Scalar Color[7]=&#123;Scalar(0,0,255),Scalar(0,125,255),Scalar(0,255,255),Scalar(0,255,0),Scalar(255,255,0),Scalar(255,0,0),Scalar(255,0,255)&#125;; for(int i=0;i&lt;7;i++)&#123; int h=colorNum[i]*height/sum; rectangle(output,Point(i*30,height),Point((i+1)*30-1, height-h),Color[i],-1); &#125; imshow("color",output);&#125;void colorDetection(Mat input)&#123; vector&lt;vector&lt;Point&gt; &gt; contours; vector&lt;Vec4i&gt; hierarchy; findContours( input, contours, hierarchy, RETR_EXTERNAL, CHAIN_APPROX_NONE, Point(0, 0) ); if(contours.size()==0)return; int area=0,x=0,y=0,a=0,b=0,c=0,d=0; for(int k=0;k&lt;contours.size();k++)&#123; RotatedRect rectPoint = minAreaRect(contours[k]); Point2f point[4]; //将rectPoint变量中存储的坐标值放到 point的数组中 rectPoint.points(point); //寻找轮廓的左上角和右下角，算出长宽 int max_x=0,max_y=0,min_x=oo,min_y=oo; for (int i = 0; i &lt; 4; i++) &#123; if (max_x &lt; point[i].x)max_x=int(point[i].x+0.5); if (max_y &lt; point[i].y)max_y=int(point[i].y+0.5); if (min_x &gt; point[i].x)min_x=(int)point[i].x; if (min_y &gt; point[i].y)min_y=(int)point[i].y; &#125; if(min_x&lt;0)min_x=0; if(min_y&lt;0)min_y=0; if(max_x&gt;=input.cols)max_x=input.cols-1; if(max_y&gt;=input.rows)max_y=input.rows-1; if((max_x-min_x)*(max_y-min_y)&gt;area)&#123; area=(max_x-min_x)*(max_y-min_y); x=min_x; y=min_y; a=max_x; b=max_y; c=max_x-min_x; d=max_y-min_y; &#125; &#125; if(c==0||d==0)return; //截取ROI区域 Mat output=img_in(Rect(x,y,c,d)); imshow("ROI",output); Mat hsv=Mat::zeros(output.size(),CV_8UC3); RBG2HSV(output,hsv); //统计截取之后的图像各种颜色的含量 Statistical(hsv);&#125;/*颜色分割*/void thresholdSeq(int var,void* usrdata)&#123; Mat input = *(static_cast&lt;Mat*&gt; (usrdata)); Mat output=Mat::zeros(input.size(),CV_8UC1); int rows=input.rows; int cols=input.cols; for(int i=0;i&lt;rows;i++)&#123; for(int j=0;j&lt;cols;j++)&#123; Vec3b pix=input.at&lt;Vec3b&gt;(i,j);//012:HSV if(pix[0]&lt;H_min||pix[0]&gt;H_max)continue; if(pix[1]&lt;S_min||pix[1]&gt;S_max)continue; if(pix[2]&lt;V_min||pix[2]&gt;V_max)continue; output.at&lt;uchar&gt;(i,j)=255; &#125; &#125; imshow("thresholdSeq",output); //目标颜色检测 colorDetection(output);&#125;int main(int argc, char **argv)&#123; //读取原始图像 img_in=imread(argv[1],IMREAD_UNCHANGED); //检查是否读取图像 if(img_in.empty())&#123; cout&lt;&lt;"Error! Input image cannot be read...\n"; return -1; &#125; imshow("src",img_in); Mat frOut1=Mat::zeros(img_in.size(),CV_8UC3); Mat frOut2=Mat::zeros(img_in.size(),CV_8UC1); // 空域滤波函数 Gaussian(img_in,frOut1,1); // 色度空间转换 RBG2HSV(frOut1,frOut1); //阈值分割 namedWindow("thresholdSeq"); createTrackbar("H_min", "thresholdSeq", &amp;H_min, HMaxValue, thresholdSeq,&amp;frOut1); createTrackbar("H_max", "thresholdSeq", &amp;H_max, HMaxValue, thresholdSeq,&amp;frOut1); createTrackbar("S_min", "thresholdSeq", &amp;S_min, SMaxValue, thresholdSeq,&amp;frOut1); createTrackbar("S_max", "thresholdSeq", &amp;S_max, SMaxValue, thresholdSeq,&amp;frOut1); createTrackbar("V_min", "thresholdSeq", &amp;V_min, VMaxValue, thresholdSeq,&amp;frOut1); createTrackbar("V_max", "thresholdSeq", &amp;V_max, VMaxValue, thresholdSeq,&amp;frOut1); waitKey(); return 0;&#125; 运行结果]]></content>
      <categories>
        <category>计算机</category>
        <category>数字图像处理</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>OpenCV</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数字图像处理之图像特征检测]]></title>
    <url>%2F%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E4%B9%8B%E5%9B%BE%E5%83%8F%E7%89%B9%E5%BE%81%E6%A3%80%E6%B5%8B.html</url>
    <content type="text"><![CDATA[实验要求 边缘检测 霍夫线变换 霍夫圆变换 算法实现边缘检测本代码采用LoG边缘检测算子 算子与图像卷积 寻找零交叉点，即边缘点 霍夫线变换 将彩色图像转化为灰度图，并对灰度图做边缘检测得到二值边缘图 参数空间离散化:对直线方程的参数$(r,\theta)$离散化，并给出$(r_{min},r_{max})$和$(\theta_{min},\theta_{max})$，划分为有限个等间距的离散值，使参数空间量化为一个个等大小网格。 设置累加器A:为每个网格单元设置累加器。A表示$(r_{min}:r_{max},\theta_{min}:\theta_{max})$，初始为0。 对图像空间中每个像素点坐标值(x,y)，计算参数空间对应的曲线方程，将该曲线穿过的格子的计数值加一。 最后，遍历A(i,j)中的寻找累加计数大于某阈值M格子，其坐标$(r_m, \theta_m)$即为检测到的直线参数。利用cvtColor()将二值边缘图转换为RGB图，并将检测到的所有直线在图中画出来。 霍夫圆变换 将彩色图像转化为灰度图，并对灰度图做边缘检测得到二值边缘图 设定检测半径和角度范围$(r_{min}:r_{max},\theta_{min}:\theta_{max})$，ax)，设置累加器A(x,y,r) 对图像空间中每个像素点坐标值(x,y)，在指定半径和圆心角范围内，计算参数空间对应的圆心，累加器A(x_center, y_center,r)加一。 最后，遍历累加器中的寻找累加计数大于某阈值M格子，其坐标$(x_center, y_center,r)$即为检测到的圆参数。利用cvtColor()将二值边缘图转换为RGB图，并将检测到的所有直线在图中画出来。 显然这样的方法效率很低，时间和空间复杂度都很高，所以我们用梯度法优化。 用sobel算子计算出整张图的梯度 对于图像中每个点，在其梯度方向上的点的累加器A(x,y)加一 遍历A(i,j)中的寻找累加计数大于某阈值M格子，其坐标$(x,y)$即为可能是圆心的点。 对于每个圆心计算每个像素点与他的距离，并塞入数组R，然后寻找最多的半径R的数量，如果大于阈值那么就以该圆心半径画圆。若俩个圆心距离很近，那么就选其一。 代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276#include &lt;stdlib.h&gt;#include &lt;opencv2/opencv.hpp&gt;#include &lt;opencv2/core/core.hpp&gt;#include &lt;vector&gt;#define LINEAR_X 0#define SIZE 5#define PI 3.1415926#define oo 1e9+7#define theta_cnt 500using namespace cv;using namespace std;//////////////////////边缘检测////////////////////边缘检测函数 LoG边缘检测算子void EdgeDetector(Mat input, Mat &amp;output)&#123; threshold(input, input, 150, 255, THRESH_BINARY); //imshow("threshold",input); double Gaussian_Temp[SIZE][SIZE] = &#123;&#123;0,0,-1,0,0&#125;, &#123;0,-1,-2,-1,0&#125;, &#123;-1,-2,16,-2,-1&#125;, &#123;0,-1,-2,-1,0&#125;, &#123;0,0,-1,0,0&#125;&#125;;//模板 //Mat Temp=Mat::zeros(input.size(),CV_8UC1); int rows = input.rows; int cols = input.cols; double *Temp = new double[rows*cols]; for(int i=0;i&lt;rows;i++) &#123; for(int j=0;j&lt;cols;j++) &#123; double sum = 0; for(int k=0;k&lt;SIZE;k++) for(int t=0;t&lt;SIZE;t++) &#123; int x=i+k-SIZE/2; int y=j+t-SIZE/2; if(x&lt;0||y&lt;0||x&gt;=rows||y&gt;=cols)continue; double m=Gaussian_Temp[k][t]; sum+=m*input.at&lt;uchar&gt;(x,y); &#125; Temp[i*cols+j]=sum; &#125; &#125; //寻找零交叉 int dx[2][4]=&#123;&#123;-1,0,1,-1&#125;,//上，左，左上，左下 &#123;1,0,-1,1&#125;&#125;;//下，右，右下，右上 int dy[2][4]=&#123;&#123;0,-1,-1,-1&#125;,//上，左，左上，左下 &#123;0,1,1,1&#125;&#125;;//下，右，右下，右上 for(int i=0;i&lt;rows;i++) &#123; for(int j=0;j&lt;cols;j++) &#123; int pa,pb,num=0; for(int k=0;k&lt;4;k++)&#123; int x1=i+dx[0][k],y1=j+dy[0][k]; int x2=i+dx[1][k],y2=j+dy[1][k]; if(x1&lt;0||y1&lt;0||x1&gt;=rows||y1&gt;=cols)pa=0; else pa=Temp[x1*cols+y1]; if(x2&lt;0||y2&lt;0||x2&gt;=rows||y2&gt;=cols)pb=0; else pb=Temp[x2*cols+y2]; if(pa*pb&lt;0&amp;&amp;abs(pa-pb)&gt;255*0.5)num++; //cout&lt;&lt;pa&lt;&lt;" "&lt;&lt;pb&lt;&lt;endl; &#125; if(num&gt;=2)output.at&lt;uchar&gt;(i,j)=255; else output.at&lt;uchar&gt;(i,j)=0; &#125; &#125;&#125;//////////////////////霍夫线变换//////////////////Mat Hough_Line(Mat input)&#123; Mat output=Mat::zeros(input.size(),CV_8UC3); cvtColor(input,output,COLOR_GRAY2BGR); int rows = input.rows; int cols = input.cols; int max_length = sqrt(pow(rows,2)+pow(cols,2)); int r_cnt=max_length*2; int M = 100;//阈值 int *A = new int[r_cnt*theta_cnt];//累加器 //遍历，并累加 for(int i=0;i&lt;rows;i++) &#123; for(int j=0;j&lt;cols;j++) &#123; if(input.at&lt;uchar&gt;(i,j)==0)continue; for(int k=0;k&lt;theta_cnt;k++)&#123; double theta=2.0*PI*k/theta_cnt; int r=1.0*i*cos(theta)+1.0*j*sin(theta);//直线方程 if(r&lt;-max_length||r&gt;=max_length)continue; A[(r+max_length)*theta_cnt+k]++; &#125; &#125; &#125; //画直线 for(int i=0;i&lt;r_cnt;i++)&#123; for(int j=0;j&lt;theta_cnt;j++)&#123; if(A[i*theta_cnt+j]&lt;M)continue; if((i&gt;0&amp;&amp;A[i*theta_cnt+j]&lt;A[(i-1)*theta_cnt+j]) ||(j&gt;0&amp;&amp;A[i*theta_cnt+j]&lt;A[i*theta_cnt+j-1]))continue; if((i&lt;r_cnt-1&amp;&amp;A[i*theta_cnt+j]&lt;A[(i+1)*theta_cnt+j]) ||(j&lt;theta_cnt-1&amp;&amp;A[i*theta_cnt+j]&lt;A[i*theta_cnt+j+1]))continue; double theta=2.0*PI*j/theta_cnt; int r = i-max_length; double a = cos(theta); double b = sin(theta); double x1 = int(b*r + 1000*(a)); double y1 = int(a*r + 1000*(-b)); double x2 = int(b*r - 1000*(a)); double y2 = int(a*r - 1000*(-b)); line(output,Point(x1,y1),Point(x2,y2),Scalar(0,0,255),1); &#125; &#125; return output;&#125;//////////////////////霍夫圆变换//////////////////Mat calc(Mat input,double kernel[3][3],int Size)&#123; Mat output=Mat::zeros(input.size(),CV_8UC1); int rows = input.rows; int cols = input.cols; for(int i=0;i&lt;rows;i++) &#123; for(int j=0;j&lt;cols;j++) &#123; for(int k=0;k&lt;Size;k++) for(int t=0;t&lt;Size;t++) &#123; int x=i+k-Size/2; int y=j+t-Size/2; if(x&lt;0||y&lt;0||x&gt;=rows||y&gt;=cols)continue; double m=kernel[k][t]; output.at&lt;int&gt;(i,j)+=m*input.at&lt;uchar&gt;(x,y); &#125; &#125; &#125; return output;&#125;Mat Hough_Circle(Mat input)&#123; Mat output=Mat::zeros(input.size(),CV_8UC3); cvtColor(input,output,COLOR_GRAY2BGR); int rows = input.rows; int cols = input.cols; int r_max=max(rows,cols)/2; double M = 0.1; int A[rows][cols]=&#123;0&#125;; double sobelx[3][3]=&#123;&#123;1,2,1&#125;, &#123;0,0,0&#125;, &#123;-1,-2,-1&#125;&#125;; double sobely[3][3]=&#123;&#123;1,0,-1&#125;, &#123;2,0,-2&#125;, &#123;1,0,-1&#125;&#125;; Mat dx=calc(input,sobelx,3); Mat dy=calc(input,sobely,3); //累加器寻找圆心 for(int i=0;i&lt;rows;i++) &#123; for(int j=0;j&lt;cols;j++) &#123; if(input.at&lt;uchar&gt;(i,j)==0)continue; double vx=dx.at&lt;int&gt;(i,j); double vy=dy.at&lt;int&gt;(i,j); double mag=sqrt(vx*vx+vy*vy); if(mag == 0)continue; double sx=vx/mag; double sy=vy/mag; for(int t=-1;t&lt;2;t+=2)&#123; double x=1.0*i+sx*t; double y=1.0*j+sy*t; for(int r=0;r&lt;r_max;r++,x+=sx*t,y+=sy*t) &#123; int X=int(x),Y=int(y); if(X&lt;0||Y&lt;0||X&gt;=rows||Y&gt;=cols)break; A[X][Y]++; &#125; &#125; &#125; &#125; //寻找可能圆心 vector&lt;Point&gt;centerP; vector&lt;Point&gt;circleP; for(int i=0;i&lt;rows;i++) &#123; for(int j=0;j&lt;cols;j++) &#123; if(A[i][j]&lt;50)continue; if((i&gt;0&amp;&amp;A[i][j]&lt;A[i-1][j])||(j&gt;0&amp;&amp;A[i][j]&lt;A[i][j-1]))continue; if((i&lt;rows-1&amp;&amp;A[i][j]&lt;A[i+1][j])||(j&lt;cols-1&amp;&amp;A[i][j]&lt;A[i][j+1]))continue; centerP.push_back(Point(i,j)); &#125; &#125; //对每个可能圆心，寻找可能半径 int l=centerP.size(); for(int i=0;i&lt;l;i++)&#123; int cx=centerP[i].x; int cy=centerP[i].y; int L=circleP.size(); bool flag=0; for(int j=0;j&lt;L;j++)&#123; int cx1=circleP[j].x; int cy1=circleP[j].y; if( pow(( cx1- cx),2) + pow( cy1- cy,2) &lt;= 9)&#123;//圆心相近 flag=1; break; &#125; &#125; if(flag)continue; vector&lt;int&gt;R; for(int k=0;k&lt;rows;k++) &#123; for(int t=0;t&lt;cols;t++) &#123; if(input.at&lt;uchar&gt;(k,t)==0)continue; int r=sqrt(pow(cx-k,2)+pow(cy-t,2)); if(r+cx&lt;rows&amp;&amp;r+cy&lt;cols&amp;&amp;cx-r&gt;=0&amp;&amp;cy-r&gt;=0)R.push_back(r); &#125; &#125; //半径数最多的就是最有可能的 if(R.size()==0)continue; sort(R.begin(),R.end()); int startR=R[0],cnt=0,maxcnt=0,ansR=0; for(int j=1;j&lt;R.size();j++)&#123; int r=R[j]; if(r-startR&gt;2)&#123; int nowR=(R[j-1]+startR)/2; if(cnt*ansR&gt;=maxcnt*nowR)&#123; ansR=nowR; maxcnt=cnt; &#125; cnt=0; startR=r; &#125; cnt++; &#125; if(maxcnt&gt;700)&#123; circle(output, Point(cy,cx),ansR , Scalar(0, 0, 255), 0.5); circleP.push_back(Point(cx,cy)); &#125; &#125;/**/ return output;&#125;int main(int argc,char **argv)&#123; //读取原始图像 Mat src=imread(argv[1],IMREAD_UNCHANGED); //检查是否读取图像 if(src.empty())&#123; std::cout&lt;&lt;"Error! Input image cannot be read...\n"; return -1; &#125; imshow("src",src); // 灰度图转换 Mat garyimg; cvtColor(src,garyimg,COLOR_BGR2GRAY); imshow("gray",garyimg); // 边缘检测函数 Mat frOut1=Mat::zeros(garyimg.size(),CV_8UC1); EdgeDetector(garyimg, frOut1); // 线检测 Mat frOut2=Hough_Line(frOut1); // 圆检测 Mat frOut3=Hough_Circle(frOut1) ; imshow("Edge",frOut1); imshow("Line",frOut2); imshow("circle",frOut3); std::cout &lt;&lt; "Press any key to exit...\n"; waitKey(); // Wait for key press return 0;&#125; 运行结果]]></content>
      <categories>
        <category>计算机</category>
        <category>数字图像处理</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>OpenCV</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数字图像处理之图像滤波与形态学]]></title>
    <url>%2F%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E4%B9%8B%E5%9B%BE%E5%83%8F%E6%BB%A4%E6%B3%A2%E4%B8%8E%E5%BD%A2%E6%80%81%E5%AD%A6.html</url>
    <content type="text"><![CDATA[前言又咕了一个学期，上学期的东西都没写完，惭愧惭愧。 实验要求 空域滤波1.1 设计高斯滤波器模板函数1.2 填充图像，将模板函数与图像进行卷积1.3 截取图像，获得滤波后的图像 腐蚀/膨胀算法2.1 读取图片2.2 腐蚀/膨胀算法2.3 将经过腐蚀或膨胀后的图片显示 代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158#include &lt;stdlib.h&gt;#include &lt;opencv2/opencv.hpp&gt;#include &lt;opencv2/core/core.hpp&gt;#include &lt;iostream&gt;#define LINEAR_X 0#define SIZE 5#define PI 3.1415926using namespace cv;void threshold(Mat input,Mat &amp;output,int var)&#123; int rows = output.rows; int cols = output.cols; for(int i=0;i&lt;rows;i++) &#123; for(int j=0;j&lt;cols;j++) &#123; int p=input.at&lt;uchar&gt;(i,j); if(p&gt;var) output.at&lt;uchar&gt;(i,j)=255; else output.at&lt;uchar&gt;(i,j)=0; &#125; &#125;&#125;//////////////////////滤波//////////////////// 空域高斯滤波器函数void Gaussian(Mat input, Mat &amp;output, double sigma)&#123; double weight;//权重 double sum = 0; double Gaussian_Temp[SIZE][SIZE] = &#123;0&#125;;//模板 weight = (2*PI*sigma*sigma); for(int i =0;i &lt;SIZE;i++) &#123; for(int j = 0;j &lt; SIZE;j++) &#123; int x = i - SIZE/2; int y = j - SIZE/2; Gaussian_Temp[i][j] =exp(-(x*x+y*y)/(2.0*sigma*sigma))/weight; sum += Gaussian_Temp[i][j]; &#125; &#125; for(int i = 0; i &lt; SIZE;i++) &#123; for(int j = 0;j &lt; SIZE;j++) &#123; Gaussian_Temp[i][j] = Gaussian_Temp[i][j]/sum;//归一化处理 &#125; &#125; //卷积 int rows = output.rows; int cols = output.cols; for(int i=0;i&lt;rows;i++) &#123; for(int j=0;j&lt;cols;j++) &#123; for(int k=0;k&lt;SIZE;k++) for(int t=0;t&lt;SIZE;t++) &#123; int x=i+k-SIZE/2; int y=j+t-SIZE/2; if(x&lt;0||y&lt;0||x&gt;=rows||y&gt;=cols)continue; int p=input.at&lt;uchar&gt;(x,y); output.at&lt;uchar&gt;(i,j)+=p*Gaussian_Temp[k][t]; &#125; if(output.at&lt;uchar&gt;(i,j)&gt;255)output.at&lt;uchar&gt;(i,j)=255; if(output.at&lt;uchar&gt;(i,j)&lt;0)output.at&lt;uchar&gt;(i,j)=0; &#125; &#125;&#125;// 膨胀函数void Dilate(Mat Src, Mat Tem, Mat Dst)&#123; int rows = Dst.rows; int cols = Dst.cols; int t_rows = Tem.rows; int t_cols = Tem.cols; for(int i=0;i&lt;rows;i++) &#123; for(int j=0;j&lt;cols;j++) &#123; int p = Src.at&lt;uchar&gt;(i,j); if(p == 0)continue; for(int k=0;k&lt;t_rows;k++) for(int t=0;t&lt;t_cols;t++) &#123; int x=i+k; int y=j+t; if(x&lt;0||y&lt;0||x&gt;=rows||y&gt;=cols)continue; if(Tem.at&lt;uchar&gt;(k,t) == 1) Dst.at&lt;uchar&gt;(x,y)=255; &#125; &#125; &#125;&#125;// 腐蚀函数void Erode(Mat Src, Mat Tem, Mat Dst)&#123; int rows = Dst.rows; int cols = Dst.cols; int t_rows = Tem.rows; int t_cols = Tem.cols; for(int i=0;i&lt;rows;i++) &#123; for(int j=0;j&lt;cols;j++) &#123; int sum = 0; for(int k=0;k&lt;t_rows;k++) for(int t=0;t&lt;t_cols;t++) &#123; int x=i+k-t_rows/2; int y=j+t-t_cols/2; if(x&lt;0||y&lt;0||x&gt;=rows||y&gt;=cols)continue; sum +=Tem.at&lt;uchar&gt;(k,t)*Src.at&lt;uchar&gt;(x,y); &#125; if(sum == 13*255)Dst.at&lt;uchar&gt;(i,j)=255; &#125; &#125;&#125;int main(int argc,char **argv)&#123; //读取原始图像 Mat src=imread(argv[1],IMREAD_UNCHANGED); //检查是否读取图像 if(src.empty())&#123; std::cout&lt;&lt;"Error! Input image cannot be read...\n"; return -1; &#125; imshow("src",src); cvtColor(src,src,COLOR_BGR2GRAY); Mat dst1=Mat::zeros(src.size(),CV_8UC1); Mat dst2=Mat::zeros(src.size(),CV_8UC1); Mat dst3=Mat::zeros(src.size(),CV_8UC1); Mat Thimg=Mat::zeros(src.size(),CV_8UC1); threshold(src,Thimg,255/2); Mat dstOut; //GaussianBlur(img_out,dstOut,Size(3,3),1,1); // 空域滤波函数 Gaussian(src,dst1,0.8); // 膨胀函数 uchar matrix1[5][5] = &#123;&#123;1,1,1,1,1&#125;,&#123;1,1,1,1,0&#125;, &#123;1,1,1,0,0&#125;, &#123;1,1,0,0,0&#125;, &#123;1,0,0,0,0&#125;&#125;; Mat Tem1(Size(5,5), CV_8UC1, matrix1);//注意：opencv里的行列顺序是和maltab相反的 //由于Mat矩阵默认的是uchar类型，所以前后一致，定义矩阵时也要定义uchar类型 Dilate(Thimg,Tem1,dst2); // 腐蚀函数 uchar matrix2[5][5] = &#123;&#123;0,0,1,0,0&#125;, &#123;0,1,1,1,0&#125;,&#123;1,1,1,1,1&#125;,&#123;0,1,1,1,0&#125;,&#123;0,0,1,0,0&#125;&#125;; Mat Tem2(Size(5,5), CV_8UC1, matrix2);//注意：opencv里的行列顺序是和maltab相反的 //由于Mat矩阵默认的是uchar类型，所以前后一致，定义矩阵时也要定义uchar类型 Erode(Thimg,Tem2,dst3); imshow("高斯滤波",dst1); imshow("膨胀",dst2); imshow("腐蚀",dst3); std::cout &lt;&lt; "Press any key to exit...\n"; waitKey(); // Wait for key press return 0;&#125; 运行结果]]></content>
      <categories>
        <category>计算机</category>
        <category>数字图像处理</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>OpenCV</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数字图像处理之图像获取与直方图均衡化]]></title>
    <url>%2F%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E4%B9%8B%E5%9B%BE%E5%83%8F%E8%8E%B7%E5%8F%96%E4%B8%8E%E7%9B%B4%E6%96%B9%E5%9B%BE%E5%9D%87%E8%A1%A1%E5%8C%96.html</url>
    <content type="text"><![CDATA[前言咕了一个学期，终于有时间也有东西可写了，虽然只是大三上修的数字图像处理的实验而已。 实验要求 统计每个灰度下的像素个数 绘制出直方图 计算累计密度 重新计算均衡化后的灰度值，四舍五入 直方图均衡化，更新原图每个点的像素值 直方图均衡化直方图均衡化是常用的图像增强处理技术，其原理为：r：原图像灰度级s：均衡化后的图像灰度级$ P_r(w)$：图像灰度概率分布$ P_s(w)$：均衡化后的图像灰度概率分布设直方图均衡化变换函数为s=T(r)，有\int_{rmin}^r{P_r(w)dw}=\int_{smin}^s{P_s(w)dw}=C(r)其中C(r)为累计分布函数若期望变换后输出图像的灰度概率密度均匀分布，即P_s(s)=\frac{1}{smax-smin}，则C(r)=\int_{smin}^s{\frac{1}{smax-smin}dw}=\frac{s-smin}{smax-smin}所以可得s=[smax-smin]C(r)+smin 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980#include &lt;iostream&gt;#include &lt;opencv2/opencv.hpp&gt;using namespace std;using namespace cv;int p_cnt[256];float p_sum[256];int s[256];int rows,cols;void DrawHistogram(string name,Mat src)&#123; for(int i=0;i&lt;256;i++)p_cnt[i]=0; int maxvalue = 0; for(int i=0;i&lt;rows;i++) &#123; for(int j=0;j&lt;cols;j++) &#123; int p = src.at&lt;uchar&gt;(i,j); p_cnt[p]+=1; if(p_cnt[p]&gt;maxvalue)&#123; maxvalue=p_cnt[p]; &#125; &#125; &#125; cv::Mat histogram(Size(256,256),CV_8U,Scalar(0)); for(int i=0;i&lt;256;i++)&#123; int h=p_cnt[i]*255/maxvalue;//归一化 line(histogram,Point(i,255),Point(i,255-h),Scalar(255)); &#125; imshow(name,histogram);&#125;int main(int argc,char **argv)&#123; Mat img_in,img_out; //读取原始图像 img_in=imread(argv[1],IMREAD_UNCHANGED); //检查是否读取图像 if(img_in.empty())&#123; cout&lt;&lt;"Error! Input image cannot be read...\n"; return -1; &#125; imshow("src",img_in); //转化为灰度图 //code cv::Mat grayimg; cv::cvtColor(img_in,grayimg,CV_BGR2GRAY); imshow("均衡化前的图像",grayimg); rows = grayimg.rows; cols = grayimg.cols; int N = cols*rows; DrawHistogram("均衡化前的直方图",grayimg); //直方图均衡化 for(int i=0;i&lt;256;i++)&#123; if(i==0)&#123; p_sum[i]=1.0*p_cnt[i]/N; &#125; else p_sum[i]=p_sum[i-1]+1.0*p_cnt[i]/N; s[i] = p_sum[i]*255+0.5; &#125; //更新像素灰度值 cv::Mat finaimg(grayimg); for(int i=0;i&lt;rows;i++) &#123; for(int j=0;j&lt;cols;j++) &#123; int p = grayimg.at&lt;uchar&gt;(i,j); finaimg.at&lt;uchar&gt;(i,j) = s[p]; &#125; &#125; imshow("均衡化后的图像",finaimg); DrawHistogram("均衡化后的直方图",finaimg); cout &lt;&lt; "Press any key to exit...\n"; waitKey(); // Wait for key press return 0;&#125; 运行结果]]></content>
      <categories>
        <category>计算机</category>
        <category>数字图像处理</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>OpenCV</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【RPGMakerMV】滑冰谜题]]></title>
    <url>%2F%E3%80%90RPGMakerMV%E3%80%91%E6%BB%91%E5%86%B0%E8%B0%9C%E9%A2%98.html</url>
    <content type="text"><![CDATA[前言project1论坛上已经有过滑冰谜题的教程了，但是这个教程里的滑冰谜题和我想要的不太一样。我想要做的是遇到障碍物才停止的效果，而并非离开冰面停止。网上搜了搜，好像并没有教程，倒是看到有人说可以用YEP_SlipperyTiles插件完成，然而我没搞清楚这个插件的用法。因此最后就自己根据原先的那个教程改进了一下，得到了自己想要的效果。 实现方法地图设置 区域ID：2个 1：踩到就进入滑冰状态，向当前朝向前进一步。覆盖冰面。 2: 踩到就离开滑冰状态，恢复正常。放置于冰面出口 注意点：冰面四周要铺满无法通行的障碍物，因为$gamePlayer.isMapPassable()无法判定地图边界。 事件变量：3个 001 X (玩家地图坐标X) 002 Y (玩家地图坐标Y) 003 RegionID 开关：1个 001 滑冰 公共事件：1个 001 滑冰 地图事件 同样我们也要在地图里放一个并行事件调用滑冰公共事件]]></content>
      <categories>
        <category>游戏</category>
        <category>RPGMaker</category>
      </categories>
      <tags>
        <tag>RPGMaker</tag>
        <tag>游戏</tag>
        <tag>教程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HackingLab之脚本关攻略]]></title>
    <url>%2FHackingLab%E4%B9%8B%E8%84%9A%E6%9C%AC%E5%85%B3%E6%94%BB%E7%95%A5.html</url>
    <content type="text"><![CDATA[开始脚本关的攻略！！本次依旧无题目描述。网络信息安全攻防学习平台 第一关这题不是跟基础关的第八题一样吗？使用的python代码也只用改一下url，key就直接出来了。1234567import requestsurl = &quot;http://lab1.xseclab.com/xss1_30ac8668cd453e7e387c76b132b140bb/search_key.php&quot;r = requests.get(url,allow_redirects=False)# 请求获取URL位置的资源，包含从服务器返回的所有内容r.encoding = r.apparent_encodingr.encoding = &apos;utf-8&apos;print(r.text) yougotit_script_now 第二关第二关需要在两秒内计算式子并提交，但很显然两秒的时间就算能算出来也不够输入。所以我们需要写一个脚本能够计算这个式子并且提交答案。 我们通过re模块，使用正则表达式提取算数表达式。由于他的式子只有a*b+c*(d+e)的形式，所以我们的正则表达式只需匹配这种表达式，即(\d+[+*])+((\d+)+(\d+))。 另外需要注意的一点是，由于每次访问的时候式子都会改变，所以我们需要保持会话，让我们获取式子和提交答案访问的是同一个会话。123456789101112131415161718192021222324252627import requestsimport reurl = &quot;http://lab1.xseclab.com/xss2_0d557e6d2a4ac08b749b61473a075be1/index.php&quot;#维持会话,可以让我们在跨请求时保存某些参数session = requests.session()# 请求获取URL位置的资源，包含从服务器返回的所有内容r = session.get(url);&apos;&apos;&apos;r&apos;&apos;一般用在正则表达式中，称为原始字符串，作用是将Python语法中的反斜杠转义给取消，将其设置成为一个普通的字符串。可以解决Python中的转义字符和正则表达式中的转义字符之间的冲突问题。&apos;&apos;&apos;expression = re.search(r&apos;(\d+[+*])+\((\d+)\+(\d+)\)&apos;,r.text).group()# eval() 函数用来执行一个字符串表达式，并返回表达式的值。result = eval(expression)print(expression)print(result)r = session.post(url,data=&#123;&apos;v&apos;:result&#125;);# 请求获取URL位置的资源，包含从服务器返回的所有内容r.encoding = r.apparent_encodingr.encoding = &apos;utf-8&apos;print(r.text) 123iohHKHJ%^&amp;*(jkh 第三关第三关的关键字就是空。我一开始想难道是要求我们直接提交空信息？什么都不填点提交却弹出“请输入答案”的窗口。于是我将判断空信息的js代码删去，却发现并没有什么效果。最后查了答案，才发现需要填null。 null 第四关查看源码，发现head中有一大堆js代码显然第一个函数function alert(a)导致a函数无法执行。将网页保存到本地，然后删去此函数再次打开即可。 不过要注意’chars’不算在14个字符当中 slakfjteslkjsd 待续]]></content>
      <categories>
        <category>计算机</category>
        <category>Hack</category>
      </categories>
      <tags>
        <tag>Hack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于u盘运行veket系统这件事]]></title>
    <url>%2F%E5%85%B3%E4%BA%8Eu%E7%9B%98%E8%BF%90%E8%A1%8Cveket%E7%B3%BB%E7%BB%9F%E8%BF%99%E4%BB%B6%E4%BA%8B.html</url>
    <content type="text"><![CDATA[前言上网冲浪时，我偶然了解到可以装在u盘里随身携带的轻量级操作系统。想到家里有一台硬盘损坏无法安装操作系统的老笔记本电脑，我琢磨着能否通过这类操作系统让这台老家伙摆脱被贱卖的命运。 所需工具 轻量级Linux系统veketveket是一个容量很小，资源要求很低，同时集成了大部分常用软件的操作系统。更重要的是，该系统的图形界面接近于windows，长辈容易操作。 YUMI MulitbootUSB其实只要一种讲iso镜像文件写入u盘的工具就好了，常用的软碟通就行。我选择这个工具主要是因为我本来想搞多重引导的u盘。 8G的U盘一个不小于4G的U盘就够用了，毕竟veket才500M左右。 一台老电脑最好还是内存不小于2G吧（1G似乎也行？）。 使用过程其实安装过程也没甚好写的，毕竟这玩意比普通安装系统还要简单，我就随便水水流程好了。 通过YUMI工具将veket的iso镜像文件写入U盘。由于使用的工具可能不大一样，所以我就不写具体操作了。 进入老电脑的BIOS界面，将电脑设置成优先USB方式启动。不同电脑的设置方式不同，不过网上一般都有教程。 将U盘插入老电脑，再次开机，进入启动界面。一般来说全选择第一个选项就好，除非使用者有其他用途。 如此便可以使用了。不过veket系统需要注意的是第一次关机时，系统会询问你是否保存数据。如果使用者没有保存数据的需求（比如只是为了体验），那么选择不保存即可。如果先要保存数据，也只需要安装提示一步一步来（以后就不用了）。 若有什么地方不太明白，可以到veket的论坛上逛一逛。 结语挺水的一篇教程，主要目的也只是记录一下使用的工具。以前发现笔记本的硬盘损坏后，我也想过直接使用Ubuntu启动盘里的试用系统，然而连个视频都看不了就放弃了。如今使用veket系统后，虽然长时间使用的话电脑还是会卡死（硬伤，莫得办法），但是好歹平时用得还是挺流畅的。其实我本来是在纠结到底选择CDLinux还是veket的，后来想着全都要算了，结果发现CDLinux不知道为何写入不了U盘，只能作罢。所以我的多引导系统U盘并没能完成，着实感到遗憾。]]></content>
      <categories>
        <category>教程</category>
      </categories>
      <tags>
        <tag>教程</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HackingLab之基础关攻略]]></title>
    <url>%2FHackingLab%E4%B9%8B%E5%9F%BA%E7%A1%80%E5%85%B3%E6%94%BB%E7%95%A5.html</url>
    <content type="text"><![CDATA[前言作为一无所知的小白，我仅仅是将此作为摸鱼时的一种解谜游戏看待，因此不会事先去恶补过多的知识，遇到盲点也会果断放弃，上网查攻略，毕竟乐趣作为重要。 每一关的解法并不唯一，可以用抓包工具，也可以只用python，我的想法是能写多少写多少方法。题目什么的我也懒得复制粘贴了，毕竟没有意义。 攻防平台 闯关第一关讲道理，看到题目就想到查看源代码。直接F12，答案写在注释里。 jflsjklejflkdsjfklds 第二关密文再加密一次又变回明文，既然全是小写字母，就很容易想到与13位后的对应字母替换。查询可知这种加密算法叫做Rot13。 23ksdjfkfds 第三关大致看一下密文，发现最后一位是特殊字符“=”，搜索一下与等号有关的加密算法，查到base64算法。在线解密，最终可以得到key。 jkljdkl232jkljkdl2389 第四关既然题目都说了MD5，何不一试？ bighp 第五关小白没什么思路，搜索关键字无果，于是看攻略。修改请求头中的Accept-Language参数。这意思就是根据语言判断是否是外国人呗……方法一：直接修改浏览器的语言，把中文删去。方法二：用python的request库伪造请求头的Accept-Language参数，然后访问网址，并打印响应内容。1234567import requestsurl = "http://lab1.xseclab.com/base1_0ef337f3afbe42d5619d7a36c19c20ab/index.php"headers = &#123;'Accept-Language': 'q=0.5,en-US;q=0.3,en;q=0.2'&#125;#伪造请求头参数r = requests.get(url,headers=headers)# 请求获取URL位置的资源，包含从服务器返回的所有内容r.encoding = r.apparent_encodingr.encoding = 'utf-8'print(r.text) (TU687jksf6&amp; 第六关搜索引擎搜索关键字，发现似乎与“User-Agent”这个属性有关。F12到Network观察请求头，找到该属性，后面参数可以明显看出和浏览器相关，或许修改此处即可。方法一（以Chrome为准）：F12打开开发者工具，点击右上方三个点，点击More Tools-&gt;Network conditions，直接修改User-Agent的值。方法二：用python的request库伪造请求头的User-Agent参数，然后访问网址，并打印响应内容。12345678import requestsurl = "http://lab1.xseclab.com/base6_6082c908819e105c378eb93b6631c4d3/index.php"headers = &#123;'User-Agent':'HAHA'&#125;r = requests.get(url,headers=headers)# 请求获取URL位置的资源，包含从服务器返回的所有内容r.encoding = r.apparent_encodingr.encoding = 'utf-8'print(r.text) meiyouHAHAliulanqi 第七关没什么想法，看攻略说是藏在响应头里。方法一：F12到开发者工具查看Network里的响应头，就看到答案了。方法二：用python的request库申请资源，打印响应头。1234567import requestsurl = "http://lab1.xseclab.com/base7_eb68bd2f0d762faf70c89799b3c1cc52/index.php"r = requests.get(url)# 请求获取URL位置的资源，包含从服务器返回的所有内容r.encoding = r.apparent_encodingr.encoding = 'utf-8'print(r.headers) kjh%#$#%FDjjj 第八关将鼠标放在超链接“_到这里找key__”上时，发现左下角显示链接与点击链接后的网址不同，可知发生了重定向。搜索浏览器如何阻止重定向，方法无效。搜索python的request库访问如何阻止重定向，找到解决方法，只需再get函数中添加属性allow_redirects=False即可。注意申请的链接是超链接显示的链接。 1234567import requestsurl = "http://lab1.xseclab.com/base8_0abd63aa54bef0464289d6a42465f354/search_key.php"r = requests.get(url,allow_redirects=False)# 请求获取URL位置的资源，包含从服务器返回的所有内容r.encoding = r.apparent_encodingr.encoding = 'utf-8'print(r.text) 可以得到一个网址./key_is_here_now_.php ohHTTP302dd 第九关搜索关键字，发现登录信息与cookie有关，并且发现测试网址使用了一个名为“Login”的cookie。F12到Network查看请求头，发现参数Cookie:Login=0,于是尝试用python的request库伪造请求头的Cookie参数，使Login=1，然后访问网址，并打印响应内容，得到答案。123456789import requestsurl = "http://lab1.xseclab.com/base9_ab629d778e3a29540dfd60f2e548a5eb/index.php"headers = &#123;'Cookie':'Login=1'&#125;r = requests.get(url,headers=headers)#r = requests.post(url,data=&#123;'v':'111111'&#125;)# 请求获取URL位置的资源，包含从服务器返回的所有内容r.encoding = r.apparent_encodingr.encoding = 'utf-8'print(r.text) yescookieedit7823789KJ 第十关发现只能输入3位数字，而999依旧显示太小。F12查看源代码，发现标签属性中限制了输入长度。方法一直接F12在开发者工具里修改源代码，使之能够输入一个极大的数，直接得出答案。方法二用python提交不受标签限制1234567import requestsurl = "http://lab1.xseclab.com/base10_0b4e4866096913ac9c3a2272dde27215/index.php"r = requests.post(url,data=&#123;'v':'111111'&#125;)# 请求获取URL位置的资源，包含从服务器返回的所有内容r.encoding = r.apparent_encodingr.encoding = 'utf-8'print(r.text) 768HKyu678567&amp;*&amp;K 第十一关题目崩了，答案就直接放在源代码注释里了。 ^&amp;*(UIHKJjkadshf 第十二关没有思路，上网查攻略，发现与robots协议有关，虽然不知道是怎么想到的…… robots协议也叫robots.txt（统一小写）是一种存放于网站根目录下的ASCII编码的文本文件，它通常告诉网络搜索引擎的漫游器（又称网络蜘蛛），此网站中的哪些内容是不应被搜索引擎的漫游器获取的，哪些是可以被漫游器获取的。 既然如此，就直接访问./robots.txt,看到Disallow: /9fb97531fe95594603aff7e794ab2f5f/。于是访问该网址,得到提示说此页面不是登陆页面，继续搜索。一般来说登录页面就是在网址后面加/login.php，尝试，成功看到答案。 UIJ%%IOOqweqwsdf 结语至此，基础十二关便结束了。虽然总是在上网查攻略，但依旧乐趣不减，毕竟都是我没接触过的东西。感觉学到了不少东西，作为娱乐方式，还是很赚的。以后可能补上抓包工具的解法。]]></content>
      <categories>
        <category>计算机</category>
        <category>Hack</category>
      </categories>
      <tags>
        <tag>Hack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[最优停止理论——如何适“可”而止]]></title>
    <url>%2F%E6%9C%80%E4%BC%98%E5%81%9C%E6%AD%A2%E7%90%86%E8%AE%BA%E2%80%94%E2%80%94%E5%A6%82%E4%BD%95%E9%80%82%E2%80%9C%E5%8F%AF%E2%80%9D%E8%80%8C%E6%AD%A2.html</url>
    <content type="text"><![CDATA[摘要本文主要从最优停止问题出发，介绍了麦穗问题和经典的秘书问题以及面对此类问题采取的策略。本文还根据该策略推导并验证了37%法则的正确性，并且简单分析了该法则的适用性。 理论介绍中国有一句古话，叫做适可而止，其意思是到适当的程度就停下来，不要过头。生活中处处需要抉择判断，像是买衣服，挑选伴侣等，而这些问题都需要运用适可而止的思想，否则将确定最终选择，因为我们永远不知道最好的将什么时候出现。但是适可而止的“可”又是什么呢？当我们面对无穷无尽的选择时，有如何知道当前选择是否为“可”呢？在进入正文之前，先让我们听一个小故事。 传说中古希腊哲学大师苏格拉底的3个弟子曾求教老师，怎样才能找到理想的伴侣。于是苏格拉底带领弟子们来到一片麦田，让他们每人在麦田中选摘一支最大的麦穗，并且要求不能走回头路，且只能摘一支。 面对老师的要求，三个弟子分别做出了不同的举动。第一个弟子刚刚走了几步便迫不及待地摘了一支自认为是最大的麦穗，结果发现后面的大麦穗多的是；第二位一直左顾右盼，东瞧西望，直到终点才发现，前面最大的麦穗已经错过了；第三位弟子把麦田分为三份，走第一个1/3时，只看不摘，分出大、中、小三类麦穗，在第二个1/3里验证是否正确，在第三个1/3里选择了麦穗中最大最美丽的一支，这就是所谓的麦穗理论。 为什么第三位弟子能够获得比较满意的结果呢？因为他在选择的过程中采用了一定的策略，即将决策过程分为两段：前2/3的路程用于确定“最基本的满意标准”，最后1/3选择满足“最基本的满意标准”的第一个方案。这里的两段可以是把全部可选方案在数量上分成两段来考察，也可以是把选择时间分成两段。 麦穗理论实际上要解决的是一种“最优停止问题”。这种问题一般有两个特点：我们并不清楚我们会遇到什么样的可选方案，只有看过了才知道，即未来不可知，但一个可选方案一旦被错过了不能再回头去选，即不能反悔。生活中其实很多事情都是类似的问题，麦穗理论里的找到理想伴侣、买房子、换工作等等。 所以有一个观望的“最优停止”的时间点，也因此这类问题被称为“最优停止问题”。 秘书问题（Secretary problem）是最优停止问题中最著名的一类难题，在不同的地方它也被称作相亲问题、止步问题、见好就收问题、苏丹的嫁妆问题、挑剔的求婚者问题等。该问题的内容是这样的：假设你是面试官，要聘请一名秘书，一共有 n 个应聘者来面试。你按照随机顺序，每次面试一名申请人。你随时可以决定将这份工作交给其中一人，而对方只能接受，于是面试工作就此结束。但是，一旦你否决其中一名申请人，就不能改变主意再回头选择他。面试后总能清楚了解应聘者的合适程度，并能和之前的每个人做比较。问什么样的策略，才使最佳人选被选中的概率最大。 面对这类问题，Merrill M. Flood在1949年首次提出37%法则。他所采取的的策略类似于上述苏格拉底的第三位弟子的决策：首先对前面一部分面试者，无论优秀与否都直接拒绝，只考察目标，收集数据，用于确定“最基本的满意标准”。然后对剩下的人进行面试，如果遇到一位比之前面试的人都优秀的面试者，那么就立即出手，直接聘请这个人，否则就继续面试。 在麦穗问题中，那位弟子选择将前2/3的麦穗用于确定“最基本的满意标准”。但是这不一定是最优秀的决策。为了提高我们获得最优结果的概率的时候，我们需要找到最合适的样本量用于制定比较的标准。通过计算，Flood发现37%是一个最优停止点，也就是说选择前37%的人直接拒绝时，得到最适合担任秘书的人的概率最大。 理论证明那么37%是如何推导出来的呢？ 假设事件A_k为第 k 个人被选中，事件B_k为第 k 个人是最优秀的，事件C_r为前 r 名面试者用于确定标准时选到最优秀应聘者，其中1 \le r < k \le n,r \in Z, k \in Z。则选到最优秀的应聘者的概率： P(C_r)=\sum P(A_kB_k)=\sum\limits_{k=1}^{n} P(B_k)P(A_k|B_k)=\frac{1}{n}\sum\limits_{k=1}^{n} P(A_k|B_k)\qquad (1)因为前 r 个人必然会被拒绝，所以P(A_k|B_k)=0,k\le r 。又因为当第 k 个人被选择时，第 k个人前最优秀的人必然在前 r 个人当中，所以 P(A_k|B_k)=\frac{r}{k-1},k>r 。因此式（1）可化简为： P(C_r)=\frac{1}{n}\sum\limits_{k=r+1}^{n} P(A_k|B_k)=\frac{1}{n}\sum\limits_{k=r+1}^{n} \frac{r}{k-1}=\frac{r}{n}\sum\limits_{k=r+1}^{n} \frac{1}{k-1}\qquad (2)因为我们需要选出最优的决策，所以前 r 名面试者用于确定标准时选择到最优秀的应聘者的概率必须为最大，即P(C_{r-1})\le P(C_r)\ge P(C_{r+1})。 通过计算机程序枚举 n 为 1~10000 时，选取的 r 的值，并选取部分数据记录于下表。 n r \frac{r}{n} P(C_r) 3 1 0.333333 0.5 4 1 0.25 0.458333 5 2 0.4 0.433333 10 3 0.3 0.39869 100 37 0.37 0.371043 1000 368 0.368 0.368196 10000 3679 0.3679 0.3679 当 n 无限接近于\infty时，P(C_r) 变为积分形式，即式（2）变为： P(C_r)=\frac{r}{n}\sum\limits_{k=r+1}^{n} \frac{1}{k-1}\approx\frac{r}{n}\int\nolimits_{r}^{n-1} \frac{1}{x}dx=\frac{r}{n}\ln(\frac{n-1}{r})\approx\frac{r}{n}\ln(\frac{n}{r})\qquad (3)令函数f(r)=P(C_r) ，所以我们需要所求的r_0为f (r)的最大极值点，即f'(r_0)=0 ，此时可得r_0=\frac{n}{e}。已知\frac{1}{e}\approx 0.36788\approx 37%，因此计算结果符合要求。 验证代码123456789101112131415161718192021222324#include&lt;iostream&gt;#include&lt;stdio.h&gt;#define oo 1e9+7using namespace std;int main()&#123; freopen("test.txt","w",stdout); for(int i=1;i&lt;=10000;i++)&#123; double maxp=0,temp=0; int maxr=1; for(int j=1;j&lt;i;j++)temp+=1.0/j; for(int j=1;j&lt;=i;j++)&#123; double pj=1.0*j/i; pj*=temp; if(pj&gt;maxp)&#123; maxp=pj; maxr=j; &#125; temp-=1.0/j; &#125; cout&lt;&lt;i&lt;&lt;" "&lt;&lt;maxr&lt;&lt;" "&lt;&lt;1.0*maxr/i&lt;&lt;" "&lt;&lt;maxp&lt;&lt;endl; &#125; fclose(stdout); return 0;&#125; 结语37%法则还可以用于生活中有很多类似于秘书问题的问题，像是如何选择自己的伴侣，如何决定投资的项目，如何选择停车位等可化简为最优停止问题的问题。在所有最优停止问题中，最大的难点不在于选择哪一种可选方案，而是确定自己需要考虑多少种可选方案。 最优停止问题的权威教科书开宗明义地指出:“最优停止理论关注的是如何选择时机以执行特定行动的问题。”秘书问题最基本同时也最令人难以置信的前提条件——严格的连续性，即有进无退的单向行进，正好是时间自身属性的一个体现。生活中我们做出决定的时候，往往具有时间上的不可挽回性，你永远无法回到过去去重新做出选择，我们没有二次选择机会，如何适可而止，在合适的时间停止观察做出选择，这是非常重要的问题。 需要注意的是，37%法则选到的并不一定是最优方案，而是接近于最优的满意方案。还有的时候可能找到最优并不可能，或者代价极大。在这种情况下，我们要能接受“满意”。而且当最优的方案出现在前37%的时候，你会发现37%法则也无法找出满意的方案。因此在生活中，我们需要灵活的应用37%法则，结合自己的经验，寻找到那个令人满意的“可”之所在。 参考文献[1] 约翰尼斯·开普勒 算法之美：指导工作与生活的算法[2] 维基百科 秘书问题[3] 听风临山 生活中一定会用到的数学常识：37%法则]]></content>
      <categories>
        <category>杂</category>
      </categories>
      <tags>
        <tag>杂</tag>
        <tag>概率</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基于C++的最优化算法——遗传算法]]></title>
    <url>%2F%E5%9F%BA%E4%BA%8EC%2B%2B%E7%9A%84%E6%9C%80%E4%BC%98%E5%8C%96%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94%E9%81%97%E4%BC%A0%E7%AE%97%E6%B3%95.html</url>
    <content type="text"><![CDATA[要求基于抽象优化类 optimizer，编写自己的派生优化类，实现多元方程未知数计算 实现最优化算法有许多，像是模拟退火、遗传算法、粒子群算法等等，而我使用的是最优化算法中的遗传算法。 算法原理遗传算法是一类借鉴生物界的进化规律演化而来的随机化搜索方法。其主要特点是直接对结构对象进行操作，不存在求导和函数连续性的限定；具有内在的隐并行性和更好的全局寻优能力；采用概率化的寻优方法，能自动获取和指导优化的搜索空间，自适应地调整搜索方向，不需要确定的规则。 在理解遗传算法的基本原理之前，先了解一下几个概念： 个体：一个个体就是一组可能解。将可能解通过编码产生一组数组，即个体的染色体。 种群：个体的集合。 适应度：度量某个物种对于生存环境的适应程度。 选择：产生一代新的子种群后，基于个体的适应度对种群里的个体进行优胜劣汰。 交叉：以一定的概率将一对染色体的某一段基因进行交换。 变异：以一定的概率使染色体的某一基因发生改变。 于是我们对每一代父种群的染色体进行筛选、交叉和变异操作，产生下一代子种群。通过种群的不断遗传与淘汰，最终能够进化出最优解。在算法初始阶段，我们首先随机创建一个包含多个个体的种群，然后对于这个种群，循环进行以下操作，直到完成设置的进化次数： 评估每条染色体所对应个体的适应度。 遵照适应度越高，选择概率越大的原则，从种群中选择两个个体作为父方和母方。 抽取父母双方的染色体，进行交叉，产生子代。 对子代的染色体进行变异。 我讲的还是比较简略的，详情请见这篇博客 代码编码：这份代码中以一组x解为一个个体。 选择函数：轮盘度选择 轮盘赌选择（Roulette Wheel Selection）：是一种回放式随机采样方法。每个个体进入下一代的概率等于它的适应度值与整个种群中个体适应度值和的比例。选择误差较大。 交叉方式：单点交叉 单点交叉（One-point Crossover）：指在个体编码串中只随机设置一个交叉点，然后再该点相互交换两个配对个体的部分染色体。 变异方式：基因以一定概率在±Xrn的领域内浮动，Xrn以类似退火的方式减小。 个体类头文件123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172#ifndef _SI_H#define _SI_H#include "string"#include "opt1.h"#include "stdlib.h"#include "time.h"#define Xr 3.0f#define Xl -3.0f//答案范围using namespace std;/** * 个体类 */static int cnt=0;//模板函数，用于生成各种区间上的数据类型template&lt;typename T&gt;T randT(T Lower, T Upper)&#123; return rand() / (double)RAND_MAX *(Upper - Lower) + Lower;&#125;class SpeciesIndividual&#123;public: double *genes;//基因序列 double error;//误差 double fitness;//适应度 double rate; int xnum; //构造函数 SpeciesIndividual()&#123;&#125; SpeciesIndividual(int xd)&#123; xnum=xd; genes=new double[xnum]; fitness=0.0f; error=0.0f; rate=0.0f; createByRandomGenes(); &#125; ~SpeciesIndividual()&#123; delete[] genes; &#125; //初始物种基因（随机） 基因直接用x序列编码 void createByRandomGenes()&#123; for(int i=0;i&lt;xnum;i++)&#123; genes[i]=randT(Xl,Xr); &#125; &#125; //void createByGreedyGenes();//初始物种基因（贪心） SpeciesIndividual &amp;operator = (SpeciesIndividual const &amp;species)&#123; xnum=species.xnum; double *genestmp=new double[species.xnum]; for(int i=0;i&lt;xnum;i++)&#123; genestmp[i]=species.genes[i]; &#125; error=species.error; fitness=species.fitness; rate=species.rate; delete[] genes; genes=genestmp; return *this; &#125; bool operator == (SpeciesIndividual const &amp;species)&#123; for(int i=0;i&lt;xnum;i++) if(genes[i]!=species.genes[i])return false; return true; &#125;&#125;;#endif 优化程序123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195#ifndef _OPT_1_H#define _OPT_1_H#include "optimizer.h"#include "SpeciesIndividual.h"#include "stdlib.h"#include "time.h"#include "math.h"#include "iostream"#include "algorithm"#define DEVELOP_NUM 3000//进化次数#define pcl 0.6f#define pch 0.95f//交叉概率#define pm 0.1f//变异概率#define oo 1e9+7#define delta 0.98#define SPECIES_MAXNUM 500//种群最大数量#define SPECIES_NUM 80 //种群数量using namespace std;SpeciesIndividual population[SPECIES_MAXNUM];//父种群SpeciesIndividual subPopulation[SPECIES_MAXNUM];//子种群int speciesNum=0;//父种群个体数量int subSpeciesNum=0;//子种群个体数量double Temp=1;/** * 遗传算法 * 包含： * 1.run 开始跑算法 * 2.createBeginningSpecies 创建种群 * 3.calRate 计算每一种物种被选中的概率 * 4.select 轮盘策略 选择适应度高的物种 * 5.crossover 染色体交叉 * 6.mutate 染色体变异 * 7.getBest 获得适应度最大的物种 */class opt1: public optimizer&#123;public: template&lt;typename T&gt; void Swap(T &amp;a,T &amp;b)&#123; T tmp=a; a=b; b=tmp; &#125; SpeciesIndividual getBest()&#123; double error=oo; SpeciesIndividual bestSpecies(xd); for(int i=0;i&lt;speciesNum;i++)&#123; if(error&gt;population[i].error)&#123; bestSpecies=population[i]; error=bestSpecies.error; &#125; &#125; return bestSpecies; &#125; //创建初始种群 void createBeginningSpecies()&#123; int randNum=SPECIES_NUM; speciesNum=0; for(int i=0;i&lt;randNum;i++)&#123; SpeciesIndividual species(xd); population[speciesNum++]=species; &#125; &#125; //计算每一物种被选中的概率 void calcRate()&#123; //计算总误差 double totalERR=0.0f; for(int i=0;i&lt;speciesNum;i++)&#123; population[i].error=fun(population[i].genes,y);//计算误差 totalERR+=population[i].error; &#125; //计算总适应度 double totalfitness=0.0f; for(int i=0;i&lt;speciesNum;i++)&#123; population[i].fitness=totalERR/population[i].error;//计算适应度 totalfitness+=population[i].fitness; &#125; //计算选中概率 for(int i=0;i&lt;speciesNum;i++)&#123; population[i].rate=population[i].fitness/totalfitness; &#125; &#125; //选择优秀物种（轮盘赌） void select()&#123; //找出最大适应度物种 SpeciesIndividual talentSpecies=getBest(); //将最大适应度物种复制talentNum个 int talentNum=(int)(speciesNum/4)+1; for(int i=0;i&lt;talentNum;i++)&#123; //复制物种至子种群中 subPopulation[subSpeciesNum++]=talentSpecies; &#125; //轮盘赌list.speciesNum-talentNum次 int randNum=speciesNum-talentNum; for(int i=0;i&lt;randNum;i++)&#123; double rate=randT(0.0,1.0); for(int j=0;j&lt;speciesNum;j++)&#123; //如果不是最后一个，那么遇到最优个体或者指针没在该区域停下 if((rate-population[j].rate&gt;0||population[j]==talentSpecies)&amp;&amp;j!=speciesNum-1)&#123; rate=rate-population[j].rate; &#125; else&#123; subPopulation[subSpeciesNum++]=population[j]; break; &#125; &#125; &#125; //子代成长为父种群 for(int i=0;i&lt;subSpeciesNum;i++)&#123; population[i]=subPopulation[i]; &#125; speciesNum=subSpeciesNum; subSpeciesNum=0; &#125; void crossover()&#123; //两两配对 for(int i=0;i&lt;speciesNum;i+=2)&#123; if(i+1==speciesNum)break;//若个体数量为奇数，则最后一个个体为单身 //以概率pcl~pch进行 double rate=randT(0.0,1.0); if(rate&gt;pcl&amp;&amp;rate&lt;pch)&#123; //单点交叉 int begin=rand()%xd; //取第i个个体和第i+1个个体进行交叉，形成新的两个染色体 for(int j=begin;j&lt;xd;j++)&#123; Swap(population[i].genes[j],population[i+1].genes[j]); &#125; &#125; &#125; &#125; void mutate()&#123; //每一物种都有变异的机会，以概率pm进行 for(int i=0;i&lt;speciesNum;i++)&#123; for(int j=0;j&lt;xd;j++)&#123; double rate=randT(0.0,1.0); if(rate&lt;pm)&#123; //基因变异在±Xrn的领域内浮动。 double x=population[i].genes[j]; population[i].genes[j]+=randT(Xl/exp(Temp),Xr/exp(Temp)); &#125; &#125; &#125; &#125; double setOptimizer(double (*foo)(double *,double *),double *x1,double *y1,int xd1,int yd1) &#123; fun=foo; x=x1; y=y1; xd=xd1; yd=yd1; //随机种子 srand(time(NULL)); //开始遗传算法（选择算子、交叉算子、变异算子） //创建初始种群 createBeginningSpecies(); for(int i=0;i&lt;DEVELOP_NUM;i++)&#123; //计算适应度 calcRate(); //目前最优解 SpeciesIndividual bestAns=getBest(); if(fun(x1,y)&gt;fun(bestAns.genes,y))&#123; for(int i=0;i&lt;xd;i++)&#123; x1[i]=bestAns.genes[i]; &#125; &#125; //选择 select(); //交叉 crossover(); //变异 mutate(); //缩小基因变异的范围 Temp+=0.01; &#125; calcRate(); return fun(x1,y); &#125;;&#125;;#endif 测试代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include &lt;iostream&gt;#include "opt1.h"using namespace std;class Matrix_4x4&#123;public: int **mat; Matrix_4x4()&#123;&#125;; Matrix_4x4(int (&amp;a)[4][4])&#123; mat=new int *[4]; for(int i=0;i&lt;4;i++)&#123; mat[i]= new int[4]; for(int j=0;j&lt;4;j++)&#123; mat[i][j]=a[i][j]; &#125; &#125; &#125; ~Matrix_4x4() &#123; for (int i=0;i&lt;4;i++) &#123; delete[] mat[i]; mat[i]=NULL; &#125; delete[] mat; &#125; int* operator[](int idx) &#123; return mat[idx]; &#125;&#125;;double f1(double *x,double *y)&#123; int index=4; int m[4][4]=&#123;&#123;1,2,3,4&#125;,&#123;2,4,7,5&#125;,&#123;6,7,3,2&#125;,&#123;1,8,4,2&#125;&#125;; Matrix_4x4 A(m); //计算误差 double temp[4]=&#123;0&#125;; double err=0; for(int i=0;i&lt;index;i++)&#123; for(int j=0;j&lt;index;j++)&#123; temp[i]+=1.0*A[i][j]*x[j]; &#125; err+=(y[i]-temp[i])*(y[i]-temp[i]); &#125; //for(int i=0;i&lt;4;i++)cout&lt;&lt;x[i]&lt;&lt;" "; //cout&lt;&lt;endl; //cout&lt;&lt;err&lt;&lt;endl; return err;&#125;int main()&#123; double x[4]=&#123;&#125;; double y[4]=&#123;6,4,3,8&#125;; opt1 opti; optimizer *opt=&amp;opti; cout&lt;&lt;"The error is : "&lt;&lt;opt-&gt;setOptimizer(f1,x,y,4,4)&lt;&lt;endl; cout&lt;&lt;endl&lt;&lt;"The result is : "&lt;&lt;endl; for(int i=0;i&lt;4;i++)cout&lt;&lt;x[i]&lt;&lt;endl; return 0;&#125; 运行结果 结语通过本次实验，让我很好地了解了几种最优化算法，并且深入了解了其中的遗传算法。实验过程中，我在如何提升结果精度上花费一些功夫，并且最终借鉴模拟退火中的一些思路，将结果优化至满意的结果。]]></content>
      <categories>
        <category>计算机</category>
        <category>程序</category>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>最优化算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基于C++的计算不同图形面积]]></title>
    <url>%2F%E5%9F%BA%E4%BA%8EC%2B%2B%E7%9A%84%E8%AE%A1%E7%AE%97%E4%B8%8D%E5%90%8C%E5%9B%BE%E5%BD%A2%E9%9D%A2%E7%A7%AF.html</url>
    <content type="text"><![CDATA[要求 定义抽象基类Shape，由它派生出5个派生类：Circle、Square、Rectangle、Trapezoid、Triangle。用虚函数分别计算多个不同类图形的面积，并求它们的面积和。 要求用基类指针数组，使它的每一个元素指向一个派生类的对象，使用一个循环完成对多个图像的面积计算与求和。 图型的数据在定义对象时给定 定义顶点Point类，并在5个派生类中使用 圆以圆心坐标，半径的方式给定，其余以顶点坐标的方式给定 各个派生类的构造函数中应判断给定顶点组合是否满足图形属性 知识点 类的继承与派生 虚函数的使用 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231#include &lt;iostream&gt;#include &lt;math.h&gt;#include &lt;stdlib.h&gt;#define pi 3.1415926#define eps 1e-6using namespace std;//点类class Point&#123;public: double x,y; Point()&#123;&#125;; Point(double x,double y):x(x),y(y)&#123;&#125;; Point &amp;operator=(const Point &amp;p)&#123; x=p.x; y=p.y; return *this; &#125;&#125;;//基类class Shape&#123;public: Point *p; virtual double Area()=0;//求面积 bool check_angle90(Point a,Point b,Point c)&#123;//判断是否垂直 return fabs((a.x-c.x)*(b.x-c.x)+(b.y-c.y)*(a.y-c.y))&lt;=eps; &#125; bool check_Parallel(Point a,Point b,Point c,Point d)&#123;//判断是否平行 return fabs((a.x-b.x)*(c.y-d.y)-(a.y-b.y)*(c.x-d.x))&lt;=eps; &#125; double dis2(Point a,Point b)&#123;//求两点间距离 return pow(a.x-b.x,2)+pow(a.y-b.y,2); &#125; void Swap(Point &amp;x,Point &amp;y)&#123;//交换两点 Point temp; temp=x; x=y; y=temp; &#125;&#125;;//派生类：圆形class Circle: public Shape&#123;public: double r; Circle(Point point,double radius)&#123; if(r&lt;=0)&#123; cout&lt;&lt;"Wrong parameter"&lt;&lt;endl; &#125; p=new Point(point); r=radius; &#125; ~Circle()&#123; delete p; &#125; double Area()&#123; return r*r*pi; &#125;&#125;;//派生类：矩阵class Rectangle: public Shape&#123;public: double width,height; bool check(Point point[],bool isSquare)&#123;//判断是否是矩形或者正方形 int k=0; while(k&lt;3)&#123;//找到一个直角 if(check_angle90(point[0],point[1],point[2]))break; Swap(point[k],point[3]); k++; &#125; if(k==3)return false; Swap(point[1],point[2]); double edge2[4]; for(int i=0;i&lt;4;i++)&#123; edge2[i]=dis2(point[i],point[(i+1)%4]); &#125; //矩形两对边相等，正方形四边相等 if(isSquare)return fabs(edge2[0]-edge2[2])&lt;=eps&amp;&amp;fabs(edge2[1]-edge2[3])&lt;=eps&amp;&amp;fabs(edge2[0]-edge2[1])&lt;=eps; else return fabs(edge2[0]-edge2[2])&lt;=eps&amp;&amp;fabs(edge2[1]-edge2[3])&lt;=eps; &#125; double Area()&#123; return width*height; &#125; Rectangle()&#123;&#125;; Rectangle(Point point[])&#123; if(!check(point,0))&#123; cout&lt;&lt;"Wrong parameter"&lt;&lt;endl; return; &#125; p=new Point[4]; for(int i=0;i&lt;4;i++)&#123; p[i]=point[i]; &#125; width=sqrt(dis2(point[0],point[1])); height=sqrt(dis2(point[0],point[3])); &#125; ~Rectangle()&#123; delete[] p; &#125;&#125;;//派生类：正方形class Square: public Rectangle&#123;public: double edge; Square(Point point[])&#123; if(!check(point,1))&#123; cout&lt;&lt;"Wrong parameter"&lt;&lt;endl; return; &#125; p=new Point[4]; for(int i=0;i&lt;4;i++)&#123; p[i]=point[i]; &#125; edge=sqrt(dis2(point[0],point[1])); &#125; ~Square()&#123; delete[] p; &#125; double Area()&#123; return edge*edge; &#125;&#125;;//派生类：三角形class Triangle: public Shape&#123;public: double edge[3]; bool check(Point point[])&#123;//三角形只要判断是否有零边 for(int i=0;i&lt;3;i++)&#123; edge[i]=sqrt(dis2(point[i],point[(i+1)%3])); &#125; return edge[0]&gt;eps&amp;&amp;edge[1]&gt;eps&amp;&amp;edge[2]&gt;eps; &#125; double Area()&#123;//海伦公式 double aver=(edge[0]+edge[1]+edge[2])/2; return sqrt(aver*(aver-edge[0])*(aver-edge[1])*(aver-edge[2])); &#125; Triangle(Point point[])&#123; if(!check(point))&#123; cout&lt;&lt;"Wrong parameter"&lt;&lt;endl; &#125; p=new Point[3]; for(int i=0;i&lt;3;i++)&#123; p[i]=point[i]; &#125; &#125; ~Triangle()&#123; delete[] p; &#125;&#125;;class Trapezoid: public Shape&#123;public: bool check(Point point[])&#123; int i=0; while(i&lt;3)&#123;//找平行的一对边，为上下底 if(check_Parallel(point[0],point[1],point[2],point[3]))break; Swap(point[i],point[3]); i++; &#125; if(i==3)return false; //找高，且高不为零 double y0=point[0].y-point[1].y,x0=point[0].x-point[1].x; if(fabs(x0)&lt;=eps)height=fabs(point[0].x-point[2].x); else &#123; double k=y0/x0; double b1=point[0].y-k*point[0].x; double b2=point[2].y-k*point[2].x; height=fabs(b1-b2)/sqrt(1+k*k); &#125; return height&gt;eps; &#125; double Area()&#123; return (topline+baseline)*height/2; &#125; double height,topline,baseline; Trapezoid(Point point[])&#123; if(!check(point))&#123; cout&lt;&lt;"Wrong parameter"&lt;&lt;endl; &#125; p=new Point[4]; for(int i=0;i&lt;4;i++)&#123; p[i]=point[i]; &#125; topline=sqrt(dis2(point[0],point[1])); baseline=sqrt(dis2(point[2],point[3])); &#125; ~Trapezoid()&#123; delete[] p; &#125;&#125;;int main()&#123; Shape *p[5]; //圆心和半径 Point circlePoint(0.0,0.0); double radius=5.5; //长方形 Point rectVertex[4]=&#123;&#123;0.0,0.0&#125;,&#123;1.0,0.0&#125;,&#123;1.0,2.0&#125;,&#123;0.0,2.0&#125;&#125;; //正方形 Point squVertex[4]=&#123;&#123;0.0,0.0&#125;,&#123;4.8,3.6&#125;,&#123;1.2,8.4&#125;,&#123;-3.6,4.8&#125;&#125;; //三角形 Point triVertex[3]=&#123;&#123;0.0,0.0&#125;,&#123;4.6,8.9&#125;,&#123;-4.3,4.2&#125;&#125;; //梯形 Point traVertex[4]=&#123;&#123;0.0,0.0&#125;,&#123;5.0,0.0&#125;,&#123;1.0,7.0&#125;,&#123;9.0,7.0&#125;&#125;; //Circle cir() Circle cir(circlePoint,radius); Rectangle rect(rectVertex); Square squ(squVertex); Triangle tri(triVertex); Trapezoid tra(traVertex); //调用各种派生类 p[0]=&amp;cir; p[1]=&amp;rect; p[2]=&amp;squ; p[3]=&amp;tri; p[4]=&amp;tra; double sumArea=0; for(int i=0;i&lt;4;i++)&#123; sumArea+=p[i]-&gt;Area(); &#125; cout &lt;&lt; sumArea &lt;&lt; endl; return 0;&#125; 运行结果 结语本次实验的重点在于类之间的继承和组合，以及对于纯虚函数的应用和类的成员函数的重复利用。花在这份代码的时间其实大部分在构思如何判断形状。]]></content>
      <categories>
        <category>计算机</category>
        <category>程序</category>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基于C++的矩阵类的编写]]></title>
    <url>%2F%E5%9F%BA%E4%BA%8EC%2B%2B%E7%9A%84%E7%9F%A9%E9%98%B5%E7%B1%BB%E7%9A%84%E7%BC%96%E5%86%99.html</url>
    <content type="text"><![CDATA[要求本次实验是编写矩阵类 Matrix_4x4，使类满足以下要求： 矩阵为 4*4，数据类型为 double 默认构造函数，初始化矩阵为单位阵 拷贝构造函数 带参数构造函数，可以用一个 4x4 的二维数组初始化 重载 加(+)，减(-)，乘(*)，幂次(^) ，输入，输出 等操作 重载 = 操作，可以实现矩阵间赋值，或者二维数组向矩阵赋值 重载( ), 实现矩阵元素访问, 例如矩阵类的对象 m 可以实现 m(1, 2)=2; 实现求逆功能，转置功能，求行列式功能 知识点 构造函数 运算符重载 友元函数的使用 实现矩阵求逆和求行列式的原理矩阵求逆：通过高斯-若尔当消元法，通过初等行变换将矩阵 A 化为单位矩阵 E，将矩阵 E 化为 A^(-1)。对于每一行，首先判断对角方向的元素是否为 0，然后将对角位置转换为 1，接着将该列非对角位置转换为 0。最终可得矩阵 A 的逆矩阵 行列式运算：使用高斯消去法，通过对矩阵 A 的一系列行变换，使之成为上三角形矩阵，其主对角线上诸元素乘积即为行列式之值。判断每列的最大元素，通过交换行放到主对角线，然后根据 $A[j][k] = A[j][k] - A[i][k] * A[j][i] / A[i][i]$，将每一列下三角转化为 0，最终可得一个上三角行列式。 代码头文件123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192#ifndef MATRIX_H#define MATRIX_H#include &lt;iostream&gt;using namespace std;double matE[4][4]=&#123;&#123;1,0,0,0&#125;, &#123;0,1,0,0&#125;, &#123;0,0,1,0&#125;, &#123;0,0,0,1&#125;&#125;;//单位矩阵class Matrix&#123;private: double mat[4][4];public: Matrix()&#123; for(int i=0;i&lt;4;i++)&#123; for(int j=0;j&lt;4;j++)&#123; mat[i][j]=0; &#125; &#125; &#125;;//默认构造函数，零矩阵 Matrix(const Matrix &amp;m)&#123; for(int i=0;i&lt;4;i++)&#123; for(int j=0;j&lt;4;j++)&#123; mat[i][j]=m.mat[i][j]; &#125; &#125; &#125;;//拷贝构造函数，拷贝同类对象 Matrix(double (&amp;m)[4][4])&#123; for(int i=0;i&lt;4;i++)&#123; for(int j=0;j&lt;4;j++)&#123; mat[i][j]=m[i][j]; &#125; &#125; &#125;;//拷贝构造函数，拷贝二维数组 Matrix operator+(const Matrix &amp;m)&#123; Matrix ansM; for(int i=0;i&lt;4;i++)&#123; for(int j=0;j&lt;4;j++)&#123; ansM.mat[i][j]=mat[i][j]+m.mat[i][j]; &#125; &#125; return ansM; &#125;;//重载加法运算 Matrix operator-(const Matrix &amp;m)&#123; Matrix ansM; for(int i=0;i&lt;4;i++)&#123; for(int j=0;j&lt;4;j++)&#123; ansM.mat[i][j]=mat[i][j]-m.mat[i][j]; &#125; &#125; return ansM; &#125;;//重载减法运算 Matrix operator*(const Matrix &amp;m)&#123; Matrix ansM; for(int i=0;i&lt;4;i++)&#123; for(int j=0;j&lt;4;j++)&#123; for(int k=0;k&lt;4;k++)&#123; ansM.mat[i][j]+=mat[i][k]*m.mat[k][j]; &#125; &#125; &#125; return ansM; &#125;;//重载乘法运算 Matrix operator^(int n)&#123; Matrix ansM(matE); bool ifInverse=false; if(n&lt;0)&#123; n=-n; ifInverse=true; &#125; for(int k=0;k&lt;n;k++)&#123; ansM=ansM*(*this); &#125; if(ifInverse)ansM=ansM.Inverse(); return ansM; &#125;;//重载幂运算 const Matrix &amp;operator=(const Matrix &amp;m)&#123; for(int i=0;i&lt;4;i++)&#123; for(int j=0;j&lt;4;j++)&#123; mat[i][j]=m.mat[i][j]; &#125; &#125; return *this; &#125;;//重载赋值运算 const double &amp;operator()(int i,int j)&#123; if(i&lt;0||j&lt;0||i&gt;=4||j&gt;=4)&#123; cout&lt;&lt;"Wrong index!"&lt;&lt;endl; &#125; return mat[i][j]; &#125;;//重载取值运算 friend istream &amp; operator&gt;&gt;(istream &amp;is,Matrix &amp;m);//友元，重载输入 friend ostream &amp; operator&lt;&lt;(ostream &amp;os,const Matrix &amp;m);//友元，重载输出 void Swap(double &amp;a,double &amp;b)&#123; double tmp=a; a=b; b=tmp; &#125;//交换两个double变量 void SwapRow(int a,int b)&#123; for(int i=0;i&lt;4;i++)&#123; Swap(mat[a][i],mat[b][i]); &#125; &#125;//交换矩阵的两行 void LineMultiK(int a,double k)&#123; for(int i=0;i&lt;4;i++)mat[a][i]*=k; &#125; Matrix Inverse()&#123; Matrix tmpM(mat); Matrix E(matE); //首先将tmpM转换为上三角矩阵 for(int i=0;i&lt;4;i++)&#123; //判断对角方向的元素是否为0 int j=i; while(mat[i][j]==0&amp;&amp;j&lt;4)j++; if(j==4)&#123; cout&lt;&lt;"this matrix has no inverse!"&lt;&lt;endl; return *this; &#125; else if(i!=j)tmpM.SwapRow(i,j),E.SwapRow(i,j); //将对角位置转换为1 E.LineMultiK(i,1.0/tmpM(i,i)); tmpM.LineMultiK(i,1.0/tmpM(i,i)); //将该列非对角位置转换为0 for(int k=0;k&lt;4;k++)&#123; if(k==i)continue; for(int t=i+1;t&lt;4;t++)&#123; tmpM.mat[k][t]-=tmpM(i,t)*tmpM(k,i); &#125; for(int t=0;t&lt;4;t++)&#123; E.mat[k][t]-=E(i,t)*tmpM(k,i); &#125; tmpM.mat[k][i]=0; &#125; &#125; return E; &#125;//矩阵求逆 Matrix Transpose()&#123; Matrix ansM; for(int i=0;i&lt;4;i++)&#123; for(int j=0;j&lt;4;j++)&#123; ansM.mat[i][j]=mat[j][i]; &#125; &#125; return ansM; &#125;//矩阵转置 Matrix Determinant()&#123; Matrix ansM(mat); for(int i=0;i&lt;4;i++)&#123; //判断每列的最大元素，通过交换行放到主对角线 int maxi=i; for(int j=i;j&lt;4;j++)&#123; if(ansM(maxi,i)&lt;ansM(j,i))maxi=j; &#125; if(i!=maxi)ansM.SwapRow(i,maxi); if(ansM.mat[i][i]==0)continue; //根据A[j][k] = A[j][k] - A[i][k] * A[j][i] / A[i][i]，将每一列下三角转化为0 for(int k=i+1;k&lt;4;k++)&#123; for(int t=i+1;t&lt;4;t++)&#123; ansM.mat[k][t]-=ansM(i,t)*ansM(k,i)/ansM(i,i); &#125; ansM.mat[k][i]=0; &#125; &#125; return ansM; &#125;//行列式化简&#125;;istream &amp; operator&gt;&gt;(istream &amp;is,Matrix &amp;m)&#123; for(int i=0;i&lt;4;i++)&#123; for(int j=0;j&lt;4;j++)&#123; is&gt;&gt;m.mat[i][j]; &#125; &#125; return is;&#125;;//重载输入流ostream &amp; operator&lt;&lt;(ostream &amp;os,const Matrix &amp;m)&#123; for(int i=0;i&lt;4;i++)&#123; for(int j=0;j&lt;4;j++)&#123; os&lt;&lt;m.mat[i][j]&lt;&lt;" "; &#125; os&lt;&lt;endl; &#125; cout&lt;&lt;endl; return os;&#125;;//重载输出流#endif // MATRIX_H 测试代码123456789101112131415161718192021#include &lt;iostream&gt;#include "matrix.h"using namespace std;int main()&#123; Matrix a; cin&gt;&gt;a; cout&lt;&lt;"a="&lt;&lt;endl&lt;&lt;a; Matrix b(a^3); cout&lt;&lt;"a^3="&lt;&lt;endl&lt;&lt;b; Matrix c=a^-2; cout&lt;&lt;"a^-2="&lt;&lt;endl&lt;&lt;c; cout&lt;&lt;"a^T="&lt;&lt;endl&lt;&lt;a.Transpose(); cout&lt;&lt;a.Determinant(); return 0;&#125; 运行结果 结语本次实验的重点在于运算符的重载、友元函数的使用和二维数组构造函数。写这份代码的时候时间更多的是花在矩阵的求逆和求行列式上，其他倒还好。重载输入输出流运算符时，普通的方法需要将cin与cout放在运算符的右边，不符合代码编写习惯。通过友元函数，可以自由定义cin和cout与输入对象的相对位置，改成符合编写习惯的代码。]]></content>
      <categories>
        <category>计算机</category>
        <category>程序</category>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基于C++的vector类的编写]]></title>
    <url>%2F%E5%9F%BA%E4%BA%8EC%2B%2B%E7%9A%84vector%E7%B1%BB%E7%9A%84%E7%BC%96%E5%86%99.html</url>
    <content type="text"><![CDATA[要求编写vector类，实现动态的建立，插入，删除等功能。 知识点 构造函数 定义对象时调用该函数，可以定义许多个不同的构造函数 析构函数 释放对象时调用该函数，只有一个 类模板 1template&lt;class T&gt; 重载运算符 const修饰词的运用 头文件的编写 实现方法在实验过程中，如何实现动态分配空间是最重要的点。为了使得分配的内存空间连续，我首先给对象分配一个固定长度的连续空间，一旦插入元素的个数大于容量，需要对数组进行扩容，即重新分配空间，都会将当前容量扩充至原先的两倍，实现动态数组的功能。 代码头文件123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151#ifndef VECTOR_SS_H#define VECTOR_SS_H#include &lt;iostream&gt;using namespace std;template&lt;class T&gt;class vector_ss&#123;private: int v_size;//元素个数 int capacity;//容量 T* buf;public: vector_ss()&#123; v_size=0; capacity=1; buf=new T; &#125;;//默认构造函数 vector_ss(int n)&#123; v_size=n; capacity=n; buf=new T[n]; &#125;;//构造函数，数组初始大小为n vector_ss(int n,T t)&#123; v_size=n; capacity=n; buf=new T[n]; for(int i=0;i&lt;n;i++)buf[i]=t; &#125;;//构造函数，数组初始大小为n，且元素均为t vector_ss(const vector_ss &amp;v)&#123; v_size=v.size(); capacity=v.capacity; buf=new T[capacity]; for(int i=0;i&lt;v_size;i++) buf[i]=v.buf[i]; &#125;;//拷贝构造函数 vector_ss(const vector_ss &amp;v,int start,int end)&#123; capacity=v.capacity; v_size=end-start+1; buf=new T[capacity]; for(int i=0;i&lt;v_size;i++) buf[i]=v.buf[start+i]; &#125;; //拷贝构造函数，数组元素为v的start位置到end位置 ~vector_ss()&#123; if(buf)&#123; delete[] buf; &#125; &#125;;//析构函数 void resize(int newCapacity)&#123; T* buftmp=new T[newCapacity]; for(int i=0;i&lt;v_size;i++)buftmp[i]=buf[i]; delete[] buf; buf=buftmp; capacity=newCapacity; &#125; void push_back(T t)&#123; if(v_size&gt;=capacity) resize(capacity*2); buf[v_size++]=t; &#125;;//数组末尾插入元素 T pop_back()&#123; if(v_size)&#123; return buf[v_size--]; &#125; &#125;;//删除并返回末尾元素 T front()&#123; if(v_size)&#123; return buf[0]; &#125; &#125;;//返回数组首元素 void clear()&#123; delete[] buf; buf=new T; capacity=1; v_size=0; &#125;;//清空数组 bool empty()&#123; return v_size?1:0; &#125;;//判断数组是否为空 void insert(int pos,T data)&#123; if(pos&gt;=v_size||pos&lt;0)&#123;//报错 cout&lt;&lt;"Wrong parameter!"&lt;&lt;endl; return ; &#125; if(v_size&gt;=capacity) resize(capacity*2); for(int i=v_size-1;i&gt;pos;i--) buf[i]=buf[i-1]; buf[pos]=data; v_size++; &#125;;//在数组的第pos个位置插入数据data void erase(int pos)&#123; if(pos&gt;=v_size||pos&lt;0)&#123;//报错 cout&lt;&lt;"Wrong parameter!"&lt;&lt;endl; return ; &#125; for(int i=pos;i&lt;v_size-1;i++) buf[i]=buf[i+1]; v_size--; &#125;;//删除pos位置的数据 void erase(int begin,int end)&#123; if(begin&gt;=v_size||end&lt;0||begin&gt;end)&#123;//报错 cout&lt;&lt;"Wrong parameter!"&lt;&lt;endl; return ; &#125; for(int i=0;i+end&lt;v_size;i++) buf[begin+i]=buf[end+i]; v_size-=end-begin+1; &#125;;//删除从begin位置到end位置的数据 const int &amp;size() const &#123;return v_size;&#125;;//返回当前数组元素个数 const vector_ss&amp; operator=(const vector_ss &amp;v)&#123; T* buftmp=new T[v.capacity]; v_size=v.size(); capacity=v.capacity; for(int i=0;i&lt;v_size;i++)buftmp[i]=v.buf[i]; delete[] buf; buf=buftmp; return *this; &#125;;//重载=运算符 T&amp; operator[](int n)&#123; if(n&lt;v_size&amp;&amp;n&gt;=0)&#123; return buf[n]; &#125; else cout&lt;&lt;"Wrong parameter!"&lt;&lt;endl; &#125;;//重载下标运算符 const T&amp; operator[](int n) const&#123; if(n&lt;v_size&amp;&amp;n&gt;=0)&#123; return buf[n]; &#125; else cout&lt;&lt;"Wrong parameter!"&lt;&lt;endl; &#125; void display()&#123; for(int i=0;i&lt;v_size;i++) cout&lt;&lt;buf[i]&lt;&lt;" "; cout&lt;&lt;endl; &#125;;//打印数组元素&#125;;#endif // VECTOR_SS_H 测试代码12345678910111213141516171819202122232425262728293031323334353637#include &lt;iostream&gt;#include "vector_ss.h"using namespace std;int main()&#123; vector_ss&lt;char&gt; v1; cout&lt;&lt;v1.size()&lt;&lt;endl; for(int i=0;i&lt;10;i++) v1.push_back('a'+i); v1.display(); vector_ss&lt;char&gt; v2(v1,2,5); v2.display(); v1.erase(2,4); for(int i=0;i&lt;v1.size();i++) cout&lt;&lt;v1[i]&lt;&lt;" "; cout&lt;&lt;endl; v1.insert(2,'c'); v1.display(); v1.clear(); v1.display(); cout&lt;&lt;v1.size()&lt;&lt;endl; vector_ss&lt;char&gt;v3; v3=v2; v3.display(); vector_ss&lt;double&gt;v4(5,5); v4.display(); return 0;&#125; 运行结果 Q&amp;A 为什么要重载赋值运算符？ 答：不重载赋值运算符直接赋值的话，要赋值的对象将简单拷贝原对象中的所有成员值。如果类成员中有指针变量，那么仅仅拷贝的是指针地址值，而非指针指向值。这样的做容易造成内存的二次释放，造成严重的错误。因此需要重载赋值运算符 重载时需要注意哪些问题？ 答：返回值的时候要返回引用，可以避免不必要的内存开销。 为什么要有返回值？ 答：可以允许连续赋值。 如果出现类似于执行a=a的情况，代码应如何处理保证操作正确。 答：首先开辟一个新的动态空间，容量capacity与原对象相同，且将原对象中的数组值拷贝到新的动态空间中。然后释放当前对象的动态空间，并将数组指针指向刚刚开辟的新的动态空间首地址。 说明重载下标操作[ ]的两个函数的异同，以及应用场景？ 答：T&amp; operator返回第n个数组元素，允许通过返回的函数值修改所访问的数据。 const T&amp; operator const以常引用的方式返回第n个数组元素，返回的成员只读，不允许通过返回的函数值修改所访问的数据。一般不希望元素被修改的时候使用。 针对自己的代码，考察插入和删除元素时的运行效率问题，动态分配空间的频率，以及可以如何提升效率？ 答：插入元素时，需要n-pos+1次赋值，故时间复杂度为O(n)，其中在末尾插入时间复杂度是O(1)。但是一旦插入元素的个数大于容量，需要对数组进行扩容，即重新分配空间，该操作是O(n)的。 删除元素时，需要n-pos次赋值，故时间复杂度也为O(n)，其中在末尾删除的时间复杂度为O(1)。删除元素的函数中没有释放多余空间，仅仅在清空函数中有释放所有空间的函数。 所以由于每次当动态数组容量满了，都会将当前容量扩充至原先的两倍，所以动态分配空间的频率大约为logn。 如果在删除时加上释放空间的代码，可以将节省空间利用率。也可以通过链表的方式提高插入删除元素时的效率。 说明不同的构造函数中，初始化操作的方式以及意义。 答：vector_ss()是默认构造函数，开辟一个内存空间，v_size赋值为0，capacity赋值为1。 vector_ss(int n)是构造一个初始大小为n的数组的函数。分配n个连续的内存空间，v_size和capacity都赋值为n。 vector_ss(int n,T t)是构造一个初始大小为n的数组，且元素均为t的函数。分配n个连续的内存空间，且将每个变量赋值为t。v_size和capacity都赋值为n。 vector_ss(const vector_ss &amp;v)是拷贝对象v的构造函数。分配与对象v相同容量的连续内存，并拷贝v中数组的元素值。v_size和capacity分别赋值为v.size()与v.capacity。 vector_ss(const vector_ss &amp;v,int start,int end)是拷贝对象v中start位置到end位置的元素的构造函数。分配与对象v相同容量的连续内存，并拷贝v中数组的元素值。v_size和capacity分别赋值为end-start+1与v.capacity。 结语类可以说是C++区别于C语言最重要的一个部分，也是我想要学习的重点。类和C语言中的结构体很相似，可以看作是在结构体的基础上改进的新东西。这个实验本身并不要求算法或者什么需要理解的数据结构，仅仅是通过完成这样一个拥有多个功能的类的实验，来让我们更好的掌握C++这门语言。]]></content>
      <categories>
        <category>计算机</category>
        <category>程序</category>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基于C++的堆排序实现]]></title>
    <url>%2F%E5%9F%BA%E4%BA%8EC%2B%2B%E7%9A%84%E5%A0%86%E6%8E%92%E5%BA%8F%E5%AE%9E%E7%8E%B0.html</url>
    <content type="text"><![CDATA[前言大二上我选修了C++课，因为这门语言我从未学到其精妙之处，所以想要好好学一学。由于平时学业比较繁重，我没有时间将做过的四门实验与大作业发布到博客上。因此，趁着寒假空闲时间，我将落下的几篇博文一一补上。 第一个实验是用C++实现堆排序。虽然C++的STL库可以直接调用优先队列，实现与堆排序相同的功能，但是堆的思想还是有必要好好学一学。不过对我而言，都是学过的东西，稍微回忆一下也都记得个大概，敲起来也并不费事。 原理首先将需要排序的所有元素建立成一个大顶堆。根据大顶堆的定义，父节点上的元素必然大于其子节点上的元素，因此在堆顶上的元素是堆中最大的。然后依次弹出堆顶的元素，即可得到一个有序的数组。 实现方法建立大顶堆的时候，每次从堆底插入新元素，然后与其父节点比较，如果小于其父节点则不变。如果该节点大于其父节点，则与其父节点进行交换，然后再与新的父节点进行比较，重复上述操作直至小于父节点或者达到堆顶。 删除堆顶元素时，将堆顶元素与堆底元素进行交换。然后维护剩下元素的大顶堆。将新的堆顶元素与其子节点中较大的那个进行比较，如果该元素比子节点小，则进行交换，然后重复上述操作，直到该元素比它的两个子节点都要大或者达到堆底。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081#include &lt;iostream&gt;#define n 6using namespace std;//函数模板，能够使得函数调用参数为任意类型template &lt;typename T&gt;inline Swap(T &amp;a,T &amp;b)&#123; T t=a; a=b; b=t;&#125;//从堆底插入新的元素template &lt;typename T&gt;void Insert(T h[],int k)&#123; //由于下标是从0开始，所以要在这里加一。 k++; //插入数从底部上升 while(k&gt;1)&#123; int t=k/2; if(h[t-1]&lt;h[k-1])Swap(h[t-1],h[k-1]); else break; k=t; &#125;&#125;//删除堆顶的元素template &lt;typename T&gt;void Delete(T h[],int m)&#123; //将堆顶的元素与堆末尾的元素进行交换，即删除操作。 Swap(h[0],h[m]); //调整堆，将堆顶的数下降。 int k=1; while(k*2&lt;m)&#123; int t=k*2; t--,k--; if(t+1&lt;m&amp;&amp;h[t]&lt;h[t+1])t++; if(h[t]&gt;h[k])Swap(h[t],h[k]); else break; k=t+1; &#125;&#125;template &lt;typename T&gt;void heapSort(T h[])&#123; //通过插入过程实现建立堆 for(int i=1;i&lt;n;i++)Insert(h,i); //通过删除过程实现排序 for(int i=n-1;i&gt;0;i--)Delete(h,i);&#125;//输出数组template &lt;typename T&gt;void Print(T h[])&#123; for(int i=0;i&lt;n;i++)cout&lt;&lt;h[i]&lt;&lt;" "; cout&lt;&lt;endl&lt;&lt;"====================="&lt;&lt;endl;&#125;int main()&#123; int a[6]=&#123;1,4,5,3,2,8&#125;; double d[6]=&#123;1.4,4.3,2.5,3.7,9.2,0.8&#125;; char c[6]=&#123;'c','d','r','a','y','b'&#125;; string s[6]=&#123;"hello","yes","byebye","welcome","good","morning"&#125;; //排序 heapSort(a); heapSort(d); heapSort(c); heapSort(s); cout &lt;&lt; endl&lt;&lt;"排序结果：" &lt;&lt; endl; cout &lt;&lt; "======================"&lt;&lt;endl; Print(a); Print(d); Print(c); Print(s); return 0;&#125; 运行结果 总结听说了函数模板这种东西之后，才惊觉stl库中的那些函数是通过这样的泛型编程实现的。不过函数模板需要每个函数前都来那么一句，稍微有那么一点不是很舒服。C++函数对于参数的灵活性调用也让我大吃一惊，虽然在此次实验中并没有体现到。]]></content>
      <categories>
        <category>计算机</category>
        <category>程序</category>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>堆排序</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基于python的开机自动登陆网站]]></title>
    <url>%2F%E5%9F%BA%E4%BA%8Epython%E7%9A%84%E5%BC%80%E6%9C%BA%E8%87%AA%E5%8A%A8%E7%99%BB%E9%99%86%E7%BD%91%E7%AB%99.html</url>
    <content type="text"><![CDATA[前言近日与同学聊天，我偶然了解到他写了一个自动登陆网站并且签到的脚本，马上有了兴趣。正好，我常常因每次开机都用登陆校园网而感到麻烦，索性就自己写一个能够自动登陆校园网的脚本。 开发环境系统window7ubuntu18.04 selenium库 Selenium 是一组软件工具集,每一个都有不同的方法来支持测试自动化。大多数使用 Selenium 的QA工程师只关注一两个最能满足他们的项目需求的工具上。然而，学习所有的工具你将有更多选择来解决不同类型的测试自动化问题。这一整套工具具备丰富的测试功能，很好的契合了测试各种类型的网站应用的需要。这些操作非常灵活，有多种选择来定位 UI 元素，同时将预期的测试结果和实际的行为进行比较。Selenium 一个最关键的特性是支持在多浏览器平台上进行测试。 中文文档 安装库1pip install selenium 查看库1pip show selenium webdriver Selenium 2.0 最主要的一个新特性就是集成了 WebDriver API。WebDriver 提供更精简的编程几口，以解决 Selenium-RC API 中的一些限制。WebDriver 为那些页面元素可以不通过页面重新加载来更新的动态网页提供了更好的支持。WebDriver 的目标是提供一套精心设计的面向对象的 API 来更好的支持现代高级 web 应用的测试工作。 win7+Chrome我的window7系统上使用的浏览器是Chrome，所以我需要下载一个Chorme的webdriver首先你需要知道知道你电脑上Chrome的版本，你可以在Chrome的help中找到。然后进入下载的网站，下载对应版本的webdriver。我的Chrome是78版的，所以我也下载了78版接着将其解压，并移动到Chrome的安装目录（或者别的什么目录），并且添加的你的环境变量中的path中。 ubuntu+firefox我的ubuntu系统上使用的火狐浏览器，因此我需要下载火狐的驱动geckodriver同样你需要知道知道你电脑上firefox的版本,然后进入下载的网站，下载对应版本。下载到本地后，进入所在文件夹，打开终端并执行以下指令123tar -xvzf geckodriver*chmod +x geckodriversudo mv geckodriver /usr/local/bin 分别是解压，赋予权限，移动。 代码开发环境搭建好了，接下来就可以代码了。代码很简单，只有短短二十几行。除了自动登陆校园网之外，我还增加了自动检测网络的功能。如果网络尚未连接，那么程序将会不断地登陆校园网，直到检测到网络。检测网络我用的是最简单的ping。1234567891011121314151617181920212223242526#!/usr/bin/env python# -*- coding: utf-8 -*-import timeimport osfrom selenium import webdriver#linux的 ping 命令和windows不一样，会不断的发送包，所以使用ping -c 4 [ip/域名]来限制发包的次数while os.system('ping -c 4 www.kxjzxc.github.io'): # 打开浏览器，同时打开自己想要打开的网页 url='http://10.248.98.2/' driver=webdriver.Chrome(executable_path="C:\\Program Files (x86)\\Google\\Chrome\\Application\chromedriver.exe") #driver=webdriver.Firefox() driver.get(url) # 打首登录页面，此处略去网址 username="xxxxxxxxx" password="xxxxxxxxxx"# 用户名和密码是自己的 # 通过id定位搜索框，同时输入登录用户名密码 driver.find_element_by_id('username').clear() driver.find_element_by_id('username').send_keys(username) driver.find_element_by_id('password').clear() driver.find_element_by_id('password').send_keys(password) driver.find_element_by_id('login').click() driver.close(); 设置开机自启脚本写完了，我们需要让它一开机就自动运行 windows7windows上的操作很简单。首先打开启动文件夹（开始-&gt;所有程序-&gt;启动-&gt;右键打开）,然后自己新建一个bat文件，并以记事本的方式打开。在bat文件中添加以下语句：12python E:\Document\Autorun_program\network.pypause 保存关闭，并且重启测试，完成。 ubuntuubuntu上可能比较麻烦，我尝试了两种方法，但只实现了一种。 方法一第一个方法是通过设置rc.local开机启动命令/脚本来实现这一篇博文讲得比较详细，我这里就简单讲一下操作 编辑以下脚本 1sudo gedit lib/systemd/system/rc.local.service 在末尾加上以下内容 123[Install]WantedBy=multi-user.targetAlias=rc-local.service 创建并打开rc.local 12sudo touch /etc/rc.localsudo gedit /etc/rc.local 在文件中写入指令 123python /home/kermit/Documents/Autorun_program/network.pyexit 0 创建软链接 1ln -s /lib/systemd/system/rc.local.service /etc/systemd/system/ 重启测试 不过以后还有脚本需要开机自启的话，应该只用编辑rc.local文件即可。但是很可惜这种方法我并未实现，原因我也不是很清楚。 方法二第二个方法则是通过ubuntu自带的开机自启应用“Startup Application”来实现找到以上应用并打开，选择Add，即添加应用或脚本。第一栏与第三栏添加名字和描述，可以随意填写。在第二栏填写你想要运行的脚本命令。点击保存，关闭。 此方法实测有效 参考的资料ping命令语法1ping(选项)(参数) 选项1234567891011121314-d：使用Socket的SO_DEBUG功能；-c&lt;完成次数&gt;：设置完成要求回应的次数；-f：极限检测；-i&lt;间隔秒数&gt;：指定收发信息的间隔时间；-I&lt;网络界面&gt;：使用指定的网络界面送出数据包；-l&lt;前置载入&gt;：设置在送出要求信息之前，先行发出的数据包；-n：只输出数值；-p&lt;范本样式&gt;：设置填满数据包的范本样式；-q：不显示指令执行过程，开头和结尾的相关信息除外；-r：忽略普通的Routing Table，直接将数据包送到远端主机上；-R：记录路由过程；-s&lt;数据包大小&gt;：设置数据包的大小；-t&lt;存活数值&gt;：设置存活数值TTL的大小；-v：详细显示指令的执行过程。 结语ok，自动登陆校园网就那么完成了。不得不说python是一个极其好用的工具，我甚至怀疑这门语言是面向非程序员开发的。几个包，几行代码，就很好的辅助，真是舒服]]></content>
      <categories>
        <category>计算机</category>
        <category>程序</category>
        <category>Python</category>
      </categories>
      <tags>
        <tag>教程</tag>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于四害驱赶家用机器人声武器系统这个坑]]></title>
    <url>%2F%E5%85%B3%E4%BA%8E%E5%9B%9B%E5%AE%B3%E9%A9%B1%E8%B5%B6%E5%AE%B6%E7%94%A8%E6%9C%BA%E5%99%A8%E4%BA%BA%E5%A3%B0%E6%AD%A6%E5%99%A8%E7%B3%BB%E7%BB%9F%E8%BF%99%E4%B8%AA%E5%9D%91.html</url>
    <content type="text"><![CDATA[前言昨天早上，历时半年多的大一立项终于完成了最后的答辩。“四害驱赶家用机器人声武器系统的研制”，这是去年年底我们的导师给毫无想法的我们选定的课题。在仓促的几天中完成立项并且答辩成功后，我们就在这个坑中渐行渐远。从一开始的一脸懵逼，充满怀疑，到最后的彻底绝望，自暴自弃，我们理所当然地并没有做出什么成果。虽然这个项目做得一塌糊涂，而且无甚成果，但是……嗯，但是，好歹完成了答辩。心想着深压硬盘底也没什么用，倒不如发布到博客上，也算是给他人排排雷。 课题背景自古以来，四害问题一直困扰着人类。传统的驱逐和消灭方法效率低。经过网上国内外的查询，发现并没有较为有效的驱逐四害的方法，大多数是以人为驱逐的方式，但效率不高；也有药物驱逐，但对人体的身体健康有着危害。 我们小组决定使用人耳听觉频段范围外的声波驱逐四害，原因主要有： 由于声波本身是无形的，所以并不会像化学药剂一样污染环境。 将声波调到合理的强度，对人的危害远小于化学药剂所造成的危害。 不会对人的日常生活工作造成影响。 综上所述，我组决定制作出一种小型的，能够发出可以让四害感到不适却又在人耳听觉频段范围外的声波驱逐四害，且具有指向性的声武器装置，并将其装在可自动导航的小车之上，使其可以边运动边发出次声以驱逐四害。 开始探索通过查阅资料以及导师的指导，我组在经过多次讨论之后，确定了两个不同的声武器驱逐四害的方案。两个方案分别是次声波驱逐方案和高功率超声波驱逐方案。以下是两个方案的详细介绍。 次声波驱逐方案研究根据了解，次声波频率与生物体自身的振荡频率相似，容易发生共振，产生极大能量，使四害感到不适，达到驱逐的效果。因此，可以搭建一个可控次声装置，使其朝设定方向发射强次声波，达到驱除四害的目的。在研究如何产生次声波方面，我组通过大量的资料查询以及数学公式推断，发现两束频率相近的声波可以在空气中线性叠加产生频率为差频的次声波。公式推导如下：假设两列振幅相同的，频率不同的次声波：$φ1(t,x)＝Asin(ω1t＋k1x)φ2(t,x)＝Asin(ω2t＋k2x)$相加并通过一系列三角变换可得：$φ(t,x)＝2Acos(ωt＋kx)cos(ω′t＋k′x)$$ω＝(ω1＋ω2)╱2ω′＝(ω1－ω2)╱2k＝(k1＋k2)╱2k′＝(k1－k2)╱2$ 由此可得叠加后产生了一个振动频率为和频，振幅变化频率为差频的波形。 以下是在MATLAB仿真出来的两组结果： 仿真的结果验证了我们的猜测，两束频率相近的声波的确可以在空气中线性叠加产生频率为差频的次声波。根据这个性质，我们可以先产生两束高频波，然后通过一定的相位差，使其在空气中线性叠加产生次声波。 难题在实施次声波方案的过程中，我组遇到了两个难以克服的困难： 难以产生两束频率相差小于20hz的超声波 我们产生次声波的方案是通过两束频率相近的超声波在空气中线性叠加后产生频率为差频的次声波。因此我们需要先产生两束频率相近的超声波。现有的产生超声波的方式为通过探头将正弦波或是方波转换为同频率的声波，然而这种方式非常依赖硬件，也就是探头。每一种探头的型号只能够加载相应频率的信号波，并发出同种频率的超声波。比如40khz的探头只能够加载40khz的信号波，发出40khz的超声波。 市面上探头的种类有很多，我们能够找到23khz、25khz、40khz等型号的探头，但是大多相差好几k频率，与之相比20hz的差频几乎可以忽略不记。因此在如今硬件水平上，我们难以寻找适合我们的，可以产生两束频率差小于20hz的探头。 市面上买不到合适且有效的次声波传感器 虽然我们的方案并不需要检测产生的次声波，但是在实验过程中检测次声波却是必不可少的。我们不仅需要通过检测次声波来验证我们是否成功产生我们所需要的次声波，还需要记录产生次声波的频率对于实验对象的影响程度。 检测次声波需要相应的硬件，也就是次声传感器。不同于检测非次声的传感器，市面上几乎没有合适的次声波传感器。虽有极少数的商品贩卖，但是不仅价格昂贵，而且多为接触式传感器，完全不符合我们的需求。而网络上虽有许多关于次声波传感器研发的论文与专利，但是大多需要特殊的材料或者不是非常靠谱的理论，以我们的能力很难去自己搭建合适的次声传感器。 因此次声波方案无法实现。 高功率超声波驱逐方案研究通过查阅资料，我组得知有特定频率的超声波会令害虫或者老鼠的听觉系统感到不适的声音（此已被证伪）。因此可以使用超声波来驱逐四害（基本上不行）。根据我组的调查，市场上已有许多使用超声波驱逐四害的装置，像是超声波驱鼠器、超声波驱蚊器之类的，但是效果大多不够显著。我组认为是超声波的功率不够导致达到所需的目的。已知超声波传播带来的能量与超声波的功率有关，如果能够将超声波的功率放大，发出的声场就可以具有高强度的能量，起到驱赶四害的效果。所以如何产生高功率的超声波就成为了我组的研究内容。在这方面，我组的想法是通过放大器模块放大由单片机和dds模块产生的正弦信号波，再加载到相应频率的探头上。为此，我组制定了以下初步方案： 首先通过程序使单片机发出频率控制字，分别输入到dds模块中。 由dds模块产生高频率的正弦波信号。 使用放大器模块将产生的正弦波信号放大功率，然后加载到相应频率的超声探头上。 大致结构如下图所示：我们采用的放大器模块为LM386，但是事实上，市面上的放大器模块的放大功率的效果并不是特别好，在限定工作电压范围内，大多无法满足放大到我们需求的倍数，所以我们需要寻找另一种放大超声波功率的方案。受到我们的师兄正在研究基于相控阵的超声悬浮的启发，我组认为通过使用多个探头组成相控阵，发出相同频率的超声波，并且调整激励信号与声源的几何位置，使其满足一定的关系，可以将产生的超声波能够在某一固定点处相叠加，产生高强度的声波能量，从而达到放大功率的效果。根据师兄提供的论文，该相列阵的电路结构大致如图所示：用FPGA电路板作为控制模块，将信号传递给驱动板。然后由驱动板驱动相应的排成阵列的探头，产生相应频率的超声波。超声波将在空气中某一点聚焦，成为高功率的声波。但是由于我组能力上的不足，尽管理论与方案都已给出，未能完成超声相控阵列，只能完成使用放大器模块放大超声波的方案。 实验结果以下是我们通过示波器检测到波功率的结果。 放大器外接电压/V 波频率/HZ 正弦波信号/接收到的超声波 峰值/V 5 23k 接收到的超声波 15.4 5 40k 接受到的超声波 46.4 5 40k 正弦波信号 10.8 11 23k 正弦波信号 25.6 11 40k 正弦波信号 44 11 40 接收到的超声波 102 虽然我们利用放大器成功放大了产生的超声波，但是放大的倍数仅为原先的两倍，效果不是非常的好。而且由于各种现实条件以及自身经验缺乏的原因，我组未能定制最后检验效果的实验方案，没有进行最终的检测。首先是实验动物的缺失，学校里没有动物中心这类地方，我组也未能联系到提供实验动物的机构。如果自己捕获四害的话，没有合适的处理方式，会导致实验的正确性不高。再有我组并没有动物实验的经验，对于实验的步骤与实验结果的分析都毫无头绪。 综上所述，我们的方案并没能经过实验的验证。 结束语如果你看完了这篇博文，你自然可以明白我们的项目是多么的水，多么的不切实际。不仅硬件上碰到困难，理论上无法证实，动物实验不会做，本身能学到的东西也是少的可怜。我们最初的方案就只有次声波，超声波的方案是次声波方案确认无法继续之后才临时决定的，虽然这个方案从原理上就是错误的。声波驱蚊？一直在坑爹，从未生过效 做到最后，我们只剩下拿到这门课的学分这一目的。用尽全力充实自己的报告和ppt，将自己的项目包装成很丰富，很充实的样子。但无论再怎么充实，终究也只是伪物，看到别组诸如体感小车，寻物机器人之类的牛逼项目，还是忍不住叹气，感觉自己浪费了大一立项的大好机会。 说到底应该算是最初项目选择上的锅。本来就没有什么经验的大一学生，应该选择在已有的成熟的产品基础上进行二次开发，而不是愣头青一般往不怎么可靠的方向乱窜。虽然我们也是往小车上安装声武器，但是声武器本身就没有成熟的理论支持，而且极其依赖硬件设施。而这些都成为了阻挡我们的高墙，逐渐消磨我们的热情，也慢慢浪费着我们的时间，因为我们基本上没能从中获得的我们所需要的东西和热情。 相比于这个不适合我们的项目，我觉得我实习期间所做的机械臂项目都要有用高级的多。而有时我脑海中也会蹦出几个容易做且有趣的项目，像是自主移动的风扇机器人之类的，只可惜立项之时脑袋中空空如也。 事到如今，大一项目也已经结束，该水的也水完了，除了叹气并总结一下经验也没有什么可以改变的。听说大二还有大创，希望这次我能够做出个好东西来。]]></content>
      <categories>
        <category>项目</category>
      </categories>
      <tags>
        <tag>项目</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基于OpenCV和Zbar的识别二维码控制机械臂]]></title>
    <url>%2F%E5%9F%BA%E4%BA%8EOpenCV%E5%92%8CZbar%E7%9A%84%E8%AF%86%E5%88%AB%E4%BA%8C%E7%BB%B4%E7%A0%81%E6%8E%A7%E5%88%B6%E6%9C%BA%E6%A2%B0%E8%87%82.html</url>
    <content type="text"><![CDATA[前言在越疆实习的时候并没有问部门里的人自己该干什么，所以似乎也没有什么任务交给我做。由于在培训的时候接触到了ROS，也就顺水推舟地朝着这个方向学了下去。第一周学习用ROS控制机械臂，消息、服务、启动文件之类的也都了解了大概。接下来就试着朝Opencv这一方面研究，在完成打开摄像头，人脸识别等简单项目后，我脑中浮现出了这个项目，二维码控制机器人。这个构思的诞生，说来也是意外之思。当时我做完人脸识别项目后，看到《ROS机器人开发实践》这本书上后面的二维码识别,联想到其他班的同学的一个轮式机器人编队的项目，听说他那个项目中是通过二维码来确定小车的位置。于是我就想，我是不是也可以通过二维码传输指令给机械臂，以此控制机械臂运动呢？深入思考之后，发现可行，网上也有识别二维码的代码，只要将两者合在一块就能实现了。虽说书上是有二维码识别的讲述，但是我并没有采用上面的方法。原因很简单，因为我并没有向部门里的人要摄像头，所以我现有的设备除了机械臂和气泵装置外，只有我笔记本自带的摄像头了。而书上的方法第一步就将我卡住了，因为它需要标定摄像头。我寻思着我这破摄像头也没法标定啊，只能放弃这个方法。所幸，根据之前做人脸识别的经验，我想到只要对摄像头获取的每一帧进行图像处理，即视觉识别即可。终于，经过几天的查资料，自己折腾，我顺利做出了一个简单的版本。 概述运用OpenCV库调取摄像头的画面，然后使用Zbar库中的函数扫描画面，获取画面中存在的二维码的信息，并以ros消息的形式发布到话题上，由客户端节点订阅到话题上的消息后，调用加载到服务端的动态链接库来控制机械臂执行相应的命令 搭建开发环境Linux系统我使用的是Ubuntu 18.04。安装Linux系统的教程网上很多，自行寻找。 机器人操作系统ROS从官网上安装对应linux系统的ROS，步骤很详细，一步一步照做即可 OpenCV库ROS中已经集成了OpenCV库以及相关接口功能包，如果你安装的是全桌面版的ROS，那么电脑中大概已经有OpenCV了。如果电脑中并没有OpenCV，那么可以通过以下命令来安装：1$ sudo apt-get install ros-kinetic-vision-opencv libopencv-dev python-opencv 其中ros-kinetic-vision-opencv中的kinetic可以替换成相应的ros版本 Zbar库 ZBar是一个开源库,用于扫描、读取二维码和条形码。 通过Zbar，我们可以扫描图像，检测其中的二维码，并且解析出其中的消息。要在Ubuntu中使用Zbar，我们首先要安装Zbar库。下面是安装步骤： 通过命令行直接下载zbar 1$ wget http://downloads.sourceforge.net/project/zbar/zbar/0.10/zbar-0.10.tar.gz 进入压缩包所在的文件夹直接解压 1$ tar -zvxf zbar-0.10.tar.gz 安装相关依赖 12$ sudo apt-get install python-gtk2-dev$ sudo apt-get install libqt4-dev 编译Zbar 1234$ ./configure --enable-shared --disable-video --without-python --without-gtk --without-qt --without-imagemagick CFLAGS=&quot;&quot;$make $sudo make install$sudo ldconfig 运行examples 123$cd example$gcc scan_image.c -o scan_image -lzbar -lpng$./scan_image barcode.png 输出结果： decoded EAN-13 symbol &quot;9876543210128&quot; 运行流程先由qrcode包中的my_pulisher节点打开摄像头，获取画面并且以消息的形式发布到话题“camera/image”上。然后由my_subscriber节点扫描从话题“camera/image”上订阅到的图像。如果从图像中扫描到图像中的二维码，那么将解析出来的指令信息发布到话题“GetCtrl_msg”上。最后由dobot包中的DobotClient_PTP节点订阅话题”GetCtrl_msg”上的指令，并根据指令，向服务端DobotServer节点请求相应的服务，控制机械臂。 代码分析代码位置 my_publisher该节点是打开摄像头，并获取摄像头图像消息，发布到话题”camera/image”的代码。 程序1.1加载ROS、Opencv头文件12345#include &lt;ros/ros.h&gt; #include &lt;image_transport/image_transport.h&gt; #include &lt;opencv2/highgui/highgui.hpp&gt; #include &lt;cv_bridge/cv_bridge.h&gt; #include &lt;sstream&gt; // for converting the command line parameter to integer 程序1.2初始化节点12ros::init(argc, argv, &quot;image_publisher&quot;);ros::NodeHandle nh; 程序1.3注册话题到ROS Master上12image_transport::ImageTransport it(nh); image_transport::Publisher pub = it.advertise(&quot;camera/image&quot;, 1); //在发布图像消息时消息队列的长度只能是1 程序1.4 打开摄像头12345678910111213141516171819202122232425262728293031323334// Convert the passed as command line parameter index for the video device to an integerint video_source; bool check=ros::param::get(&quot;/image_publisher/video&quot;,video_source);/*检查视频源是否已作为参数传递*/ if(check == 0) &#123; ROS_INFO(&quot;no camera %d\n&quot;,video_source); return 1; &#125; cv::VideoCapture cap(video_source); //判断视频读取或者摄像头调用是否成功if(!cap.isOpened()) &#123; ROS_INFO(&quot;can not opencv video device\n&quot;); return 1; &#125; 程序1.5 发布摄像头图像消息到话题”camera/image”上//ROS中的图像消息类型sensor_msgs::ImagePtr msg; ros::Rate loop_rate(5); while (nh.ok()) &#123; cap &gt;&gt; frame; // Check if grabbed frame is actually full with some content if(!frame.empty()) &#123; //将opencv格式的图像转化为ROS所支持的消息类型 msg = cv_bridge::CvImage(std_msgs::Header(), &quot;bgr8&quot;, frame).toImageMsg(); pub.publish(msg); //cv::Wait(1); &#125; &#125; my_subscriber该节点则是将订阅到的图像消息进行图像处理，即二维码识别。在识别到二维码后，将解析出来的信息以消息的形式发布到话题”GetCtrl_msg”上。其中，wait这个变量是为了在识别过后等待一段时间在识别下一个二维码。 程序2.1 加载ROS，OpenCV，Zbar的头文件和命名空间1234567891011121314151617181920212223242526#include &lt;ros/ros.h&gt; #include &quot;std_msgs/String.h&quot;#include &quot;iostream&quot;#include &quot;string.h&quot;#include &quot;fstream&quot;#include &quot;signal.h&quot;#include &lt;termios.h&gt;#include &lt;math.h&gt;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;sys/poll.h&gt;#include &lt;boost/thread/thread.hpp&gt;#include &quot;opencv2/core/core.hpp&quot; #include &quot;opencv2/highgui/highgui.hpp&quot; #include &quot;opencv2/imgproc/imgproc.hpp&quot; #include &lt;opencv2/opencv.hpp&gt;#include &lt;image_transport/image_transport.h&gt; #include &lt;cv_bridge/cv_bridge.h&gt; #include &lt;zbar.h&gt;#define oo 1e9+7using namespace std;using namespace zbar; //添加zbar名称空间 using namespace cv; 程序 2.2 初始化节点，窗口，并注册发布和订阅的话题123456789ros::init(argc, argv, &quot;image_listener&quot;); ros::NodeHandle nh; cv::namedWindow(&quot;Source Image&quot;); //开始窗口线程cv::startWindowThread(); image_transport::ImageTransport it(nh); signal(SIGINT, MySigintHandler);ros::Publisher pub=nh.advertise&lt;std_msgs::String&gt;(&quot;GetCtrl_msg&quot;,1000);image_transport::Subscriber sub = it.subscribe(&quot;camera/image&quot;, 1,boost::bind(&amp;imageCallback,_1,boost::ref(pub))); 程序2.3 订阅到图像消息后回调函数1234567891011121314151617181920212223242526void imageCallback(const sensor_msgs::ImageConstPtr&amp; msg,ros::Publisher pub) &#123; try &#123; Mat image=cv_bridge::toCvShare(msg, &quot;bgr8&quot;)-&gt;image; imshow(&quot;Source Image&quot;, image); if(wait==100)&#123; wait=-1; ROS_INFO(&quot; Continue to identify &quot;); &#125; else if(wait!=-1)&#123; wait++; return; &#125; cvtColor(image, image, CV_RGB2GRAY); if(Scan(image,pub))&#123; wait=0; &#125; //waitKey(30); &#125; catch (cv_bridge::Exception&amp; e) //异常处理 &#123; ROS_ERROR(&quot;Could not convert from &apos;%s&apos; to &apos;bgr8&apos;.&quot;, msg-&gt;encoding.c_str()); &#125; &#125; 程序2.4 使用Zbar库识别二维码并发布解析出来的消息12345678910111213141516171819202122232425262728293031bool Scan(Mat image,ros::Publisher pub)&#123; //zbar类，定义扫描器 ImageScanner scanner; //配置参数，初始化 scanner.set_config(ZBAR_NONE, ZBAR_CFG_ENABLE, 1); int width = image.cols; int height = image.rows; uchar *raw = (uchar *)image.data; //封装图像数据 Y800单色图像格式 Image imageZbar(width, height, &quot;Y800&quot;, raw, width * height); //扫描条码或者二维码 scanner.scan(imageZbar); for (Image::SymbolIterator symbol = imageZbar.symbol_begin(); symbol != imageZbar.symbol_end(); ++symbol) &#123; cout &lt;&lt; &quot;类型：&quot; &lt;&lt; endl &lt;&lt; symbol-&gt;get_type_name() &lt;&lt; endl &lt;&lt; endl; cout &lt;&lt; &quot;二维码：&quot; &lt;&lt; endl &lt;&lt; symbol-&gt;get_data() &lt;&lt; endl &lt;&lt; endl; //发布消息到话题“GetCtrl_msg”上 std_msgs::String msg; msg.data=symbol-&gt;get_data(); pub.publish(msg); imageZbar.set_data(NULL, 0); return 1; &#125; //清除缓存 imageZbar.set_data(NULL, 0); return 0;&#125; DobotClient_PTP该节点是订阅话题”GetCtrl_msg”上的指令消息，并做出相应的行为。程序3.1 初始化节点12ros::init(argc, argv, &quot;DobotClient&quot;);ros::NodeHandle n; 程序3.2 注册订阅器1ros::Subscriber sub = n.subscribe&lt;std_msgs::String&gt;(&quot;GetCtrl_msg&quot;, 1000,messageCallback); 程序3.3 回调函数1234567void messageCallback(const std_msgs::String::ConstPtr &amp;msg)&#123; std::string cmd=msg-&gt;data.c_str(); if(cmd==&quot;0&quot;)DobotHome(); else if(cmd==&quot;1&quot;)Action(); else if(cmd==&quot;2&quot;)getPoint(); else if(cmd==&quot;3&quot;)Point.clear();&#125; 以上DobotHome(),Action(),getPoint()函数中就是通过服务请求的方式向 DobotServer节点请求相应的服务，此处并未展现。 结果测试启动ros master1$ roscore 打开新终端，运行DobotServer1$ rosrun dobot DobotServer 打开新终端，启动launch文件，可同时打开qrcode功能包中的my_subscriber和my_publisher节点，dobot功能包中的DobotClient_PTP和DobotClient_GetInfor。1$ roslaunch qrcode camera.launch 启动文件成功运行后，将含有指令信息的二维码对准摄像头，控制机械臂运动。0 回零 1 执行 2 记录点位 3 清空点位通过按下机械臂上的解锁按钮，手动移动机械臂。当松开按钮时，机械臂将自动记录末端点位。以上操作也可以通过键盘来操控机械臂运动，按下0～3相应的按键可操作。按Ctrl+C可终止启动文件。 不足之处 实现的功能过少 有时候会一下子识别好几次二维码，原因不明。 其实很多节点都可以合并成一处。不过分到不同节点上去也可以使人对于节点间的通讯更加了解。 总结这个项目可以说是把我这一个月来所学的东西都揉在一块，ROS、OpenCV、Zbar……作为我本次实习出来的结果也算是令人满意。原本作为一个大一刚刚结束的学生，其实根本没想过自己实习的时候能做些什么，毕竟一开始什么也不会，ROS,OpenCV这些也只不过是听过而已。但是经过三个周的自我探索，对这些东西也有了一个初步的了解，对于脑中时不时浮现的奇思妙想也有更加具体的构思，而并非以前那样的天马行空，形而上学。 大一实习生到底能做些什么呢？我觉得什么都做不了，但什么都能做。 毕竟大一接触的专业知识并不多，大多还只是通识教育。若是在实习初期就告诉我要做个balabala玩意我估计会一脸懵逼，不知所云。但是我不会毫无办法，甚至逃避现实。因为我深知工作中所运用的大部分知识都根本没有必要非得在学校里学习，这些只是完全是可以通过自学来掌握的。没有学过的东西，只要不是必须需要非常高深的理论知识，我们完全可以现学现用。像是ROS和OpenCV这类东西，学校里一般是不会教学生的，基本上需要学生自学掌握。在做项目的过程中也不一定非要完全掌握了某样东西才能去做。学海无涯，bug不止，哪有人能百分百的精通一个技能。人总会遇到自己无法解决的问题，这个时候只要百度，谷歌一下，总能找到解决方法。 重要的，是耐下心来，脚踏实地，慢慢探索。 我其实很感谢我高中学习竞赛的那段经历。虽然我并没有获得完美的收场，但是我的确收获了很多。编程的入门，算法的理解，搜索的方法，以及……自学的觉悟。因为在看题解的时候，我常常会遇到一些我没有学过的，老师也没讲过（虽然老师很少讲东西）的新算法或者数据结构。一开始，我大惊小怪，感到很坑，怀着这玩意是高级货的心态去学习，弄得自己好像是刚出新手村就碰见四大天王的勇者。然而后来这种事情经历的多了，也就习以为常了，碰到不懂的东西？莽就完事了。对我而言，很少有东西是自学学不会的（动手操作除外），只要肯投入实践，到处查资料，自己折腾一番，最后总能搞出个所以然来。 此文到此结束，感谢观看。]]></content>
      <categories>
        <category>计算机</category>
        <category>程序</category>
        <category>OpenCV</category>
      </categories>
      <tags>
        <tag>ROS</tag>
        <tag>OpenCV</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于我重装ubuntu系统后所做的那些事]]></title>
    <url>%2F%E5%85%B3%E4%BA%8E%E6%88%91%E9%87%8D%E8%A3%85ubuntu%E7%B3%BB%E7%BB%9F%E5%90%8E%E6%89%80%E5%81%9A%E7%9A%84%E9%82%A3%E4%BA%9B%E4%BA%8B.html</url>
    <content type="text"><![CDATA[安装关于安装系统的具体过程，网络上有很多博客，私以为这篇博客讲得最为详细，基本上按顺序照做即可。其中有几个注意点： 硬盘方面用DiskGenuis处理一下即可。 UEFI模式电脑，U盘启动盘要制作成UEFI模式，否则很可能无法识别U盘。 重启电脑前，要注意关闭win10电源计划中的快速启动这个选项，否则可能无法进入启动盘。具体方法自行百度。 修改BIOS启动U盘时，除了常规操作外，要使Secure Boot不使能，而且Boot Mode必须选择Uefi模式。 关于分区设置，我设置了三个分区 引导分区 efi 主分区 200MB 交换区域 swaparea 逻辑分区 4096MB（4G） 主目录 ext4 逻辑分区 挂载到/ 剩下空间（有些人会将/home从根目录里单独分出来，相当于文档盘。但是我觉得没必要） 我通常选择的是最小化安装，所以系统里最初就只有firefox，gedit，Teriminal以及一些系统工具等基本配置。重新安装了Ubuntu，那么一切都得重新配置，接下来就让我谈谈我都在Ubuntu上做了什么吧。 配置更换下载源到软件与更新中选择更换合适的下载源，默认下载源太慢了。 更新完后来一波操作12sudo apt-updatesudo apt-upgrade 语言设置由于上次将系统设置成中文后，tty模式经常会乱码。这着实让我感到非常不爽，所以这次我索性将系统设置成英文，等习惯了说不定还能学好英文呢（笑）。至于输入法，拼音绝对是必不可少的。无论是写博客，还是查资料，我都必须用中文。这次我依旧选择的是ibus输入法。首先安装拼音输入。1sudo apt-get install ibus-pinyin 然后打开设置选择Region&amp;Language，点击‘Manage Installed Languages’，在Install/Remove Languages中选择Chinese(simplified)，选择apply。回到Region&amp;Language，在Input Source中点击加号，单击Chinese，选择Chinese(Pinyin)，设置完成。 hexo+git（2019.8）我用ubuntu的一大功能就是写blog，所以博客的环境必不可少。由于之前写过教程，所以这里就不再赘述了。 百度网盘（2019.8）重装系统前，我都是使用Aria2来下载百度网盘文件的。后来终端不能用了，又要下载win7镜像文件，所以就下载了百度网盘linux版本，却意外发现也许大概应该可能没有限速？所以索性这次就直接下载百度网盘的linux版，反正aria2也不快，而且还麻烦。方法嘛，直接去官网下载压缩包喽。 WPS-Office为了看word文档和ppt，就必须要有Office。这次因为是最小化安装，所以系统也就没装LibreOffice，而且我也不太喜欢用这玩意，打开个文件都要半天。所以我去下载了WPS。12wget http://kdl.cc.ksosoft.com/wps-community/download/6634/wps-office_10.1.0.6634_amd64.debsudo dpkg -i wps-office_10.1.0.6634_amd64.deb 第二条命令需要进入安装包所在目录 ROSROS有需要就装，方法也不在这里赘述了，自己去官网找呗。 音乐播放器到写这篇博文前，我才惊觉自己没有安装音乐播放器。Gnome桌面套件自带的Rhythmbox我是不打算用了，倒也不是有什么地方不好，只是想换换。虽然网易云也有Linux版，但最终我还是选择比较符合Ubuntu气质的播放器（其实我也不知道啥是Ubuntu气质）。于是在一众神奇的播放器中，我相中了被称为Ubuntu界的千千静音的Audacious。至于用法，我暂且不会，将来用习惯了，用会了，或许会提一下。12sudo apt-get install audacioussudo apt-get install audacious-plugins 第二条命令是安装解码器。 grub界面背景选择一张背景，移动到/boot/grub里即可1sudo cp -v grub_background.jpg /boot/grub grub_background.jpg是你选择的背景图片 修改默认启动项打开并编辑/etc/default/grub，修改GRUB_DEFAULT= 0,修改的数字就是你想要默认启动的项的位置。例如Windows项在第三位，那我就改成2（0为第一位）。1sudo gedit /etc/default/grub 修改分辨率编辑/etc/default/grub文件，修改GRUB_GFXMODE=800x640把分辨率改为适合你的屏幕的大小,且支持的值。可以在grub界面按c，然后输入videoinfo查看。 进行上述操作后，需要使用以下指令更新1sudo update-grub 遇到的坑第一坑-空间（2019.8）前文讲分区的时候说了，感觉给根目录的分区太小，因为软件基本上是装在这上面的。我后来装了个ROS后，就只剩下几百MB了这时摆在我面前的有两种做法第一，压缩/home分区，划给根目录，也就是直接切割磁盘。为此我下载了Gparted，然而那似乎只能操作非当前系统。所以我得去win7上操作。但是这终究只是我的猜想，而且这几天的经历也给我留下心理阴影，不敢再对磁盘动手。第二，将/usr目录和/opt目录移到/home目录下。这是我上网找到的方法，还不错。 尽量的关掉不用的程序 复制 1cd / ; sudo tar cf - usr opt | (cd /home ; sudo tar xfv - ) 编辑fstab 1sudo vim /etc/fstab 没有vim用gedit。 在带/usr 和/opt的行(如果有的话)最前面加上#号 然后在紧接着 /home 的那行加上。 12/home/usr /usr none bind 0 0/home/opt /opt none bind 0 0 保存并重启 方法有效。但是我后来想删掉根目录下的/usr时，系统又双叒叕崩溃了。原因不明，方法无效，准备重装。好吧，实际上这次我用启动盘启动后，没有选择install ubuntu，而是try ubuntu于是我进入了在ubuntu系统后，检查了两个目录下的/usr目录，发现主目录下有缺失，于是用sudo cp -r 源文件路径 要复制到的文件夹路径将/usr有复制了一遍后，成功重启。但是我不打算再碰根目录了。 第二坑-wifi适配器安装完之后发现无法连接无线网络，打开设置里的wifi，才发现显示未发现wifi适配器。 解决方法：1sudo modprobe -r ideapad_laptop 第三坑-比例问题由于电脑分辨率比较高，系统显示的字体与界面都比较小。可以到设置-&gt;设备-&gt;显示中修改比例 Log2019-08-07上周五，我搞完基础的ros，准备进军OpenCv了解了解图像处理。然而没意识到装ROS全桌面版时OpenCv早已跑到我电脑里的我傻乎乎地打算再装一个OpenCv。于是在漫长且无趣的安装途中，我一时心血来潮，查看了自己的python版本——2.7，于是果断打算升级一波。且不说我不知道系统本来就自带两个版本的python，等我心满意足地升级完后，意外地发现自家终端打不开了。这就是此次事故的万恶之源。根据网上提供的方法，我进入tty3，输入gnome-terminal，回车，发现是什么no module named &#39;gi&#39;。我百度几下，再各种死马当活马医的折腾，却完全不见效果。最终恼羞成怒的我，决定莽过去，极其无脑地删掉了整个python3文件夹，于是乎，系统崩溃。而后随抢救回来，但是也不过是回到原点，而且输入法也消失了。 无计可施的我打算重装了。但是完全没有经验的我打算先卸载移动硬盘里的ubuntu（我装在移动硬盘里），先搞grub引导。于是下载FreeBSD就是一通乱搞。好了，我把win7也搞炸了。win7上不去？那就只能暴力重装喽。但现在只有ubuntu是可以制作启动盘喽，于是又回到ubuntu制作win7的启动盘。结果最后有败在了引导上，连ubuntu都装不上去了。好的，那么现在两个系统都白给了。浪费了整整一天的我求助了同学，最终意外的用PE修复了win7的引导，可喜可贺。（PE真是个好东西） 事到如今，我也改变了想法，将两个系统都装在电脑硬盘上，文件数据都放在移动硬盘上。如此一来我也不必费劲去卸载原先的ubuntu了。怀着这等策略，我迎来了安装ubuntu的第二天，然而很快就迎来了第一个坑——启动盘无法启动我的电脑。我的启动盘是用sd卡+读卡器制成的，理论上和U盘没什么区别，而我的电脑就是无法在开机时识别到此启动盘。确定一遍bios，没错。在别人电脑上试试，识别成功。用UltraISO制作，还是不行。就这样荒废了整个白天，我也没查出个所以然来。最终将原因归结为电脑型号太旧无法识别读卡器后，向同学借了个U盘，制成启动盘，成功启动。 接下来的安装ubuntu的过程倒是简单到令人感动。 经过这三天看似毫无意义的折腾后，我对系统修复和安装以及ubuntu的结构都上升了一个台阶，也算是不幸中的万幸。这篇博文我打算时时更新，将我认为必要的软件和操作写到此处，以便以后重装系统时，能知道做什么。 2020-7-30今年换了新电脑，我也从win7党变成了win10党。不过刚买来发现并没有安装ubuntu的必要，所以也就没有急着装双系统，博客什么的也都迁移到了windows上。然而下学期选了需要用ros的课程，所以最近把Ubuntu装了起来。 由于电脑比原先的高级一些，而系统也不再是win10，所以我这次安装系统也花费了不少时间，虽然最后发现都是启动盘制作工具的锅，我还是老老实实的用USBWriter吧。 至于grub，我原先只是想要改个启动顺序，毕竟主要还是使用windows，不想每次都手动选择。搜索的过程中发现了还可以更改背景这一操作，甚是惊喜。不过分辨率最终还是没有修改。倒不是没有用，而是其他分辨率比例不对，让人头痛。]]></content>
      <categories>
        <category>教程</category>
      </categories>
      <tags>
        <tag>教程</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ROS第一坑之基本操作]]></title>
    <url>%2FROS%E7%AC%AC%E4%B8%80%E5%9D%91%E4%B9%8B%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C.html</url>
    <content type="text"><![CDATA[前言作为自动化专业的学生，机器人操作系统ROS的大名如雷贯耳。 ROS 是一个适用于机器人的开源的元操作系统。它提供了操作系统应有的服务，包括硬件抽象，底层设备控制，常用函数的实现，进程间消息传递，以及包管理。它也提供用于获取、编译、编写、和跨计算机运行代码所需的工具和库函数。在某些方面ROS相当于一种“机器人框架（robot frameworks）”——ROS Wiki 早在今年年初，我与同学一起参观华强北的优艾智合公司的时候，为我们介绍公司的人（似乎是我们的师兄）就向刚结束大一上学期，尚不明所以的我们介绍了机器人学习之路，其中就提到了非常重要的ROS。虽然当时ROS在我心目中留下了深刻的印象，但是我并没有时间也没有机会去学习。 直到小学期，我深感自己在本专业的自我学习上完全不够，所以一时心血来潮安装了ROS，可惜知道小学期结束，我连打开都未曾打开过。所幸暑期在越疆实习的时候，可以使用ROS操纵他们的机械臂。因而我便趁此机会借用公司的机械臂和其官网上的demo开始真正接触ROS。 然而我并不想写关于ROS的教程，该方面的书籍资料已经够多了，即使那些资料并非十分完美，但至少会比我自己写的要有用的多。所以在这篇文章中我也只想谈一谈我在学习ROS初级教程中所遇到的坑。 ROS Wiki中文 从安装到入门 ROS_INFO不输出我从越疆官网上下载下来的demo是将所有的程序都写在一个main函数中，这使得稍微有点强迫症的我手动将main函数里的程序封装在不同的函数中。然而作为一个懵懂无知的新手，我的“莽撞”行为导致我在后期调试的时候,在跳出第一个调用的函数后，ROS_INFO都输出不了。我上网搜索原因，可似乎没有人遇到与我相同的问题，所以就暂且搁置。后来我一句一句的测试，发现我将第一个句柄的创建写在main函数中的这个函数调用前问题就解决了。原因目前暂且不明，但是当我后来知道ROS节点是在第一个句柄被创建后才开始的，我就怀疑应该是这个原因了。无论如何以后的ROS程序，句柄一定要写在初始化语句的后面。当然，如果我们也可以选择使用ros::start()和ros::shutdown来启动和关闭节点。123456int main(int argc, char **argv)&#123; ros::init(argc, argv, &quot;Quit&quot;);//初始化节点 ros::NodeHandle n;//创建句柄,节点开始 return 0;&#125; 消息与服务关于消息与服务的理解，srv文件与msg文件的创建，订阅器与发布器的编写，服务端和客户端的编写在官网上都写得非常清楚，这里我也就不再赘述。服务端和客户端的编写我倒是没遇到什么大的问题，毕竟demo中有此两者的源代码。遇到问题也不过是我没有按照流程一步一步来。但对于消息的订阅器与发布器编写我倒是经常遇到的坑，虽然大多由于我理解有误。 订阅器与发布器的注册编写订阅器和发布器的时候首先要向节点管理器（ros Master）进行注册，这是毋庸置疑的。但是要值得注意的是，要在main函数中启动节点后就注册，尤其是发布器，不能够在单独的函数中进行注册，要不然会无法发布消息。 12ros::Publisher pub=n.advertise&lt;dobot::GetCtrl_msg&gt;("GetCtrl_msg",1000);//注册发布器ros::Subscriber sub = n.subscribe&lt;dobot::GetCtrl_msg&gt;("GetCtrl_msg", 1000,messageCallback);//注册订阅器 ros::spin()与ros::spinOnce()对于这两个函数的详解，网上资料也有很多，像是这个博客简而言之，就是在你订阅消息的时候，只有遇到这两条语句的时候才会调用回调函数。使用ros::spin()会进入自循环，也就是不断的调用自己，以使一接收到消息就进入回调函数。使用此语句，该语句下面的程序都不会再被执行。而ros::spinOnce()只会调用一次回调函数，可以实现接下来的程序。 消息的发布订阅机制消息会发布到注册的话题上，然后订阅器实时的订阅话题上的消息。这就等同于一个节点实时接受另一个节点的指令，而并非信息的传递，订阅器是无法接受之前发布的消息的。举个例子：我之前想让一个节点记录我机械臂末端的坐标，并发布到话题上。然后我开启另一个节点，先接受话题上的坐标信息，在执行操作。然而实际上这么做是不可行的，当我开启另一个节点的时候，之前发布到话题上的消息已经过期了，新节点是无法订阅到坐标消息的。所以后来我转变了思路，由第一个节点发布指令消息，第二个节点根据接受到的指令消息作出相应的操作，这样一来第二个节点就可以一接收到第一个节点发布的消息就执行操作或者记录节点。执行完后继续等待指令消息。 回调函数传递多个参数在ROS的节点程序中，经常会使用到许多回调函数，像是订阅到消息 的时候会自己调用回调函数。但这种时候传递到回调函数里的参数是固定的，所以我们需要使用boost::bind函数来使我们可以自由的传递参数。 boost::bind是标准库函数std::bind1st和std::bind2nd的一种泛化形式。其可以支持函数对象、函数、函数指针、成员函数指针，并且绑定任意参数到某个指定值上或者将输入参数传入任意位置。 boost::bind(f,1,2) —&gt; f(1,2)boost::bind(f,_1,1) —&gt; f(x,1)具体用法参见此博客 此处举两个例子 订阅消息12ros::Subscriber sub = n.subscribe&lt;dobot::GetCtrl_msg&gt;("GetCtrl_msg", 1000,messageCallback);//单参数ros::Subscriber sub = n.subscribe&lt;dobot::GetCtrl_msg&gt;("GetCtrl_msg", 1000,boost::bind(&amp;messageCallback,\_1,point);多参数 其中_1是占位符，代表回调函数中原先的参数const dobot::GetCtrl_msg::ConstPtr &amp;msg。 多线程12boost::thread t(keboard);//单参数boost::thread t1(boost::bind(&amp;keyboard,boost::ref(pub)));//多参数 其中boost::ref(x)是向回调函数传递一个变量 退出节点在未使用launch文件启动的情况下，每一个节点都是一个终端，所以通常只要按Ctrl+C即可取消命令，程序会调用ros::shutdown()来关闭节点。但是有时候我们会需要在退出节点的时候进行一些处理，例如需要清空指令队列使机器人停下或者传递消息之类的。这时候我们就需要signal函数来覆盖原先的Ctrl+C，使得当用户按下Ctrl+C的时候，会调用相应的回调函数，作最后的处理。这里是对信号处理函数的比较好的介绍1234567891011121314151617181920#include "ros/ros.h"#include "signal.h"void MySigintHandler(int sig)&#123; //这里主要进行退出前的数据保存、内存清理、告知其他节点等工作 ROS_INFO("shutting down!"); /*自己封装的函数 StopQueueCmd(); ClearQueueCmd(); */ ros::shutdown();&#125;int main(int argc, char **argv)&#123; ros::init(argc, argv, "Quit");//初始化 ros::NodeHandle n;//创建句柄 signal(SIGINT, MySigintHandler);//第一个参数是指Ctrl+C的指令，第二个参数是调用的函数 ros::spinOnce(); return 0;&#125; 总结其实还有好多的东西没有写，像是我封装函数到服务端，launch文件启动，用键盘键入字符，多线程等，只是这些大多是基础教程或是与ros关系不大的知识，所以也就没写出来。这几天用ros实现我所想要的功能时，也的的确确学到了不少东西，至少ros的初级用法都已明晰。虽然还有许多有待提升的地方，像是暂停功能、紧急停止功能、用栈优化指令队列之类的，不过意义不大，也就没有继续写下去了。]]></content>
      <categories>
        <category>ROS</category>
      </categories>
      <tags>
        <tag>ROS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基于C语言与EGE图形库的模拟地铁自动售票系统]]></title>
    <url>%2F%E5%9F%BA%E4%BA%8EC%E8%AF%AD%E8%A8%80%E4%B8%8EEGE%E5%9B%BE%E5%BD%A2%E5%BA%93%E7%9A%84%E6%A8%A1%E6%8B%9F%E5%9C%B0%E9%93%81%E8%87%AA%E5%8A%A8%E5%94%AE%E7%A5%A8%E7%B3%BB%E7%BB%9F.html</url>
    <content type="text"><![CDATA[前言众所周知，期末考试周结束后，迎来的不是荒淫放荡的暑假生活，而是依旧忙碌的小学期。小学期的第一周，全是高级语言设计课。说是上课，其实除了第一天讲了一天的软件工程之外，剩下四天全都是搬着笔记本待在教室里敲代码。为了提供笔记本的电源，助教还得向物业借许多排插。不是很明白为什么非得在教室敲，只要作业完成了在哪里其实都一样吧。题目有两个，我的题目是模拟地铁自动售票系统，另一个是职工档案管理系统。第二个有点像是大一上C语言实验课做的学生成绩管理系统，不过要比那个多很多功能。两个题目都需要做用户交互界面。我选到第一个还是比较幸运的，因为第一个核心代码并不是特别的多，主要程序还是在界面设计上，至少对我来说是这样的。而第二个题目之前也做过类似的，感觉并不能学到什么比较新的东西。这一周感觉大部分时间都在各种乱七八糟的事情上折腾，像是安装图形库，配置sublime，设计交互界面之类的，作业一拖再拖，直到第一周周日才做好。第二周又马上要开始认知实习课程，前四天一天到晚就要往外跑，参观各种企业。加上社团的项目，robomaster的选拔培训，之类的，实验报告到周四才完成。到周五认知实习答辩结束，原以为可以休息一阵子，谁想突然又说这门课也要答辩，报告也需要修改。周末写了几篇博文，再把PPT做好，就过去了。报告是懒得改了……原先是这么想的，结果呢，终究还是逃不过去，答辩结束后还是要修改。好在这次比起之前要求修改多了一些要求，好下手。说真的，每每想到这门课只有一个学分，而且还不是考察课，我总有一种随便做做就算了的想法。这一而再再而三的要求也着实令人厌烦，只想快点结束。若不是真的学到了一些东西，我必定不会写这篇博文。时到如今，多说也无益了。 任务概述设计一个具有购买车票、地图查询、系统说明、退出等功能的模拟地铁自动售票的系统。系统要求具有欢迎界面，界面显示作者信息和版权信息。进入系统主菜单后提供购票选项、地图查询选项、系统说明、退出系统四个选项。系统说明界面详细的介绍了购票流程，并且附有用户须知。购票系统实现通过键盘输入起止站和票价，并且以此计算阶梯票价。根据系统提示进入投币找币流程，购票成功后返回欢迎界面。查询系统通过输入站台编号查询站台信息。查询成功后可选择继续查询、购票或是返回。 运行环境操作系统：Windows7开发环境：codeblocks+EGE图形库 系统设计总体架构设计整个系统分为地图查询系统和购买车票系统。由于代码比较多，我将其分写到mian.cpp、map.cpp、data.cpp、sold.cpp、Welcome.cpp、Index.cpp、description.cpp共七个cpp文件中。然后新建了一个名为”kxj.h”的头文件，在里面声明多个文件共用的函数，结构体以及外部变量。其中每个文件的作用如下：Welcome.cpp：绘制欢迎界面。Index.cpp：绘制系统主菜单界面。description.cpp：绘制系统说明界面。data.cpp：地铁信息初始化。Map.cpp：绘制地图查询界面，以及实现查询地图的功能。Sold.cpp：绘制购买车票界面，以及实现输入起止站和车票数与投币功能。Main.cpp：调用各个功能以及界面，并提供主界面的按钮点击功能。 模块分析与设计头文件 公用函数分析 123456789void DrawOpt(int x,int y,int w,int h,int fnum,int fh,char optTitle[]);//绘制按钮键。void Title();//标题void Copyright();//版权信息，每一页的标配bool checkClick(int *x,int *y);//检测是否有点击，并且获取点击的位置void Init();//初始化页面，使之清空，并且有标题与版权信息void textBox(int x,int y,int w,int h,int r);//绘制输入框int Input(int x,int y,int n,int fh,int (*click)(int x,int y));//在某输入框内输入。每次循环同时检测鼠标消息与键盘消息，确保键盘与鼠标都能够实现所需效果。void Delete(int x,int y,int w,int h);//使某一矩形变成背景色，实现删除效果bool checkIn(int mx,int my,int x,int y,int w,int h);//检测点击位置是否在某处 结构体STA是站台信息的存储类型，数组下标就是编号 123456struct STA&#123; string name;//站点名称 int line;//站点路线 string pre;//上一站名称 string nxt;//下一站名称&#125;; 地铁信息初始化通过循环将站台信息整合到结构体STA数组中，数组下标即为编号。换乘点拥有多个编号，不同线路上编号不同。将八条线路图建成无向连通图。其中每一个编号视为一个点。一条线路上相邻两站之间连通，距离直接打表写入文件。换乘点不同编号之间距离为零。不连通的点之间距离为oo（1000000007）。1234567891011121314151617181920212223void Query_same(int x)&#123; for(int i=1;i&lt;=number;i++)&#123; if(station[i].name==station[x].name)mp[x][i]=0; &#125;&#125;void data()&#123; for(int i=0;i&lt;=7;i++)&#123; for(int j=0;j&lt;sta_num[i];j++)&#123; number++; station[number]=(STA)&#123;sta_name[i][j],i+1&#125;; station[number].pre=j?sta_name[i][0]+"方向："+sta_name[i][j-1]:"此站为终点站"; station[number].nxt=j&lt;sta_num[i]-1?sta_name[i][sta_num[i]-1]+"方向："+sta_name[i][j+1]:"此站为终点站"; if(j)mp[number][number-1]=dismp[i][j-1]; if(j&lt;sta_num[i]-1)mp[number][number+1]=dismp[i][j]; &#125; &#125; for(int i=1;i&lt;=number;i++)&#123; for(int j=1;j&lt;=number;j++)&#123; if(!mp[i][j])mp[i][j]=oo; &#125; Query_same(i); &#125;&#125; 欢迎界面，系统主菜单以及系统说明界面通过EGE图形库的库函数设计。官方文档 地图查询系统通过EGE图形库中的库函数完成交互界面。查询站台时，先检测所查询编号是否合理，然后通过暴力查询，遍历每个站台，寻找所有站台名称相等的元素，加入到Line数组中，最后输出。查询的代码如下：12345678910111213141516171819202122232425void Query(int num)&#123; for(int i=1;num&lt;=number&amp;&amp;i&lt;=number;i++)&#123; if(station[num].name==station[i].name)&#123; Line[cnt++]=station[i]; &#125; &#125; InitMap(); setfont(20,0,"微软雅黑"); if(!cnt)outtextxy(WIDTH-200,30,"对不起，您查询的站点并不存在！"); else &#123; char * name=(char*)("站名："+Line[0].name).c_str(); outtextrect(WIDTH-200,30,100,20,name); outtextxy(WIDTH-200,60,"所在线路："); while(cnt--)&#123; xyprintf(WIDTH-200,90+cnt*120,"%d号线",Line[cnt].line); xyprintf(WIDTH-200,120+cnt*120,"下一站："); name=(char*)Line[cnt].pre.data(); xyprintf(WIDTH-200,150+cnt*120,name); name=(char*)Line[cnt].nxt.data(); xyprintf(WIDTH-200,180+cnt*120,name); &#125; delay_fps(60); cnt=0; &#125;&#125; 购买车票系统通过EGE库函数完成交互界面，实现输入功能。计算阶梯票价时，先用无优化的最短路径dijstra算法计算出两者间的最短路径，然后将路径向上取整，根据规则计算出单价。计算票价的代码如下：12345678910111213141516171819202122void calcLine()&#123;//dijkstra计算最短路 for(int i=1;i&lt;=number;i++)dis[i]=oo,mark[i]=0;//初始化 dis[startStation]=0; for(int i=1;i&lt;=number;i++)&#123; int mi=oo,k=-1; for(int j=1;j&lt;=number;j++)&#123; if(!mark[j]&amp;&amp;dis[j]&lt;mi)&#123; mi=dis[j]; k=j; &#125; &#125; if(k==-1)return ; mark[k]=1; for(int j=1;j&lt;=number;j++)&#123; if(!mark[j]&amp;&amp;dis[j]&gt;dis[k]+mp[k][j])&#123; dis[j]=dis[k]+mp[k][j]; &#125; &#125; &#125; price=calc(ceil(dis[endStation]));//calc是计算票价 return ;&#125; 系统主菜单初始化窗口。用EGE的库函数完成交互功能。点击“地图查询”“购买车票”“系统说明”直接调用相关函数。点击“退出系统”时则退出循环。123456789101112131415161718192021222324252627int main()&#123; initgraph(WIDTH,HEIGHT);//初始化窗口 data();//站点信息初始化 //欢迎界面，任意键继续 Welcome(); int num=0; for ( ; is_run(); delay_fps(60)) //while(1) &#123; //系统说明界面，任意键继续 //description(); //显示主界面 Index(); delay_fps(60); int x,y; xyprintf(0,0,"%d",num++); while(!checkClick(&amp;x,&amp;y));//getch(); if(checkIn(x,y,(WIDTH-160)/2, 100, 160, 50))sold();//购买车票 else if(checkIn(x,y,(WIDTH-160)/2, 180, 160, 50))Map();//查询地图 else if(checkIn(x,y,(WIDTH-160)/2, 260, 160, 50))description();//说明介绍 else if(checkIn(x,y,(WIDTH-160)/2, 340, 160, 50))break;//退出系统 &#125; closegraph(); return 0;&#125; 软件结构（流程图） 调试过程我首先编写完系统的核心代码，如地图查询与购买车票。这一块没有遇到太大的问题。改正几处简单的错误之后，便通过了测试。接下来我开始绘制图形界面。按钮、输入框、文字等只需要稍微计算一下便能够符合我的预期。较为困难的是用户交互机制的设计。我先是设计键盘交互的部分，这一块较为简单。也没有需要调试的地方。但是当我加入鼠标交互功能是，却遇到了难题：当用户输入的时候，无法通过鼠标点击相应按钮实现功能。必须等到输入结束之后才能实现鼠标点击。而且需要鼠标点击的阶段也无法通过键盘操作。即无法同时用鼠标和键盘进行操作。为了解决这一问题，我在需要用户操作的阶段设置了一个while(1)循环，里面先检测是否有键盘消息，如果没有再检测是否有鼠标消息。通过这样类似于多线程的方法，系统可以实现同时通过鼠标和键盘操作，代码如下：1234567891011while(1)&#123; if(kbhit())&#123; char k=getch(); if(k=='\r')break;//确定 &#125; int x,y; if(checkClick(&amp;x,&amp;y))&#123; if(checkIn(x,y,WIDTH/2-210, HEIGHT-340, 160, 50))break;//确定 if(checkIn(x,y,WIDTH/2+50, HEIGHT-340, 160, 50))return 0;//返回 &#125;&#125; 但是此时又造成了另一个问题——页面无法及时的更新。在之前的代码中，程序只有到getch()，即等待用户按键的时候，才会更新页面。原先因为只有键盘输入所以不会造成影响。而如今只有检测到键盘消息，才读取键盘操作，导致页面无法及时更新。思考片刻后，我认为系统只有等待的时候才会更新界面，所以我在每一处改变页面的代码之后加了delay_fps(60)延时函数。正如我猜想，加入延时函数之后，问题成功解决。 测试结果 进入系统后，显示欢迎界面： 按任意键进入系统主菜单，点击对应按钮进入对应的功能界面。 进入购买车票的界面后，出现起止站的输入框。首先通过键盘输入起始站，将在输入框中出现相应字符。最多输入3个字符，而且必须是数字。点击确定或者按下回车键后，可以在目的地的输入框中输入。点击刷新按钮后可以从起始站重新输入。点击返回或者按下esc键将回到主界面。起止站输入完成后，点击确定键或者回车键，如果站台编号符合要求将进入输入票数的界面。若是不符合将被要求重新输入站台编号。 输入票数的界面中，标题下方显示两个站点之间最短距离的票价。再下面是询问购买的票数，可通过键盘输入数字字符，最多可输入一个字符。点击返回或者按下esc键回到上一界面。点击确定或者按下回车键进入下一界面。 显示总价格，并且最后询问是否购买车票。点击返回或者按下esc键回到上一界面。点击确定或者按下回车键进入下一界面。 投币界面中标题下方出现提示。按数字键可以在界面右下方的输入框中输入数字字符，最多可输入两个字符。点击确定或者回车键，如果投入的钱币小于总价格，则显示“钱币不足，请再次投币”。直到投入钱币总和大于等于总价格，到下一界面。 购买成功后，显示信息与提示，按任意键返回主界面。 进入地图查询界面后，显示地铁线路图，并且在线路图下方有输入框，可以输入站点编号。只能输入数字，且最多三个字符。点击查询可以在线路图右侧显示查询的地图信息。在屏幕右下方出现“继续查询”与“购票”按钮。点击“继续查询”，可以继续输入站点编码。点击“购票”按钮直接进入购票界面。点击返回或者按下esc键返回系统主界面。 系统说明界面显示购票流程与用户须知，按任意键返回系统主界面。 问题 无法输入中文字符。EGE自带的键盘输入字符函数是直接从读取按下的键盘按键，所以无法从输入法输入中文。唯一的解决方法是通inputbox_getline()函数，用对话框让用户输入一个字符串。但是因为对话框样式风格与系统界面不符，也没有找到改变对话框样式的方法，所以没有通过输入站台名称查询站台信息的功能。 没能清空鼠标缓存消息。不过好在这一点因为点击之后能够马上切换到新的界面，所以没有构成什么问题。 可提升空间 当鼠标移到或点击按钮时，出现动画。 输入站名查询站点信息。 提供点击站点即可查询信息的功能。 分析总结与心得体会本次程序设计，不仅让我复习巩固了许久未用的最短路径算法，并且让我熟悉了使用库函数设计用户交互界面。而且将代码写在不同文件中，自己写一个头文件也是第一次尝试。虽然在新事物上折腾了很多时间，但结果还是非常令人满意的。经过此次课程，我的确获得了极大的进步。]]></content>
      <categories>
        <category>计算机</category>
        <category>程序</category>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>dijkstra</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于Codeblocks下安装EGE图形库这件事]]></title>
    <url>%2F%E5%85%B3%E4%BA%8ECodeblocks%E4%B8%8B%E5%AE%89%E8%A3%85EGE%E5%9B%BE%E5%BD%A2%E5%BA%93%E8%BF%99%E4%BB%B6%E4%BA%8B.html</url>
    <content type="text"><![CDATA[前言估计大部分需要学习C/C++语言的大学生都会被要求用该语言设计小游戏或者某某系统，然后就需要用到C++专有的图形库来设计人机交互界面。Windows下有许多图形库供我们选择，其中比较出名的就是EasyX。不过EasyX只适用于VC6或者VS系列的开发环境。由于懒得下载VS，又不适应VC6那古老的界面，所以我不打算用EasyX。在Windows环境中，我一般使用sublime text3编辑代码。可惜的是，我找寻了老长时间，也未曾找到可以在该编辑器中使用图形库的方法。因此，我打算使用原先便已安装的Codeblocks。在Codeblocks开发环境下，我使用的是EGE这种轻量级的图形库。虽然依旧为安装花费了半天时间，但最终结果也算是圆满的。 准备工具Codeblocks：最好安装最新版本。EGE：我使用的是15.0.4版本，更高级的版本我实在用不来。反正我也不打算再用这玩意做图形界面了，就凑和着用。 安装流程 找到Codeblock的文件夹，打开其中的MinGW文件夹 将下载下来的EGE压缩包解压后，打开文件夹。 打开include文件夹,将里面的东西复制到之前打开的MinGW文件夹中的include文件夹里 打开lib文件夹，选择mingw4.8.1，将里面lib文件夹里的东西复制到MinGW文件夹中的lib中。 打开codeblocks，新建一个项目，点击Project-&gt;Build options-&gt;Linker settings。在Link libraries中点击Add，选择添加文件的图标。进入MinGW下lib文件夹，寻找以下一系列文件”libgraphics.a””libgdi32.a” “libimm32.a” “libmsimg32.a””libole32.a” “liboleaut32.a” “libwinmm.a””libuuid.a”，可以直接全部粘贴上去，系统会自动生成路径。然后在右边Other linker options中写上-mwindows。点击ok完成。以上，EGE配置完成。之后你只要在敲代码是写上#include&lt;graphics.h&gt;就能使用图形库了。 注意事项 上述方法仅适用于当前设置的项目。如果要有新建了一个项目，要使用EGE图形库的话，需要再次进行第五步的配置。 如果觉得每次都设置很麻烦，可以自己新建一个模板，以后使用EGE的时候直接调用模板即可。新建模板的方法点此。 使用时可能会遇到中文乱码的问题，可以自己去网上找解决方案，我也是糊里糊涂才调好的。 设置完成后，该项目就变成了绘图模式。在该模式下寻常的输入输出是无法在终端中显示的，无论是否调用了#include&lt;graphics.h&gt;头文件。这也是为什么我们不选择一劳永逸的配置方法。]]></content>
      <categories>
        <category>教程</category>
      </categories>
      <tags>
        <tag>教程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于使用sublime-text3编译C++程序这件事]]></title>
    <url>%2F%E5%85%B3%E4%BA%8E%E4%BD%BF%E7%94%A8sublime-text3%E7%BC%96%E8%AF%91C%2B%2B%E7%A8%8B%E5%BA%8F%E8%BF%99%E4%BB%B6%E4%BA%8B.html</url>
    <content type="text"><![CDATA[前言在Windows环境下，我比较喜欢使用sublime-text3作为代码编辑器。界面简洁舒适，敲代码的体验也非常好。不过平时用sublime写写js还好，想要编译C++的话，就需要自己手动配置。配置的教程其实网上很多，也说的很明白。不过网上大部分的方法都有一点小问题，那就是无法用scanf或者cin输入，只能显示输出结果。因为它并没有调用终端，直接在底栏输出。好在上周写作业的时候，偶然在网上找到了一份有效的教程，或者说有效的代码，能够调用系统终端运行程序。教程如下。 教程 想要编译C++程序，必须要有编译器，像是gcc和g++。如果你的电脑上有可以编译C++的软件，像是C-free、dev-c、codeblocks、vs之类的，那么软件的文件中肯定有编译器。如果你的电脑上没有这些，那要么从网上下载一种C++编译软件，要么直接去下载MinGW。 右键我的电脑-&gt;属性-&gt;高级系统设置-&gt;高级-&gt;环境变量，在用户变量或者系统变量（两者都行，具体区别自行百度）中找到path，点击编辑，将你编译器所在的文件夹路径添加上去，然后点击确定。 环境变量设置完成后，打开sublime，新建编译系统。由于我的sublime是汉化过的，所以选项是工具-&gt;编译系统-&gt;新建编译系统。 将下面的代码复制粘贴到配置文件后保存，保存到的文件夹不要改动。 1234567891011121314151617&#123; &quot;cmd&quot;: [&quot;g++&quot;, &quot;$&#123;file&#125;&quot;, &quot;-fexec-charset=gbk&quot;, &quot;-o&quot;, &quot;$&#123;file_path&#125;/$&#123;file_base_name&#125;&quot;], &quot;file_regex&quot;: &quot;^(..[^:]*):([0-9]+):?([0-9]+)?:? (.*)$&quot;, &quot;working_dir&quot;: &quot;$&#123;file_path&#125;&quot;, &quot;selector&quot;: &quot;source.c, source.c++&quot;, &quot;variants&quot;: [ &#123; &quot;name&quot;: &quot;Run&quot;, &quot;cmd&quot;: [&quot;cmd&quot;, &quot;/c&quot;, &quot;g++&quot;, &quot;$&#123;file&#125;&quot;, &quot;-o&quot;, &quot;$&#123;file_path&#125;/$&#123;file_base_name&#125;&quot;, &quot;&amp;&amp;&quot;, &quot;cmd&quot;, &quot;/c&quot;, &quot;$&#123;file_path&#125;/$&#123;file_base_name&#125;&quot;] &#125;, &#123; &quot;name&quot;: &quot;RunInCommand&quot;, &quot;cmd&quot;: [&quot;cmd&quot;, &quot;/c&quot;, &quot;g++&quot;, &quot;$&#123;file&#125;&quot;, &quot;-o&quot;, &quot;$&#123;file_path&#125;/$&#123;file_base_name&#125;&quot;, &quot;&amp;&amp;&quot;, &quot;start&quot;, &quot;cmd&quot;, &quot;/c&quot;, &quot;$&#123;file_path&#125;/$&#123;file_base_name&#125; &amp; pause&quot;] &#125; ]&#125; 这一步是关键一步，也是不同教程中不同的一步。 如此一来就配置好了，写一份C++代码，按shift+ctrl+b，选择RunIncmd那一项就可以了。以后编译也只用按ctrl+b。当然，你想的话也可以自己设置热键。]]></content>
      <categories>
        <category>教程</category>
      </categories>
      <tags>
        <tag>教程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[日渐颓废的平凡之路]]></title>
    <url>%2F%E6%97%A5%E6%B8%90%E9%A2%93%E5%BA%9F%E7%9A%84%E5%B9%B3%E5%87%A1%E4%B9%8B%E8%B7%AF.html</url>
    <content type="text"><![CDATA[高代考试的那天，正值夏至。从那天起，白昼开始缩短，黑夜将逐渐变得漫长。就如同我的高等代数试卷被交上去地那一刻，一个学期结束，新的学期将至。 复(yu)习高代，我只用了一天时间。上午我还能将书上的课后习题一道一道地看过去，脑中想想解决方法，再看一眼答案验证思路。到了下午，一觉醒来之后突然就没了学习的热情，和室友有一搭没一搭地聊着，复习进度龟速前进。好在考试前也完成了复习任务，怀着表面自信，内心慌张地态度踏进考场，开始我的最后一门考试。其实不只是高等代数，像是之前的数学分析和大学物理，我也只在上面投入一两天的时间，而语文英语之流甚至片刻未学。并非我过于自信，不屑于这些考试，事实上这些课我学得都不是特别扎实，听课效率低到令人叹息。这笔记基本也没怎么做，后期全靠导图支撑。然而导图还是比较适合复习阶段，在学习方面并无太大作用。我之所以这么跳，除了考试周考试频率高外，大部分原因还是我的自控力太差，难以长时间专心致志地投入到枯燥的复习当中(或许有女朋友一起复习会比较有趣，然而我并没有)。或许正是因为复习的时候很颓废，所以考试周结束后并没有解放的感觉吧。 其实我的颓废也并非一日两日的事，而是从这个学期初便早有迹象。 暂且不谈上课的时候日常走神，本身投入到学业中的时间就很少。除了考试周之外，也只有自习课才会写一会作业。原本打算语文课上看书，英语课上看英文版的《傲慢与偏见》的计划也基本上没完成过，反倒是在知乎的碎片化阅读与爽文类的漫画中浪费了大把时间。前些天的六级让我意识到自己的英语已经退步到一种可悲的境地，甚至连初中时代都难以企及。至于大一的项目，磕磕绊绊，进度缓慢，一开始的方案也被推翻。前路迷茫，有时根本不知道该如何是好。自己的信心也在这一次一次的挫折前消磨，只想着早些结束。 最为颓废的是，曾经自诩为从不玩游戏的我也掉进了游戏的坑洞。最初接触游戏其实只是因为自己加入了社团里的游戏项目组，偶尔会接一些谜题设计的任务。不过那时候只是作为一个单纯的云玩家，在B站上云游戏视频。由于undertale、女神异闻录5、风之旅人这些剧情经常或是理念绝佳的游戏，让我对游戏的观念大大改变，可还是很少自己亲自玩游戏。主要还是觉得自己手残，而且没钱买正版和主机。一次偶然的机会，我在一家微信公众号上被推荐了一个游戏网站。该网站上都是从红白机上移植到PC上的经典街机游戏，像马里奥、魂斗罗之类的。因《高分少女》的影响，我对上个世纪的街机游戏黄金时代充满了好奇，所以不由自主地点了进去。不过很可惜，网站上大多都是战斗类游戏，正是我最不擅长且最无兴趣的种类，因而一两天就厌弃了。不过从那时起，我开始玩的游戏也越来越多：扫雷，俄罗斯方块、Nazo解谜网站、密室逃脱类游戏、仙剑奇侠传一、植物大战僵尸，deemo……不得不承认，我对游戏因此加深不少，甚至有以后干脆进入游戏行业的念头，但是耗费的时间还是颇让人吃惊。好在贫穷和电脑配置阻止了我痴迷游戏，止步于极少数优质的免费游戏。而由于四月份加入了桌游社，也有机会接触这个我一直以来都想加入的圈子。虽然到目前为止，也就只参与了两次活动，不过在社里的两位大佬的带领下，我也玩了不少从前前所未闻的游戏，像是烧脑的《推翻苏丹》《犯罪现场》，克苏鲁风格的跑团桌游《诡镇奇谈》《疯狂诡宅》，而我自己也购买了两款轻松简单的卡牌游戏《UNO》《爆炸猫咪》。我有种预感，或许将来我会有一大笔消费花在购买桌游上面呢。不过那些大桌游，动辄便是三四百，恐怕还得好好斟酌一二。 比起玩游戏，对于游戏的解构更让我感兴趣。像是游戏的核心机制，游戏的风格，游戏元素的组合……其主要原因还是我现在正在做游戏。当然，我说的不只是社团里的那个解谜RPG类游戏，还有另外一个基于前端语言的网页游戏。该游戏是我在六月初突发灵感且脑洞大开产生的，目前也只处在大纲设计完成，刚刚开始写HTML的阶段。我是打算将这个游戏作为我学习前端的一个项目来做。我是从这学期开始才打算学习前端的。最初不过是从github上找一些前端小项目，一边读着代码一边实现效果。这样虽然能学会很多，但并没发真正转变为自己的知识。后来又注册codewars，在上面刷了十来道js的题目，但效果依旧有限。想来想去，还是自己动手写项目会好一些，可惜并没有特别有兴趣的想法。直到这个游戏的构思诞生，我对学习前端有出现了动力，打算在此路上渐行渐远。 虽然感觉这学期事情不少，但实际上却觉得非常水。学习学得一般般，项目的进度缓慢无比，社团游戏没做多少，前端也没学到什么，还将一大堆时间浪费到碎片化阅读和游戏中……当真是日渐颓废。唯一比上学期有进步的大概就属小说写作。这大抵要归功于创意写作课和友人的激励。为了累积灵感，我还特意买了许多小本子随身携带，一有灵感就及时记录。不过说到底，我也只不过写了两篇，其中一篇还只是练笔。我真的担心自己对于写小说的热情会逐渐被繁重的事务所淹没，从而遗忘自己的初心。世上众人大多有志，却只有堪堪数人得以实现，着实令我焦虑。 不管怎么说，夏至已过，我的春季学期也随之结束。本学期的成绩还算平庸，门门八十几，既没有挂科，也没有很优秀。作为如此浪荡的复习结果，我已经是非常满意的了。愿来日漫长，岁月静好，路漫漫其修远兮，吾将上下而求索。 PS：以下是这几门的思维导图，不多，且不全，自取。 点击下载还有那个红白机网站点此穿越上世纪以下是nazo解谜网站，有兴趣可以试一试，反正我到第三十四关玩不下去了。顺便一说，这个不让写攻略。点此烧脑]]></content>
      <categories>
        <category>杂</category>
      </categories>
      <tags>
        <tag>杂</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【练笔】家有史莱姆]]></title>
    <url>%2F%E3%80%90%E7%BB%83%E7%AC%94%E3%80%91%E5%AE%B6%E6%9C%89%E5%8F%B2%E8%8E%B1%E5%A7%86.html</url>
    <content type="text"><![CDATA[“哇，好可爱的荧光兔！”“这就是植入荧光基因的新品种吗，好漂亮的孩子！”“软乎乎的，毛茸茸的，真想吸一辈子！”“下班后，我也要去萌即正义旗舰店买一只回来！”……不远处充满兴奋的讨论声使得木友人有些心烦意乱，原本就很疲惫的他难以专心地继续调式bug。他那熊猫般的双眼略带不满地投向噪音的源头——几个女同事围绕着一只浑身散发着蓝色荧光的兔子像麻雀般叽叽喳喳个不停。而那只作为罪魁祸首的兔子正毫无自觉地趴在桌子上享受着女同事们的抚摸。“女孩子向来对可爱的事物没有抵抗力，不是吗？”一旁的同事无精打采地以龟速敲打着键盘，显然也被那恼人的吵闹声影响到了。“嘛，虽然那只兔子是挺可爱的。”木友人对这个话题并没有太大的兴趣，只是随便回应了一句表示赞同对方的话语。“其实呢，我也挺想养只宠物的，”可惜无心工作的同事并没有打算放过这个话题，“像猫啊，狗啊之类的，每天回到家抱起来吸几口，治愈一下都市人疲惫的心灵。可恶，好羡慕！”“等你回家的时候，你家宠物估计都躺在窝中做着美梦呢……”木友人吐槽道。“……说的也是，这该死的工作什么时候能结束啊！”同事双手胡乱揉了揉头发，然后一脸颓废地将头垂在桌上。忽然同事侧过头望向木友人问道，“话说，你有养宠物吗？”“没……”刚想否认的木友人突然想起了什么，改口道：“我好像养了一只……虽然不知道是不是还活着……”“突然有些同情你家宠物了……你养的啥？”“史莱姆。”同事眨了眨眼睛，“史莱姆？”木友人点了点头。“生物清道夫有线公司买的那种？”“我可买不起高级品种。”木友人一边敲着代码，一边缓缓说道，“只是因为我每天下班回家太晚，没时间打扫房间，这才去店里买了只史莱姆回来。之后也就完全没管它了。毕竟房间天天都需要清理，饿不死它。大概。”“你这根本就不算是宠物吧，完全是当仆人来用的吧。”同事有些无奈地叹了口气，然后靠在椅背上，用手指按摩着自己的鼻梁，“我敢说你连名字都没给它取。”木友人沉默地看着电脑屏幕，并没有反驳同事。说到底他的确只是把那只史莱姆当做家用清理机器人来用，而且关于史莱姆这种人造产品能否真的作为一个生命来看待也是个迷。 回到家的时候已经是第二天凌晨一两点钟，房间里寂静无声，漆黑一片。这几天连着加班，无论是身体还是心灵都早已疲惫不堪，所幸今天拼了老命终于完成了手头的工作，明天周日也能够稍微休息休息。想到此处，木友人顿时觉得生活充满了希望，眼前无尽的黑暗中仿佛出现了一点荧光，然后一阵晕眩袭来，整个人瘫倒在某种软乎乎的凉丝丝的事物上，疲惫感如潮水般将他淹没，陷入了香甜的睡梦之中。 再次从慵懒的睡梦中醒来时，木友人眼中是自己熟悉中待着陌生的卧室。他这一觉睡了足有十来个小时，温暖的阳光已将卧室照得通明。他感到自己怀里似乎有什么软乎乎的东西，惺忪的睡眼低头一看，那是一个光溜溜的富有弹性的半固态流体，在明亮的阳光照射下呈现出透明的淡蓝色。流体中间有一颗拳头大小的透明圆球，缓慢而安稳地跳动着。毫无疑问，这是他的史莱姆。史莱姆是不需要睡眠的。作为人造生物，人类只赋予了它清理污渍的使命。估计是感受到他几天没有洗澡，身上全是脏东西才依靠本能靠过来的。木友人苦笑着伸了个懒腰，决定先去洗个澡，然后开始他美好且轻松的假日时光。似乎是感到自己的主人已经苏醒，史莱姆一蹦一蹦地来到阳台上，在明亮的阳光下缩成一个水珠状的椭球。借助太阳光，史莱姆正在消化积攒在它体内的污渍。若有若无的气体在如同蓝宝石般光滑的表面上飘动着，甚是漂亮。洗完澡出来后，史莱姆的的踪影已消失不见了。想来是消化完成，跑去清理屋子里。木友人也没放在心上，穿上松松垮垮的家居服，便走到零食柜前，打算拿上几包零食去客厅打游戏。可惜计划赶不上变化，木友人看着空空如也的柜子，心里疑惑着自己前不久刚买的零食怎么那么快就吃完了，感觉他平时好像也没吃多少。想来想去，也只能把锅扣到繁忙的加班让他变得有些健忘。在网上购入了一箱新零食后，木友人走到客厅里以最舒服最慵懒的姿势陷入柔软的沙发上，打开电视播放起这个季度的新番。这部新番倒也不是那么精彩，不过是一群人嘻嘻哈哈的日常生活，但对于身心俱疲的木友人来说却是极佳的疗品。相比之下，那些精彩万分，富有深度的动画却渐渐很难吸引他的兴趣了，毕竟作为休息的假日时光他可不想在调动自己的脑袋。正当他津津有味地看着动画时，他家的史莱姆君不知何时也坐到了沙发上，就像是在同他一起观看这部动画。木友人的注意力瞬间被这个有趣的小家伙吸引住了。只见他那颗圆润的核心以一种欢快轻松的跃动着，蓝色透明的流体时不时地荡起一阵不规律的涟漪，仿佛是因为有趣的剧情而发笑。史莱姆也会看动画吗？这种事情倒是第一次听说，不，倒不如说他从来就没有关心过自家的史莱姆。正如他同事所说的那样，他连名字都没给它取。突然，某样东西让他瞪大了眼睛——那是一片黄灿灿的薄薄的像是薯片的东西。观察了足足五秒后，他无比确信地把“像是”二字去掉了。这就是一片薯片。待到那片薯片逐渐溶解在那透明的液体中，一只蓝色的触手从史莱姆身上伸了出来，伸向玻璃茶几上的一包不知何时出现的开封的薯片袋，卷起一片薯片后猛地缩回体内。整套动作行云流水，流畅无比，让人难以置信。木友人吃惊地看着自家史莱姆，一个大胆的想法逐渐在他脑海中成型。“我说，”木友人用手扭着史莱姆富有弹性的身体向两边拉扯，后者立刻变成了一个可笑的形状，“我的零食不会都是被你偷吃光的吧！”“您好，您的快递已送达，快递员正在门口等候。”此时手机一阵振动，传来了优雅悦耳的女声。木友人只得暂时松开自己的双手，起身走到门口取快递。“好嘞，现在没有人打扰了，我的死宅生活正式开启！”木友人将零食箱放在客厅的地上，从电视底下拿出尘封……已久的游戏手柄？木友人看着手上光滑干净如同新品的游戏机，若不是上面有许多划痕之类的痕迹，他真的很怀疑这是不是自己的手柄。木友人回头望了一眼沙发上若无其事地“吃”薯片的史莱姆，然后猛地甩了甩头，拍了拍自己的脸颊：“说不定只是它经常清理过……”话音未落，便见听见一阵熟悉的音乐响起，吓得他赶忙向后退了几步，却看见自家史莱姆不知何时来到了电视机前，像个老司机般熟练地连接手柄，选择游戏，点击开始，然后在富有节奏感的背景音乐声中，淡蓝柔软的触手在黑色的手柄上快速地按动，控制着屏幕上的游戏角色在华丽炫目的弹幕中穿梭，杀怪，闯关……那模样，完全不像是一个智能有限，只会清理的人造生物，而像是一个拥有多年玩游戏经验的老手，在自己的领域中叱咤风云。“这……这家伙不会趁我不在家的时候把我的游戏都玩了一遍吧！”由于眼前的事实过于令人震惊，木友人呆呆站在原地，顿时有些不知所措。回想起刚刚自家史莱姆看动画，吃薯片的场景，木友人觉得自己完全小瞧了眼前这个花一千块钱买来的小家伙。自从买到家里已经有半年多了，这期间木友人回家的次数屈指可数，而且每次都是疲惫地到头就睡，一觉睡到天明后又匆匆忙忙地感到公司，对这家伙算是完全不了解。原以为不过是只是打扫房间的清道夫，却万万没想到竟成长为一个连他都比不过的老司机。说不定，每天都宅在家中看动画，玩游戏，吃零食，过着令人羡慕，呸，无比堕落的宅男生活……正当木友人沉浸在自己杂乱忽然他感到脚踝处传来一阵冰冰凉凉的触感，下意识地低头一看，是自家史莱姆的触手。木友人疑惑地望着史莱姆，然后似乎明白了些什么地看了一眼屏幕。屏幕上是双人模式中选择角色的界面，其中一方已经选定，而另一方则迟迟未动。史莱姆安静地持着游戏手柄，仿佛，不，就是在等待着木友人选择角色。原先脸上阴晴不定的木友人愣了愣，不由自主地发出奇怪地笑声，脑中乱七八糟的想法全都烟消云散。“算了，难得的休息日，不想那么多了。”他深深地吸了一口气，决定放弃了思考，认命般地盘腿坐下，拿着手柄开始挑选角色。“你是想和我一起玩一局吗？”“……”“事先说明，我可是人称独孤求败的游戏小王子。”“……”“让你见识见识我的厉害，emmm……就叫你波奇好了！”“……”“波奇，看招……” 其实这一篇是十天前就已经完成的练笔，只不过今天才有时间发布到博客上。关于这篇练笔的题目来源于创意写作书系中《开始写吧！虚构文学创作》中的第三篇《我的宠物》。由于我这人没有幻想元素的故事完全没有兴趣写，所以宠物从一开始就设定成现实世界中没有的动物。最初我是打算写玄武型宠物机器人的，一种好养又宅的宠物。与此对应，它的主人则是一个被996的生活压迫着的社畜，虽然内心是一个喜欢看动画玩游戏宅在家中不动弹的宅男，但却被繁重的工作所压迫连续好几天都没有回家。后来玄武机器人改成了史莱姆，其他设定却没怎么改。毕竟软萌软萌的史莱姆配上死宅的生活方式，感觉会很有趣呢。然而，这篇文章前面写的时候还行，到了最后却明显地感到后劲不足，像是主人公内心的转变就完全没有写到位。如今，虽然对此略加修改，加了一些心理活动，却依旧感到不尽如人意。看来还是自身修炼未曾达标。]]></content>
      <categories>
        <category>我的小说</category>
        <category>练笔</category>
      </categories>
      <tags>
        <tag>我的小说</tag>
        <tag>练笔</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[用键盘控制图标移动]]></title>
    <url>%2F%E7%94%A8%E9%94%AE%E7%9B%98%E6%8E%A7%E5%88%B6%E5%9B%BE%E6%A0%87%E7%A7%BB%E5%8A%A8.html</url>
    <content type="text"><![CDATA[之前几个小项目，我都是照着代码敲下来。但是发现这样的效果并不是特别好，所以这个项目我改变了策略，打算先看懂代码，然后再自己手敲。这份代码我一直想读一读，读下来之后也发现不是特别的困难，也没有什么特别重要的新知识。点此体验代码并没有什么地方需要解释的，就直接呈出来了。 HTML123456789101112&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta http-equiv="Content-Type" content="text/html; charset=utf-8" /&gt; &lt;title&gt;键盘控制图标&lt;/title&gt; &lt;link rel="stylesheet" href="keyScrollball.css"/&gt; &lt;script src="keyScrollball.js"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id="box"&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; CSS123456789101112@charset "utf-8";body&#123; background:#CCC;&#125;div&#123; width:60px; height:60px; background:brown; position:absolute; /*属性允许向元素添加圆角*/ border-radius:30px;&#125; JAVASCRIPT12345678910111213141516171819202122232425262728293031323334353637383940window.onload=function()&#123; var box=document.getElementById("box"); //网页可见区域宽，兼容各种浏览器 var MapWidth=document.body.clientWidth||document.documentElement.clientWidth; //网页可见区域高，兼容各种浏览器 var MapHeight=document.body.clientHeight||document.documentElement.clientHeight; var timer=null; document.onkeydown=function(ev)&#123; var ev=ev||window.event; clearInterval(timer); //只要键盘按着每隔10ms移动一次 timer=setInterval(function()&#123; switch(ev.keyCode)&#123; case 37: if(box.offsetLeft&gt;0)&#123; box.style.left=box.offsetLeft-10+"px"; &#125; break; case 38: if(box.offsetTop&gt;0)&#123; box.style.top=box.offsetTop-10+"px"; &#125; break; case 39: if(box.offsetLeft&lt;MapWidth-box.offsetWidth)&#123; box.style.left=box.offsetLeft+10+"px"; &#125; break; case 40: if(box.offsetTop&lt;MapHeight-box.offsetHeight)&#123; box.style.top=box.offsetTop+10+"px"; &#125; break; &#125; &#125;,10); &#125; document.onkeyup=function()&#123; clearInterval(timer); &#125;&#125;]]></content>
      <categories>
        <category>计算机</category>
        <category>程序</category>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[那些年，我与MP3的往事]]></title>
    <url>%2F%E9%82%A3%E4%BA%9B%E5%B9%B4%EF%BC%8C%E6%88%91%E4%B8%8EMP3%E7%9A%84%E5%BE%80%E4%BA%8B.html</url>
    <content type="text"><![CDATA[在我的学生生涯中，MP3是不可或缺的一部分。一直以来，我都很想将自己与MP3的故事记录下来，写成诗歌，写成小说。因此也借着此次语文期中作业机会，我为其写了这篇文章。十四岁那年，朋友送了我一部MP3作为生日礼物。那是一款学生用的无屏随身听，只有掌心大小，颇为小巧可爱。金属外壳是漂亮的大红色，配上按键的纯白，给人一种简约清爽的感觉。我喜欢把它掂在手中，感受着它那沉沉的质感，仿佛一颗美丽的红宝石，承载着空灵而神秘的世界。我的初中是属于那种全封闭式的寄宿学校，每两个星期才放一次假期，平常除了信息课很少有机会能够听音乐。在此之前的一段时间，我都是用复读机来听歌的。我并没有零花钱去买音乐磁带，我的复读机也不是那种可以插U盘的类型。但是听歌的欲望总是在我心中燃烧，驱动着我自己动手录歌。因为作业的需要，我曾经买过两盒空白磁带。周末回家的时候将让手机外放着自己想要听的歌，然后与开启录音模式的复读机一同放在厚厚的棉被中，再锁上房门，等待着磁带录完。尽管我努力营造一个安静的环境，但是录入的曲子还是不可避免地混有嘈杂的噪音。不过对于那时的我而言，在相对沉闷且忙碌的校园生活中能听到自己想听的歌曲，这些刺耳的杂音完全是可以忽略不计的。有了MP3后，我听歌的品质和数量都上升了一个档次。那时候，我听歌很杂，从中文到英文，从人声到纯音乐，只要是旋律能让我喜欢，无论雅俗，我向来是来者不拒。每个寂静昏暗的夜晚，我躺在自己的床偷偷地听着耳机中风格迥异的歌曲，都会感觉内心无比的愉悦，仿佛整个人乘着呼啸的夜风，翱翔在月光澄澈的云海中，感受着世界的广阔无垠。此时此刻，白天里的一切喜怒哀乐都揉碎在耳畔的歌曲中，沉淀，消散，只留下颤抖的心灵逐渐陷入沉睡。其实我的中学是向来不允许学生携带MP3这类电子物品的，只不过从来都有学生敢于打破这一规定，在教务处的搜查下暗地行动。无论是过去，现在，还是未来，学生与教务处之间永远存在着战争。只不过这也为我带来了诸多烦恼，如何充电，如何避免搜查……有时候甚至自己吓得自己思考出一系列被发现后的应对方案。而我也不太敢随身携带，一来害怕教务处随机搜查，二来也担心一不小心开了机，又将好不容易充好的电耗得一干二净。所幸在剩下的初中时光中，我和我的MP3成功逃过了每一劫，安然无恙地度过我压力最大的那一年。可惜的是，也许是因为我太不懂得珍惜，我的MP3慢慢地开始损坏：按键不灵，耳机孔损坏……它仿佛一个风烛残年的老人，各种各样的毛病浮现出来，最终在无力的拯救中完全失灵。心怀着叹息与遗憾，我将其藏在了自己的物品盒中，永远封存。那时我已成为了一个高中生，并且参加了学校里的信息学竞赛。教练允许我们一边敲代码一边戴着耳机听歌，我不再需要像初中那样偷偷摸摸地听歌。所以我并没有再次购入MP3的打算。然而，我与MP3之间的缘分似乎未尽。由于意外，我不小心将同学的MP3弄到了水中。赔偿新的之后，这个不幸的MP3自然也就成了我的新伙伴。我的新伙伴不再像之前那部是个无名小卒，而是索尼家族的贵公子。昂贵的价格，修长的外形，华丽的金色，极高的音质，完全有资格傲视大多数同僚。可惜这玩意儿跟了我，算是倒了八辈子霉——掉水里两次，拆了六七次，摔倒地上无数次，屏幕与开机键不知所踪，螺丝钉也有缺失，两个音量键都是降低……而即便经历了如此灾厄，它依旧能够正常开机。如果将它拟化成一个人的话，那必然称得上是一届传奇人物。虽然此MP3的确可以开机，但是是否能够播放音乐那完全就是个玄学。唯有天时地利人和三者全齐，方可一听其中乐曲。故此我学竞赛的那段时间，基本上只是将它作为U盘使用，平日里若是能听偶尔还是会听听，若是听不了那也无所谓。比起只能听歌和电台的它，室友那能看电子书的MP3才更是吸引人，虽然黑眼圈也会随之而来。不过待到我以遗憾的成绩结束我的竞赛生涯后，我的MP3作为随身听的功能才愈发受到了重视。每当我费劲按下那残缺的开机键，都像是一次令人期待的赌博。成功还是失败，每一次的结果都是难以预测的。甚至有时候第一次失败，下一次就成功了，所以我每次都会试个七八次才肯彻底死心。也正是因为如此，听歌的喜悦才会更加强烈，如同无尽荒漠中饥渴的旅人遇见一片美丽的绿洲。我至今记得那个疲惫的夜晚，许多天不曾听歌的我躺在床上凝视着昏暗的天花板，耳畔播放着优美动听的纯音乐，宛如聆听着天籁，心中洋溢着无与伦比的感动。那真是此生难忘的经历。到了后来，我上了大学，手机逐渐替代了MP3的地位。我很少再打开MP3，只是偶尔为了专心学习才记起它的存在。去年十一月，正在纠结论文题目的我回忆起与它的种种过往，决心写一篇关于音乐播放器的论文。然而几天后，它便丢了。那篇论文也因为水平原因，主题变成了留声机。从此MP3消失在我的人生中。时至今日，我收藏了几千首音乐，后摇，古典，爵士，摇滚……所听歌曲也与往日大有不同。身为重度音乐患者的我，无论是走路也好，吃饭也好，或者是写作业，都会随自己心意听上几小时的音乐。我的蓝牙耳机插上内存卡之后也能够作为MP3来使用。可我还是常常回忆起那些被繁星点缀的夜空与广阔无垠的云海。那是梦境？亦或是现实？我无从得知。我只知道，从那以后，我从未遇见在那些夜晚曾感受到的自由。]]></content>
      <categories>
        <category>杂</category>
      </categories>
      <tags>
        <tag>杂</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基于js的图标移动代码]]></title>
    <url>%2F%E5%9F%BA%E4%BA%8Ejs%E7%9A%84%E5%9B%BE%E6%A0%87%E7%A7%BB%E5%8A%A8%E4%BB%A3%E7%A0%81.html</url>
    <content type="text"><![CDATA[这份代码写得极其糟心。一来自己写这个样例的时候一直在拖，花了好几天才写完。二来原代码中有一些搞不明白的东西，也看不出来在代码中的作用，到后来索性都删了。再有就是外联css不知为何用不起来，闹腾了半天，只能和html放在一起写。最后就是找bug花了一堆时间，甚是难受。点此体验而我也懒得讲了，这里直接放代码算了。 代码html&amp;&amp;css123456789101112131415161718192021222324252627282930&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/&gt; &lt;title&gt;图标移动&lt;/title&gt; &lt;script src="moveLoad.js"&gt;&lt;/script&gt; &lt;!--&lt;link rel="stylesheet" hrel="moveLoad.css"/&gt;--&gt; &lt;style&gt; *&#123; margin: 0; padding: 0; &#125; div&#123; position: absolute; width: 30px; height: 45px; background: url("./images/V.ico") no-repeat center center; background-size: 76px 55px; top:100px; left:50px; &#125; p,input&#123;margin: 10px;&#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;input type="button" value="根据鼠标点击位置移动" /&gt; &lt;input type="button" value="根据标鼠标轨迹移动" /&gt; &lt;p&gt;请点击按钮激活功能！&lt;/p&gt; &lt;div&gt;&lt;/div&gt;&lt;/body&gt; js123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384window.onload=function()&#123; //图标 var oDiv=document.getElementsByTagName(&quot;div&quot;)[0]; var aInput=document.getElementsByTagName(&quot;input&quot;); var oP=document.getElementsByTagName(&quot;p&quot;)[0]; //移动到鼠标点击的位置 aInput[0].onclick=function(event)&#123; //清空事件 clearEvent(); this.value +=&quot;(已激活)&quot;; oP.innerHTML=&quot;鼠标点击页面，图标将移动至鼠标位置！&quot; //鼠标点击 document.onclick=function(event)&#123; var event=event||window.event; //开始移动 clearInterval(oDiv.timer); oDiv.timer=setInterval(function ()&#123; var X=(event.clientX-oDiv.offsetLeft)/5; var Y=(event.clientY-oDiv.offsetTop)/5; //ceil()向上取整，floor()向下取整 X=X&gt;0?Math.ceil(X):Math.floor(X); Y=Y&gt;0?Math.ceil(Y):Math.floor(Y); if(event.clientX==oDiv.offsetLeft&amp;&amp;event.clientY==oDiv.offsetTop)&#123; clearInterval(oDiv.timer); &#125; else &#123; oDiv.style.left=oDiv.offsetLeft+X+&quot;px&quot;; oDiv.style.top=oDiv.offsetTop+Y+&quot;px&quot;; &#125; &#125;,30); return false; &#125; &#125;; //图标跟随鼠标移动轨迹移动 aInput[1].onclick=function(event)&#123; clearEvent(); this.value+=&quot;(已激活)&quot;; oP.innerHTML = &quot;按住鼠标左键，在页面划动，图标将按照鼠标轨迹移动。&quot; //鼠标的位置 var aPos=[&#123;x:oDiv.offsetLeft,y:oDiv.offsetTop&#125;]; //鼠标按下 document.onmousedown=function(event)&#123; var event=event||window.event; //记录当前图标的位置 aPos.push(&#123;x:event.clientX,y:event.clientY&#125;); document.onmousemove=function(event)&#123; var event=event||window.event; //记录路上鼠标的位置 aPos.push(&#123;x:event.clientX,y:event.clientY&#125;); return false; &#125; return false; &#125; document.onmouseup=function(event)&#123; //初始化鼠标移动的事件 document.onmousemove=null; //setInterval(code,time)可按照指定的周期（以毫秒计）来调用函数或计算表达式。 var timer=setInterval( function()&#123; //如果没有坐标需要移动了，停止周期函数 if(aPos.length==0)&#123; clearInterval(timer); return; &#125; //设置图标位置 oDiv.style.left=aPos[0].x+&quot;px&quot;; oDiv.style.top=aPos[0].y+&quot;px&quot;; //弹出数组中的元素 aPos.shift(); &#125;,30); &#125; &#125; //清空事件 function clearEvent()&#123; document.onclick=null; document.onmousedown=null; document.onmousemove=null; document.onmouseup=null; for(var i=0;i&lt;aInput.length;i++)&#123; aInput[i].value=aInput[i].value.replace(&quot;(已激活)&quot;,&quot;&quot;); &#125; &#125;&#125;]]></content>
      <categories>
        <category>计算机</category>
        <category>程序</category>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Codewars之JS题解]]></title>
    <url>%2FCodewars%E4%B9%8BJS%E9%A2%98%E8%A7%A3.html</url>
    <content type="text"><![CDATA[这一篇文章主要是写一些我在Codewars上写到的js题目。 2019.5.9 Disemvowel Trolls题目将一行字符串中的元音字符删去，并返回修改后的字符串。 题解直接使用字符串自带的函数replace。str.replace(x,y)表示将与正则表达式x匹配的子串替换成y字符串我们所需要的正则表达式为/[aeiou]/gi/g表示执行全局匹配/i表示对大小写不敏感因为是删去，所以我们把匹配到的子串替换成空字符，即’’ 代码123function disemvowel(str) &#123; return str.replace(/[aeiou]/gi, '');&#125; List Filtering题目给定一个只含有数字类型和字符串类型元素的数组对象，过滤其中的字符串，并输出。 题解数组对象有一个函数是filter(),功能为创建一个新的数组，新数组中的元素是通过检查指定数组中符合条件的元素。那么接下来就是判断一个元素是否为数字类型。通过typeof我们可以得到一个元素的数据类型，如果等于’number’那么就是数字类型。 代码1234567function check(e)&#123; return typeof e == "number";&#125;function filter_list(l) &#123; // Return a new array with the strings filtered out return l.filter(check);&#125; 2019.5.12 Number of People in the Bus题目给定一个数组，表示n个车站。数组中的每个元素包含两个整型，分别表示每一个车站的上车人数和下车人数。求到最后一站时车上还剩下的人数。 题解代码很好写，但是js代码要用js特色的代码。数组中自带的reduce函数，功能为从左到右将元素通过括号里的函数累加。(a,b)=&gt;(a+b)是函数的另一种表现形式，等价于123function (a,b)&#123; return a+b;&#125; 代码1234var number = function(busStops)&#123; // Good Luck! return busStops.reduce((ans,[add,dec])=&gt;ans+add-dec,0);//0表示初始值&#125; 2019.5.14 Your order, please题目给定一个字符串，字符串中的每一个单词都包含着一个单独的数字，位置不定。数字的范围为1-9，请按照数字从小到大对单词进行排序。输出排序后的字符串。 题解这题应该是我第一次用JS语言的风格单独写出来的题。之前的题目虽然也是自己解决的，但代码写出来就跟用C\C++写出来的一样。以下为使用函数的解析：str.split(separtor,limit):将字符串转换成数组。separtor是指定分割成元素的字符或正则表达式。array.sort(function):对数组中的元素进行排序，默认排序顺序是按照字母升序。function是用来指定排序顺序的函数。str.match(regexp):在字符串中检索一个或者多个与括号内正则表达式匹配的值。array.join(separator):将数组中的所有元素转换成一个字符串，separator为元素之间的分隔符，此处用空格。 代码123function order(words)&#123; return words.split(" ").sort((word1,word2)=&gt;word1.match(/[1-9]/)&gt;word2.match(/[1-9]/)).join(" ");&#125; Where my anagrams at?题目定义两个字符串等价，当且仅当它们拥有的每种字符的个数都相等。问在给定的字符串数组中有多少字符串与给定的字符串word等价。 题解这题不难，所需函数上文都有。 代码1234function anagrams(word, words) &#123; word = word.split(&apos;&apos;).sort().join(&apos;&apos;); return words.filter(a =&gt; a.split(&apos;&apos;).sort(&apos;&apos;).join(&apos;&apos;) == word);&#125; 5.20 Calculating with Functions题目使用函数计算结果。输入包括两个数字函数和一个符号函数，如one(plus(two()));形式，即要求计算1+1的结果。数字函数代表函数名对应的数字。符号函数代表函数名对应的符号。除法向下取整。 题解因为这道题目我升到了5kyu这道题其实并不难，用寻常的方法也是可以写的。我再看了别人代码后修改了自己的代码。其实主要的盲点就是函数可以直接返回一个函数。代码不难，模拟一下即可。 代码123456789101112131415function zero(Func) &#123;return Func?Func(0):0;&#125;function one(Func) &#123;return Func?Func(1):1;&#125;function two(Func) &#123;return Func?Func(2):2;&#125;function three(Func) &#123;return Func?Func(3):3;&#125;function four(Func) &#123;return Func?Func(4):4;&#125;function five(Func) &#123;return Func?Func(5):5;&#125;function six(Func) &#123;return Func?Func(6):6;&#125;function seven(Func) &#123;return Func?Func(7):7;&#125;function eight(Func) &#123;return Func?Func(8):8;&#125;function nine(Func) &#123;return Func?Func(9):9;&#125;function plus(b) &#123;return (a)=&gt;a+b;&#125;function minus(b) &#123;return (a)=&gt;a-b;&#125;function times(b) &#123;return (a)=&gt;a*b;&#125;function dividedBy(b) &#123;return (a)=&gt;Math.floor(a/b);&#125; 5.21 Simple Pig Latin题目将给定字符串中的每个单词的第一个字母移到末尾，并在末尾加上’ay’。忽略标识符12pigIt(&apos;Pig latin is cool&apos;); // igPay atinlay siay oolcaypigIt(&apos;Hello world !&apos;); // elloHay orldway ! 题解感觉这题还是主要考验 代码123function pigIt(str)&#123; return str.replace(/\b(\w)(\w*)\b/gi,&quot;$2$1ay&quot;);&#125;]]></content>
      <categories>
        <category>计算机</category>
        <category>程序</category>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【游戏】Vim adventure之Level1-3]]></title>
    <url>%2F%E3%80%90%E6%B8%B8%E6%88%8F%E3%80%91Vim-adventure%E4%B9%8BLevel1-3.html</url>
    <content type="text"><![CDATA[关于Vim adventureVim adventure是一款用于学习Vim的网页游戏，你也可以直接把它当作一个Vim教程。至于Vim，以下是百度百科中的介绍： Vim是从 vi 发展出来的一个文本编辑器。代码补全、编译及错误跳转等方便编程的功能特别丰富，在程序员中被广泛使用，和Emacs并列成为类Unix系统用户最喜欢的文本编辑器。 当我在知乎上看到这款游戏时，便萌生出了极大的兴趣。毕竟在我不断接触Linux的过程中，Vim的大名可是常常出现在各类文章中。如今有这么一款寓教于乐的游戏，自然让我有些兴奋。所以在一个稍微有些空闲的下午，我在浏览器上打开了这款游戏:Vim adventure 游戏攻略Level 1刚进入游戏，你是一个阴影光标，正处在四个字符h,j,k,l中间。h,j,k,l代表着控制光标移动的四个方向键，其中h为左,j为下,k为上,l为右。当然你也可以直接使用键盘上的方向键，Vim中也是支持的。只不过这需要将你的手从字母键盘上移开，会降低流畅感。所以选择用哪个还需要玩家自己斟酌。现在，我们学会了移动自己的光标。当我们将光标移到人物的位置的时候，屏幕上便会出现人物的提示。第一个人物并没有给出什么重要的信息，只是表示欢迎而已。 那么接下来就让我们进入迷宫当中。迷宫的作用我想是为了让玩家更好地熟练关于方向键的使用。迷宫中有两个人物，一个是告诉我们关于help的使用，即:help加上想要查询的按键，即可得到信息。另一个人物则是告诉玩家需要去找w,e,b，三个按键。这个游戏中的按键不是一开始都能用的，除了h,j,k,l,:这五个字符之外的其他按键都是需要玩家自己去寻找。迷宫里右上角的宝箱暂时无法碰到，此时暂且忽略不计。另一个宝箱其实就是相当于障碍物，玩家必须获得钥匙才能通过。 走出了迷宫，在接下来的地图中玩家会发现自己被单向地图块所阻挡。此时根据人物的提示，我们可以知道，当下一行的长度小于所在行时，直接向下会到下一行的最后一格，一直到大于等于最初那行长度的一行时，才会回到原先那一列。根据这个性质，我们在以下三个位置按上下键即可通过。 当我们移到最后一个人物处，按下ESC键后即可迎来第二关。 Level 2Level2中，我们可以获取w,e,b三个按键。w:到下一个单词的第一个字母。e:到下一个单词的最后一个字母b:到上一个单词的第一个字母注意以上三个热键中标点也算是单独一个单词。通过这三个热键，我们就可以轻松到达被石头阻挡的地方。不过这时还是无法解决前面那个难题的，因为石头下面也压着一个感叹号。当我们通过这三个新技能拿到钥匙，就可以来到第三关了。 Level3第三关的第一个谜题是名为Bugs的邪恶势力在预言上添加了一些字符，即红框框起来的部分，需要玩家删掉这些字符。这个时候我们是没办法解决这个谜题的，所以先跳过去。不过谜题上的B按键我们可以先领取过来。B:到上一个单词的第一个字母，此处的单词是指被空格分开的字符串。有了这个案件前面的难题就可以解决了。不过别急，我们还没有拿到宝箱的钥匙。第三关的第二个谜题考验的是对于w与e的理解，玩家需要通过这两个按键到达最终点拿到按键x。不过这个谜题是限时30秒完成目标，否则会被传送回谜题外。玩家其实可以通过来回按w与e键以达到快速通关的目的。x:删除光标所在位置的字符。有了x我们就可以完成第一个谜题，并且获得宝箱钥匙。最后回到第一关打开宝箱，完成前三关。 后续不幸的是，这个游戏只有前三关是免费玩的。若还想玩后续关卡，则需花25美金（折合人民币大约200元），可以玩六个月。作为没钱的学生狗，这个游戏的教程恐怕就到此为止了。不过说实话，这款游戏对于Vim热键的掌握还是非常有帮助的，若是不缺这钱又苦于Vim热键不习惯的人不妨买来玩玩。]]></content>
      <categories>
        <category>游戏</category>
      </categories>
      <tags>
        <tag>游戏</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[读书、桌游与五月的雨]]></title>
    <url>%2F%E8%AF%BB%E4%B9%A6%E3%80%81%E6%A1%8C%E6%B8%B8%E4%B8%8E%E4%BA%94%E6%9C%88%E7%9A%84%E9%9B%A8.html</url>
    <content type="text"><![CDATA[我的五一过得相当颓废。整整四天的假期时光仿佛是一笔承诺的财富，如约地交到了我这个挥霍无度的穷人手中。尽管四天看起来很多，但对于我而言是远远不够，不一会就被安排得明明白白。由于繁忙的考试周与与自己的拖延症，待办事项如同滚雪球般越滚越大，至五一期间已堆积成令人叹息的模样。因此这难得的长假对我而言也只能是在堆积的事务中稍稍喘口气。然而，作为毫无自控力可言的拖延症患者，这一笔诱人的财富能用百分之五十用在原计划上我就心满意足，足以自傲了。事实上的确如此，原定一天内解决的近代史纲要的论文在互联网与漫画的诱惑下硬生生地被拖延到第三天晚上才勉强完成，导致原本时间充裕的大学计算机复习时间被大大缩减。项目什么的更是丝毫未动，当真令人羞愧。幸好我原先也算是有些许自知之明，没有把两门数学课的复习列入计划内，不至于让自己焦头烂额。 近代史纲要的论文题目是自己的家族史。一开始听到这题目，其实我是拒绝的，毕竟像咱这世世代代农民出身的家族能有什么值得记载的历史呢？但是作业毕竟是作业，作为学生还是得老老实实地做。所幸，老师的要求并不高，只需要讲讲几代人的生活即可，没有什么考据等专业性要求。这意味着就算是瞎编讲故事也无妨，我爸也觉得我随便编一下就行。可惜阅历极浅的我对于那段时间的了解并不多，根本无法胡编乱造。所以最后还是花了大把时间向我的父母询问那段“毫不起眼”的历史。虽然最初只是把这个作业当做一个麻烦，但是随着对自己家族故事的深入了解，我却愈发地感兴趣了。解放战争、共产党、人民公社、文化大革命、改革开放……当这些从小到大都在学的熟悉名词遇上了自己身边的亲人时，一种奇妙的历史参与感便油然而生。第一次感到，那些熟悉的历史事件与自己是多么的接近。当真是任何一个人的人生都是一个时代的缩影啊。虽然写论文花了多余预想两三倍的时间，但实际上还是有一天左右的复习时间的。加上原先约于第四天早上的乒乓球也因为球场装修而改了日子，按理来说还是非常充裕的。但是我向来不是一个讲理的人。持着计划制定出来就是为了打破的原则，我成功在漫画的怀抱中“荒废”了一个早上加半个下午，成功将复习时间压缩了一半。我可以毫无底气地宣称，这不过是为了将时间更加有效率地使用的一种策略，一切都在我的计划中。说实话，大学计算机课我这学期基本上是没有听过的。课程本身无趣，老师讲得也无聊，加上有一部分内容也都了解过，我是根本没有听课的欲望。每节课刷刷手机，写写作业(并没有)就这样浪过去。作业偶尔认真写一下，基本上没学到什么东西。复习的时候我连思维导图都懒得做，边看上课的PPT边写配套的习题，一章一章的地翻过去就当自己复习完了。至于SQL，我试着在codewars上写了几题，结果一道都没写出来，果断放弃以防打击自己的信心。还好5月5号的考试并不是特别的难，除了题型让我大吃一惊以及SQL依旧懵逼外都还好。成绩至今未出，但不出意外，及格还是能够的。 虽然这四天在学习上我的确颓废得很，但其实生活还是充实得像一般大学生活。介于5月8号又到了还书的日子，而我手上那本借来）两个月左右的《爵士乐时代的故事》尚有三篇未读，所以第一天早上就坐在大寝室的客厅里看看书做做笔记。看完书自然是要写书评，趁着刚刚读完，下午就顺便写写书评。然而想起上次那篇《骆驼的后背》还咕着，创意写作课的总结也忘了写，顿时感到任务重了好多。边写边浪着，直到第二天早上才写完。第四天早上才有时间去还了书，相应的又借来一本石黑一雄的《别让我走》。看书的时间固然少，但书不可不看，要不然又会陷入浅薄的思维沼泽，难以挣脱。不过想着六级考试也快到了，我也该看看手头那本英文版的《傲慢与偏见》。 第二天的下午和社团里约好玩桌游。其实我一直很期待玩桌游，尤其想试一试跑团。第一次知道跑团是在17年的十月番《如果有妹妹就好了》里面。我是很喜欢这部番的。尽管它并没有什么值得一提的剧情，也没有特别令人印象深刻的人物，制作方面平平常常，属于那种看着很有意思，但基本上没有安利价值的番剧，但是我却被这部动画所吸引着。因为这部动画描绘了我最渴望的生活状态——一间自己的房子，一屋子游戏书籍，友人常常造访，所遇大多有趣的灵魂……这是何尝令人羡慕的生活状态。所以这也成了我的理想之一。在我的理想生活中，桌游是必不可少的东西，毕竟是朋友聚会，居家旅行的必备品。因此在社里分出桌游分社时，我满怀欢喜地加入了，算是借此道踏入这个圈子。五月二号的下午是我第一次参加社里的桌游活动。由于人数多的原因，并没能跑团，而是玩了三个我从未玩过的桌游游戏——《爆炸猫》《推翻苏丹》《犯罪现场》。我比较喜欢《爆炸猫》，简单，有趣，刺激，流程也短。相比之下，后两者比较烧脑，需要各种推理，《犯罪现场》还需要两次连着抽到凶手的我来演戏，着实费劲。演戏的确是很累的事情，不仅要假装侦探推理，还得用最自然的方式误导侦探，每次一指到正确的红白牌我都会紧张一阵子。两次凶手都是输了，剩下一次侦探也完全没有表现的余地，可惜可惜。将整整一个清闲且充裕的下午献祭给桌游，我感到自己的san值逐渐回满。向桌游社的诸位道别后，我又到荷园吃了一锅物美价廉的麻辣香锅，然后心满意足地回到寝室。 我计划是第三天下午出门，毕竟是难得的长假，即便我是一个死宅，也不愿意一直呆在宿舍里发霉。而那天上午却下起了小雨。五一这几天一直是阴雨天气，天空灰蒙蒙的一片，绵长的雨丝时不时地飘落，让人在撑伞与不撑伞之间纠结。偶尔雨大了，淅淅沥沥地下一小会儿，不平整的地上又出现了大大小小的水洼。我讨厌在雨天出门，一是不愿意走满是水洼的道路，而是撑着雨伞总感觉极不方便。所以我有点担心这雨会一直下到午后，心想着若真是下一天的雨，我就索性窝在宿舍里看漫画。这两天沉迷于水上悟志老师的作品，一口气看完了《魂环》和《惑星公主与蜥蜴骑士》，还是意犹未尽。不过雨很快就停了，到了下午地也差不多干了。我打算去红树林公园走一遍那条有名的海岸线。坐公交车发现途经华侨文化创意园，于是顺道去了一趟。去年十二月我去过一次创意园，但那时只是随便逛逛，走过著名的B10现场门口，然后到独立动画展览的会场里走了一圈，感觉不到什么趣味，便去看附近的马拉松比赛了。后来才意外得知此处的旧天堂书店小有名气，于是趁此机会决定去店里看看。出乎我意料的是，创意园那天刚好有个小集市一般的展会。我满怀兴致地一个摊位一个摊位地看过去，发现了不少有意思的东西——木制的茶具、有些年代的瓷杯、自家蒸馏的香精……各种各样充满文艺气息的物品，让人眼花缭乱。有一个摊位摆满了各种各样奇奇怪怪的魔方，两位摊主坐在计时器前专心致志地转着手中的魔方；另一个卖画的摊位上有一个孩子用马克笔画着精致复杂的空中楼阁。还有一家展示旧杂志旧报纸的摊位上摆着一架现在很少见到的电唱机，让曾经写过关于留声机论文的我心生亲切。逛了一圈摊位，我便找那家旧天堂书店。书店很有那种怀旧悠闲的氛围，昏黄的灯光、拥挤却整齐的书籍、老旧的机器……我进门时店里放着旧式的摇滚乐，一曲结束后有放了一首有点迷幻味道的音乐。店里的书都很有意思，充满了文化感。但不同于其他书店，这家书店最令我感兴趣的还是其陈列的音乐专辑和黑胶唱片：Jazz,Rock,Funk……看着这些承载上世纪荣光的小盒子，我感到无比兴奋。虽然我基本上看不太懂，但是我还是傻里傻气地一个一个看过来，内心期待这能有一张自己听过的专辑或者唱片。书店的照片我虽照了一张，但事后才发现自己拍糊了，所以只能用其他地方的照片替代。希望以后能有机会再照一张。离开了创意园后，我继续朝着红树林前进。这次的公交车下站点正好在红树林公园的对面，欢乐海岸的门口。因为是我独自一人的出游，所以行程也比较随意。我就到欢乐海岸外面的广场上逛了逛。也许是五一的缘故，广场上的人很多，大部分是一家人整整齐齐地来到此地游玩。那些孩子们在起伏的喷泉旁玩耍，而他们的爷爷奶奶，爸爸妈妈则在一旁面带笑意地看着。广场旁有一座造型奇特的建筑，我走近一看，原来是大疆的旗舰店。由于学校与专业的缘故，我常常能听到大疆的名号。此时看见他家的旗舰店，自然也好奇地走进去看看。店里展示着许多不同型号的无人机，还有看上去就有高科技感的摄影机器。我照旧是不懂装懂地看了一遍，就退了出来。门口有一架小型的无人机翱翔在人群上空，仿佛一只新生的飞鸟。通过地铁站穿越马路，我总算来到了最初的目的地——红树林公园。人很多，灰蒙蒙的天空下五颜六色的一片。这是我的第一印象。我觉得自己应该挑一个非节假日的晴天来此地。所谓海岸，其实和我家乡那边的滩涂差不多模样，由于是阴天的缘故，似乎有些压抑的感觉。公园倒像是我曾经去过的西湖畔，一路上全是行人。近年来，穿汉服的小姐姐似乎越来越多，大家也都愿意来到人群中间展现自己的风采，以至于我一路上看到不少穿着汉服的小姐姐（应该是小姐姐吧），让我一度疑心周围有什么漫展。海边的道路很长，我听着耳机内的音乐，嗅着海风中咸湿的气息，望着广阔的天地、来往的行人，心情惬意得像是踩在棉花上流畅地跳着华尔兹。 五一四天的假期在我颓废而又充实的生活中结束了，繁忙的学业生活又将来临。虽然我依旧是犯了严重的拖延症，不过好歹也算是完成了预定的计划。希望接下来的五月里，我能迎来更加充实的生活吧。]]></content>
      <categories>
        <category>杂</category>
      </categories>
      <tags>
        <tag>杂</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于播放音乐的二三事]]></title>
    <url>%2F%E5%85%B3%E4%BA%8E%E6%92%AD%E6%94%BE%E9%9F%B3%E4%B9%90%E7%9A%84%E4%BA%8C%E4%B8%89%E4%BA%8B.html</url>
    <content type="text"><![CDATA[这篇文章我主要是想写写我在听音乐过程中所遇到的一些问题。感觉写成好几篇文章太过于麻烦，所以我索性全写到一篇文章中，以后若是遇到自然也会在此文章中更新。以下是本文的内容所涵盖的几点： Linux里firefox无法播放音乐 网易云音乐付费音乐免费下载 Hexo博客添加音乐 ubuntu里firefox无法播放音乐我在ubuntu环境下时一般使用RhythmBox播放本地音乐，而且也很少在此环境下看视频，所以我很少用浏览器播放音频和视频。但是有时候是必须用到浏览器播放，就像是下文所讲的下载付费音乐。然而当我第一次在ubuntu的firefox上打开网易云音乐网页版播放音乐时却发现无法播放。网上一查，大抵上是解码器不支持的缘故。幸运的是这个问题也好解决，安装个解码器即可。1sudo apt-get install ubuntu-restricted-extras 网易云音乐付费音乐免费下载这个方法只对可以在网页端听的音乐有用。 进入歌曲页面，按下F2查看元素。 点击网络(network)，并且选择媒体(media)，然后按ctrl+R重新载入。 在ubuntu中，选择大小最大的那一项，即上述图片中的第二项。右键，点击新建标签页打开，然后切换到新生成的页面中。在windows中，需要先播放音乐，然后再选择大小最大的那一项，双击并切换得到新生成的页面中（也可能是浏览器的原因，我两个系统的浏览器不同）。 右键中间的进度条，点击另存音频为，即可保存歌曲。windows Hexo博客中添加音乐使用音乐平台提供的外链以网易云音乐为例： 进入所需歌曲的页面，点击生成外链播放器。 一般添加的是iframe标签，调节完尺寸和播放模式后，复制最低端的HTML代码，添加到自己的博客文章中。1&lt;iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=330 height=86 src="//music.163.com/outchain/player?type=2&amp;id=19892244&amp;auto=0&amp;height=66"&gt;&lt;/iframe&gt; 效果如下： 使用aplayer播放上述引用音乐平台外链的方法可以说是非常的方便了，只要获取代码添加一下即可。然而对于一些老爵士、老摇滚和其他有版权保护的音乐是没办法添加外链的。网上虽然有如何获取这些歌曲外链的方法，但是我试过两次后，发现只能出现播放器，却无法播放。所以为了一劳永逸，我选择使用aplayer。aplayer是一款音乐播放插件，即html5的嵌入式播放器，只要有歌曲的id即可。 安装aplayer插件 1npm install --save hexo-tag-aplayer 使用MetingJS MetingJS 是基于Meting API 的 APlayer 衍生播放器，引入 MetingJS 后，播放器将支持对于 QQ音乐、网易云音乐、虾米、酷狗、百度等平台的音乐播放。 上述是从别人博客里引用的关于MetingJS的介绍以及功能。使用MetingJS需要在根目录下的_config.yml文件中添加以下语句：12aplayer: meting: true 添加代码准备工作完成了，接下来你只需要在你想加音乐的博客文章中添加以下代码即可：1&#123;% meting &quot;3880720&quot; &quot;netease&quot; &quot;song&quot; &quot;theme:#555&quot; &quot;mutex:true&quot; &quot;listmaxheight:340px&quot; &quot;preload:auto&quot; %&#125; 效果如下： 其中3880720是歌曲的id，可以在该歌曲页面的网址中找到。 这份代码中的各个参数配置如下： 选项 默认值 描述 id 必须值 歌曲/专辑/歌单对应的id server 必须值 音乐平台：netease(网易云音乐)、tecent(qq音乐)、xiami(虾米音乐)、kugou(酷狗音乐)、baidu(百度音乐) type 必须值 请求类型：song(单曲)、album(专辑)、playlist(歌单)、search(搜索)、artist(歌手) theme #ad7a86 播放器风格色彩设置 fixed false 开启固定模式 mini false 开启迷你模式 loop all 列表循环模式：all, one,none order list 列表播放模式： list(顺序播放), random(随机播放) volume 0.7 播放器音量 lrctype 0 歌词格式类型 listfolded false 指定音乐播放列表是否折叠 storagename metingjs LocalStorage 中存储播放器设定的键名 autoplay true 自动播放，移动端浏览器暂时不支持此功能 mutex true 该选项开启时，如果同页面有其他 aplayer 播放，该播放器会暂停 listmaxheight 340px 播放列表的最大长度 preload auto 音乐文件预载入模式，可选项： none, metadata, auto]]></content>
      <categories>
        <category>教程</category>
      </categories>
      <tags>
        <tag>Blog</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【读书】爵士乐时代的故事]]></title>
    <url>%2F%E3%80%90%E8%AF%BB%E4%B9%A6%E3%80%91%E7%88%B5%E5%A3%AB%E4%B9%90%E6%97%B6%E4%BB%A3%E7%9A%84%E6%95%85%E4%BA%8B.html</url>
    <content type="text"><![CDATA[《爵士乐时代的故事》我从图书馆结果来历经两个月方才读完。主要还是平常看书的时间太少，在加上一开始心太野，想给每一篇短篇小说都分析一遍。后来终于发现自己并没有那么多的精力，所以最终只是写了两篇小说的分析。 我很喜欢这部作品。菲茨杰拉德的文笔非常的华丽、精致，所描述的场景极其富有画面感，很容易让人的脑海中浮现出那个繁华、放纵、娱乐至上的爵士乐时代。无论是《牛皮糖》和《骆驼的后背》中所描述的舞会场景，还是《幸福与辛酸》和《治心人》中描绘的年轻人的生活，都让人惊叹不已。他对于每个人物的情感刻画也是有声有色，行为逻辑、语言风格、内心活动……自然、合理，菲茨杰拉德笔下的人物似乎源于一个个活生生的人类，凭着自己的意愿活在这些小说所描绘的世界中。我想这必须是要有一定的阅历才能表现出来的文字，而我如今无论是阅历上还是文字功夫上都是远远不足。 我向来认为，一篇短篇小说就是一件精致的艺术品。它不必向长篇那样光是构思大纲便已经很累，却也不想诗歌那般字字句句都得斟酌。短篇小说的精妙在于其精巧的结构与精炼的文字。毫无疑问，这两点菲茨杰拉德先生都非常的擅长。虽然我只是具体分析了《牛皮糖》和《骆驼的后背》两篇故事，但是其完整精致的结构却给我留下了深刻的印象。每一部分都不多余，每一部分都不可缺失，阅读节奏也是恰到好处。每篇小说都想是一个流畅的主体，前文包含着后文的内容，后文也呼应着前文的剧情，无论那一段都不可分割出来。反观我自己所写的那部《深夜派对》，尽管设定我是非常喜欢，但也正如路学姐所说，现实与幻象部分感觉被割裂成两个独立的个体，如果单独把幻象拿出来似乎也不成问题。我想如果将来有时间的话，我还是想多分析菲茨杰拉德的短篇小说。 其实这篇短篇小说集最令我惊叹的，还是其中所描绘的内容。这本小说集是1922年开始出版的，也就是说这篇小说集中的大多数短篇都是上个世纪二十年代的成品，距今差不多也有百年时光。然而，百年之后的我去阅读这本小说集的时候，却惊讶地发现，他虽写的是百年前的年轻人的生活状态，却与当今现状如出一辙。 《牛皮糖》中游手好闲、虚度光阴的吉姆与追求自由独立的现代女性形象南希在我们的日常生活中随处可见。《骆驼的后背》中男女主之间关于是否结婚的矛盾也是如今屡见不鲜。《热血与冷血》中在过于热心与过于冷漠之间徘徊的马瑟简直就是我本人的写照，也是现代人经常面临的道德困境。每当我走过乞丐的旁边，强硬地压抑住内心的同情与愧疚，无视其可怜可悲有时甚至可恨的姿态，拒绝施舍自己的善意时何尝不是那么的纠结困扰。甚至不要说是乞丐，便是不得已拒绝相识之人的请求也会让我困扰一阵。如何在热心与冷漠之间平衡，真的是一个问题。《格雷琴的四十次眨眼》中的奋斗家罗杰的经历，虽然与如今的996本质上不同，但是那种为追求幸福疯狂工作而导致自己本人的情感生活与身体健康临近崩溃的描写简直是现代人的真实写照。哪怕是为了自己的理想而奋斗，这种近乎献祭的工作方式也会令人反思。《治心人》所讲的是年轻夫妻之间的婚姻矛盾。一开始我以为这应该是两个人之间价值观的不切合，才导致如今这种感到厌烦的局面。而后来，我渐渐明白，这是两个人尚未理解生活的真相，尚未明白婚姻的真相，无法适应新的，他们应该面对的生活的结果。这样的矛盾以丈夫的生病为爆发点疯狂激化，使得他们原先那种勉强维持的日常生活瞬间崩塌，成为一堆难以处理的废墟。所幸在心理医生的帮助下，两个人都成熟了许多，明白婚姻是怎样的一回事。这些日子我常常能在知乎上看到一些关于爱情，关于婚姻的问题，有些人是认为三观不合的缘故，但也有人指出是两人都没能包容对方的想法所导致的。我不得不承认，现实中的大多数矛盾都是源于后者。一个人在生活中很难找到兴趣三观完全符合的友人，而且还要是异性，这就更加困难。两个人在一起过于亲密，那么必定会有许许多多的矛盾之处，只有接受这些不同，相互理解，求同存异，生活才会更加和谐。另外一点就是现代人果然还是需要心理医生，定期地去检查心理健康还是非常重要的。《“哦，赤褐色的女巫”》中的“卡罗琳”在全篇小说中可以说是一个理想的令人痴迷的女性形象。与其把她这个形象单纯认为是一个“女神”，我更愿意将她作为一种理想事物的隐喻——理想伴侣、理想生活、理想工作或者说青春、梦想、激情……那时所有人都渴望得到的，想要追求的东西。但是大多数人更像是默林·格兰杰，作为一个平庸的人“单相思”着自己的幻想，却又不得不在为主流的平凡的生活而奋斗。毕竟那样的生活才是我们的现实，那样的幻想只能想想。而在小说的结尾，老默林知道了这一切的真相后，幻想破碎，其中未必没有些许讽刺的意味——也许我们所向往的不过是自己的幻想，有时候也只是自我感动罢了。《幸福的辛酸》所讲的两对夫妻，两场以悲剧收场的婚姻，一个因为天灾，一个因为人祸，倒也令人叹息。《返老还童》这篇小说很有意思，也曾经被改编成一部叫做《本杰明·巴顿奇事》的电影。而《齐普赛街的塔奎》这篇虽说精彩，但其实我也没怎么看懂。 我想人类的烦恼与苦闷是跨越时间，跨越地理的，无论是哪个时代的人都遇见的相同的烦恼。正如《传道书》中所写： 传道者说：虚空的虚空，虚空的虚空，凡事都是虚空。人一切的劳碌，就是他在日光之下的劳碌，有什么益处呢？一代过去，一代又来，地却永远长存。日头出来，日头落下，急归所出之地。风往南刮，又向北转，不住地旋转，而且返回转行原道。江河都往海里流，海却不满；江河从何处流，仍归还何处。万事令人厌烦，人不能说尽。眼看，看不饱；耳听，听不足。已有的事后必再有；已行的事后必再行。日光之下并无新事。]]></content>
      <categories>
        <category>小说阅读</category>
        <category>短篇小说</category>
        <category>菲茨杰拉德</category>
      </categories>
      <tags>
        <tag>小说阅读</tag>
        <tag>短篇小说</tag>
        <tag>菲茨杰拉德</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[我的第一次创意写作课]]></title>
    <url>%2F%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E6%AC%A1%E5%88%9B%E6%84%8F%E5%86%99%E4%BD%9C%E8%AF%BE.html</url>
    <content type="text"><![CDATA[第一次了解创意写作是我高中时候的事情了。那时候热衷于写小说，却苦于时间精力与技术上的不足。因此我特意去家乡本地的图书馆里找关于写作的书籍。然后那本叫做《成为作家》的书便出现在了我眼前。我向来是个羞涩的人，对于自己写小说的爱好也很少诉诸他人。而对于这类书名如此“露骨”的书籍，我更是不愿意借的，一来怕是无用的商业之作，二来受不了他人的询问。然而当我翻看此书时，内心动摇了。不得不承认，此书中所写的内容正是我所需要的东西。我正面临的困境，我所向往的形象，我所缺失的训练……里面的字字句句无不直扣我的内心。经过一番犹豫之后，我借了这本书，还有另外一本《开始写吧 虚构文学创作》。这两本书恰好属于国内引进的创意写作书系。 创意写作是这样一种写作，它以一种具有想象力的、通常是独特的又赋有诗意的方式表达作者的思想和情感。”写作是个人自由的一种形式。它能使我们从周围所见到的公众性中解放出来。作者最终所写的不是某种文化下的草莽英雄（outlaw heroes），而最主要的是想拯救自己，保存个性。 高中毕业后，我上了一所工科大学。按理说在这样的大学里，即使是文理通识课也是与这种训练课无缘的，至少不会面向理工科学生。然而大一下学期的文理通识选课中却出现了“创意写作”这四个字，而且与我繁多的必修课没有丝毫冲突。毫不犹豫地，我选择了它。 上课的老师是一个非常有名的老先生——杨争光老师。 杨争光，深圳市第四届政协委员。一级作家，影视编剧，深圳市文联副主席。1957年生于陕西省乾县，1982年毕业于山东大学中文系，长期从事诗歌、小说、影视剧写作。著有《土声》、《南鸟》、《老旦是一棵树》、《黑风景》、《棺材铺》、《从两个蛋开始》等小说，担任电影《双旗镇刀客》编剧，电视连续剧《水浒传》编剧之一，《激情燃烧的岁月》的总策划。 老先生很是友好，上课也是近于一种聊天的形式。虽然由于我们这些大学生糟糕至极的阅读量与内向的举止，大多时候都是老师在说。杨老师拥有很强的人文关怀，他的很多思想都能引发我的思考，并且让我认识到自己的不足。老师再次让我意识到了自己对于人性，对于爱，对于诸多人生命题的理解上的缺陷，以及对于高中时所陷入的功利主义的思考。虽然凭着当前的阅历大多思考都是无用功，但是我又因此重拾那些因高考而舍弃的“无用之书”。就是凭这一点，我上这门课也是有收获了。 由于我们的阅读量不够，所以讲课的素材是老师选定的五部电影——《郎读者》《肖申克的救赎》《阿甘正传》《贫民窟的百万富翁》《泰坦尼克号》。都是曾经得到过奥斯卡奖且广为流传的经典电影。虽然其中大部分都看过，但是老师还是会要求我们重新再看一遍，并且边看边做笔记。杨老师首先从立意、人物、事件三方面讲起。用的素材是前三部电影，一部电影一个方面。关于电影的评述我不再多说，以后有可能的话会单独写成文。 在立意这方面，我并没有收获很多，毕竟这一点终究是依靠个人对于外界的体验认知。不过在后面的小说创作中，我再一次认识到其重要性，以及困难之处。对于立意，也许在动笔之前，我能够想很多，但是在动笔之后，总会想得更加深入，以至于文章主题模糊。这一点着实令我困扰。 而在人物方面，我收获的相对多一些。对于人物形象的五种概括，其精神形象、符号形象、经典形象、通俗形象、伪经典形象，只不过是概念上的阐释，我也不必多言。但是人物本身在小说中的地位却让我有所思考。作为小说立意的载体，人物本身应当是非常重要的。 塑造有价值的人物是讲好故事的关键 的确，故事是由人物产生的，立意也是有人物承载的。人物的行为应当包含这作者本身的态度，故事的发展也应该符合人物的行为逻辑。这一点是我从前从未注意到的。而后来，我对这话又有了其他思考。我的小说中常常有一个致命的缺陷，那便是过于无趣。无趣，便会导致读者看不下去。看不下去，那么无论小说的立意是多么深刻，后期剧情怎样的神展开，都是无济于事了。我原先以为是故事性太差的缘故，虽然的确有这样的原因，但是如今的我仔细思考，比起故事性，人物本身的无趣单调或许更为致命。若是有一个有趣的人物形象，那么即使是枯燥的故事想必也不会无聊了吧。由此亦能推之，现实生活的乏味不可避免，然而比起多姿多彩的生活，一个有趣的灵魂更为重要。关于人物的另外一点，是杨老师提出的“铁三角理论”。三角形是几何图形中最为稳定的结构，这一性质，在各个领域都有运用。老师认为在文字领域亦是如此，一部优秀的小说，其中的关系必有稳定的三角关系，此处的关系已经不仅仅指人物了，一个事件，一个道具都可以成为这个三角形中的一角。乍一听，这理论甚是微妙，然而仔细一想，其中缘由不无道理。三角关系才能达成一种平衡，才更加稳固。 “铁三角理论”在事件中也有体现。一个事件由起因，经过，结果三段组成，每一段又可以包含几个小事件。事件的堆叠构成高潮迭起的故事，才能让人感觉完整，舒适。事件中还有一点极为重要，那就是困境。老师说：你把主人公写得越惨，故事便越精彩。所以要为主人公设计一个主要的困境，解决主要困境的路上可以在多设计几个小的困境，是文章跌宕起伏。我认识到自己的确对于笔下的人物太过温柔，使得人物的目的模糊不清，导致无法继续有进展。而仔细回忆自己所看过的优秀故事，大多都是将主人公扔进一个意想不到的甚至是痛苦的困境之中，将其表面上和平的日常粉碎，挖出深藏于其中的矛盾，如此才使得小说更有张力。人物脱离困境之后也只有两种情况，绝境或是大团圆的境地。无论是那种境地，都是为了讲述出故事的内核。 这之后，杨老师借分析《贫民窟的百万富翁》为我们讲述了故事的结构。这部电影本身的故事结构便是非常精彩的，回忆中套着回忆，大故事中夹杂这小故事，最后在统一起来，让人感到酣畅淋漓。对于结构而言，其实我也并没有得到新的知识。但是对于分析故事本身的结构有了更多的经验，这的确也让我有所收获。而杨老师对于结构与意人事之间的关系倒也让人耳目一新。他认为两者一文一质，唯有文质彬彬，才是优秀的作品。 最后老师通过《泰坦尼克号》为我们分析了细节的重要性与情节设置的必要性，深层的分析，让人不得不感叹一部优秀的作品的确就是一个精致的艺术品。 至于我们的作业，是自己写一篇叙事性的作品，包括小说、剧本、叙事散文……不过所有人写得都是小说就是了。我原先构思了一篇科幻，思索了好几个星期，却发现自己根本驾驭不了这样的题材，于是赶紧重新构思了一篇校园怪谈类小说，即《深夜派对》。这篇小说最终的成品也与我的最初的构思不同，一来是自己的能力的确不足，二来时间也不大允许。不过作为作业我还是可以接受的。在讲评阶段，这篇小说的缺点也被指出来了。首先是现实部分与幻想部分之间的疏离感过重，让人感到有些脱节，之间的联系不是很大。然后是我本人的写作意识过重，导致前文并没能给人带来所期望的感觉。这一点我自己虽有所知觉，但没发现其所带来的问题。我写文时非常的困难，通常是将脑中的画面用仔细地描绘，这样就导致很多地方都被重点描绘，导致情感不明显。情感不明显也导致了最后一个问题，就是我施加给主人公的压力不够显著，会让人有种大题小做的感觉。虽然我本意是想将小说在修改一遍，不过时间是个问题，所以先加入日程吧。 为期八周的创意写作课便在作业讲评中结束了。其实这篇文章几周前就可以写了，但一直拖到今日才完成，也是因为这段时间比较忙。这门课我受益匪浅，也知道了自己的缺陷。正所谓师傅领进门，修行靠个人，以后的练习还是得多靠我自己。最后献照一张，以纪念我的第一次创意写作课。]]></content>
      <categories>
        <category>杂</category>
      </categories>
      <tags>
        <tag>杂</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【基础学习】大学物理——牛顿力学、刚体转动、相对论]]></title>
    <url>%2F%E5%A4%A7%E5%AD%A6%E7%89%A9%E7%90%86%E2%80%94%E2%80%94%E7%89%9B%E9%A1%BF%E5%8A%9B%E5%AD%A6%E3%80%81%E5%88%9A%E4%BD%93%E8%BD%AC%E5%8A%A8%E3%80%81%E7%9B%B8%E5%AF%B9%E8%AE%BA.html</url>
    <content type="text"><![CDATA[昨天晚上考完了大物的期中考试，试卷意外地很简单，导致我莫名地有些担心期末考会难到爆炸，毕竟像这类先给颗糖让人尝尝甜头，再冷不防来一头闷棍的事情屡见不鲜，更不要说曾闻上届有很多人挂科……其实考试结果如何真的无所谓，只要及格我就心满意足了，毕竟我也不是靠这个混饭吃的。 近日迷上了思维导图，本身就不太喜欢听课的我就开始不负责任地自个儿搞自个儿的，边浪边学，最终也完成了几张不怎么靠谱的思维导图。其实原本是想通过写故事来总结的，但是发现自己实在是狂妄至极，知识还没有学透就想着用这样的需要极高熟练度及想象力的方法，于是便不了了之。 思维导图本身有没有用处我倒是不知道，但是做思维导图的过程倒是有用，至少让我的对这些知识有了个大致的了解。从前我的学习状态大多处于那种学到某一个地方明白了，换到另一个地方就忘记了。思维导图的精炼描述倒是容易让我想起来曾经学过的东西。 以下便是我做的三份思维导图了，只有由于是期中考试，所以只有牛顿力学、刚体转动、相对论三张。运动学没有，因为时间不够。 由于是图片格式，所以备注不可见，若有好奇的、或是想要更好体验的不妨下载文末的文件，于Xmind8中一览。 点击下载]]></content>
      <categories>
        <category>杂</category>
      </categories>
      <tags>
        <tag>杂</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基于canvas的鼠标画图功能]]></title>
    <url>%2F%E5%9F%BA%E4%BA%8Ecanvas%E7%9A%84%E9%BC%A0%E6%A0%87%E7%94%BB%E5%9B%BE%E5%8A%9F%E8%83%BD.html</url>
    <content type="text"><![CDATA[在别人的前端demo中看到了鼠标画图这一项目，略感兴趣，于是读其代码，实现其功能。 点此体验 用鼠标画图的功能不是很难，原代码将html、css、javascript全部放在一份文档里都不算长。为了更好的阅读，我将其分成了三份。 html在&lt;head&gt;标签中引用css和javascript代码在&lt;body&gt;标签中构造按钮区域以及canvas画布1234567891011121314151617&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta http-equiv="Content-Type" content="text/html; charset=utf-8"/&gt; &lt;title&gt;鼠标画图&lt;/title&gt; &lt;script src="mouseDraw.js"&gt;&lt;/script&gt; &lt;link rel="stylesheet" href="mouseDraw.css"/&gt;&lt;/head&gt;&lt;body&gt; &lt;div id="button"&gt; &lt;input type="button" value="重画"/&gt; &lt;/div&gt; &lt;!--定义画布元素，宽高要写在标签里。 若在css文件设置，虽然canvas标签的大小会正常显示，绘制的图形则会按照缺省宽高比例放大缩小，缺省的高度是300px，宽度是150px--&gt; &lt;canvas id="can" width="500px" height="500px"&gt;&lt;/canvas&gt;&lt;/body&gt;&lt;/html&gt; css无解说123456789101112131415/*允许中文字符*/@charset "utf-8";body&#123; background: #CCC; text-align: center;&#125;#button&#123; margin: 50px auto; width: 200px;&#125;#can&#123; background: white; margin-top: -50px; display: inline-block;&#125; javascript1.创建画布2.获取按键元素，并赋予清除功能3.画布中实现画图功能12345678910111213141516171819202122232425262728293031323334353637383940window.onload=function()&#123; //获取&lt;canvas&gt;元素 var can=document.getElementById("can"); //创建画布对象 var con=can.getContext("2d"); //获取按键元素，此处是通过标签名得到的变量，是数组变量 var inp=document.getElementsByTagName("input"); //清空画布.canvas每当高度或宽度被重设时，画布内容就会被清空,（此方法仅限需要清除全部内容的情况） inp[0].onclick=function()&#123; can.width=can.width; &#125; //当用户按下鼠标按钮执行Javascript代码 can.onmousedown=function(ev)&#123; //兼容各个浏览器。 //在FireFox浏览器中，事件绑定的函数要获取到事件本身，需要从函数中传入，而IE等浏览器则可以直接使用event或者window.event得到事件本身。 var ev=ev||event; /* moveTo:定义一个起点 client系列:可视区域 clientX： 相对文档的水平坐标 clientY： 相对文档的垂直坐标 offsetLeft： 对象相对于版面或由 offsetParent 左侧位置 offsetTop：对象相对于版面或由 offsetTop 顶端位置 *///document.write(ev.clientX-can.offsetLeft); con.moveTo(ev.clientX-can.offsetLeft,ev.clientY-can.offsetTop); //当鼠标指针移动到图像上时执行一段Javascript代码 document.onmousemove=function(ev)&#123; var ev=ev||event; //lineTo() 方法添加一个新点，然后创建从该点到画布中最后指定点的线条（该方法并不会创建线条）。 con.lineTo(ev.clientX-can.offsetLeft,ev.clientY-can.offsetTop); //stroke() 方法会实际地绘制出通过 moveTo() 和 lineTo() 方法定义的路径。默认颜色是黑色。 con.stroke(); &#125; //当鼠标释放时执行一段Javascript代码 document.onmouseup=function()&#123; //鼠标释放后这些事件不再触发函数 document.onmousedown=document.onmousemove=null; &#125; &#125;&#125; 尚需改进之处1.该清除为擦除2.改变画笔颜色大小等属性3.改变画布大小4.待定]]></content>
      <categories>
        <category>计算机</category>
        <category>程序</category>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【小说】深夜派对]]></title>
    <url>%2F%E3%80%90%E5%B0%8F%E8%AF%B4%E3%80%91%E6%B7%B1%E5%A4%9C%E6%B4%BE%E5%AF%B9.html</url>
    <content type="text"><![CDATA[灰绿色的黑板上写满整齐而整洁的白色粉笔字，物理老师正费尽心思地讲解着那道容易犯错的大题。他流畅通俗的话语填充着整间教室，却如同幽灵一般徒劳地从郑石奕的左耳钻进，右耳钻出。他的大脑正沉迷于自己杂乱纷繁的思绪，丝毫没有思考这些不速之客的欲望。理智在谴责大脑不顾自己的职责，愚蠢地浪费着自己的时间。怠惰的大脑扬起嘲讽的微笑，对此等言论不屑一顾。人的一生中有多少时光是在毫无意义的消磨中度过？又有多少时光确确实实地在做着所谓有意义之事？这种事情根本毫无定论，若要深究必然会牵扯到何为意义的争辩。对于读书不多，阅历尚浅的郑石奕同学，就此打住方才是最佳抉择。郑石奕嘴巴微张，极为隐秘地打了一个哈欠。身为学业繁重的高三党，郑石奕却是一个非常讨厌上课的家伙。讨厌的原因很简单，唯无趣二字而已。这里有听上去天真幼稚，令人发笑，却又不可谓之无理。无趣便难以集中精力，精力不集中便无法认真听讲，如此自然便会走神发呆，然后陷入浪费时间的可笑自责当中。明明知识很有趣，老师讲得也算不赖，但他那“寻欢作乐”的大脑却很不耐烦，仿佛那是什么恼人的虫子，恨不得退开十万八千里，否则必会遭受其害。的确算是害呢。郑石奕想到了即将来临的模拟测验，不禁叹了口气，转头望向身边的玻璃窗。玻璃上映着堆满书籍的明亮教室，听课的人、记笔记的人、自顾自写作业的人、悄悄看课外书的人……窗外是无穷无尽的夜色，一片漆黑，仿佛一张极黑的幕布将这间教室紧紧包围。忽然，黑色的夜与明亮的影像之间浮现出一张棕色的中年大叔的面庞，正面无表情地盯着他。郑石奕有些疑惑地眨了两下，然后意识到那是自己班主任的脸，双手一颤，连忙转头，坐直，盯着讲台上讲得起劲的物理老师，假装自己在认真听课，直到余光瞥见班主任已不在窗外后，方才如释重负地长吁一口气，挺得笔直的腰背立刻松懈下来。物理课一结束，郑石奕便迫不及待地离开座位，跑到教室外的走廊上，贪婪地呼吸着新鲜空气。其实外面的夜色并没有郑石奕所想的那么漆黑，反而透着一层绚丽的玫瑰红，仿佛晚霞尚未消逝的遗体。他安静地趴在带有些许凉意的栏杆上，百无聊赖地看着不远处的高大樟树在夜风中微微摇曳。形形色色的人从他的身边走过，接水的、上厕所的、嬉戏玩闹的……空气中尽是轻松愉悦的氛围，似乎忍耐了四十五分钟的情绪全部被倾倒在这短暂的十分钟间隙中。“你听说过最近那个特别火的怪谈吗？”旁边两个人的对话吸引了郑石奕的注意力。虽然郑石奕为偷听他人之间的对话感到抱歉，但是他对怪谈之类带有神秘色彩的玩意怀有异乎寻常的兴趣。这些并不存在的幻想总能够使他的思绪活跃起来。“哪个？”“就是那个突然出现的神秘纸条。”“唔，我知道了。收到纸条的人晚上会莫名奇妙地来到一间无人的教室，对吧？”“对的，而且听说每次教室里都不尽相同，有人见到的教室空无一人，有人则遇到了恐怖的影像，还有人看到的是好几台上个世纪的街机。”“这种事情大多是以讹传讹的吧，估计就是几个人压力太大，又碰巧做了几个类似的梦。顶多作为消遣听听。”“说得也是。”神秘纸条？无人的教室？听起来像是三流的校园传说，一点新意也没有。郑石奕还想了解更多的信息，可惜上课铃不合时宜地响起，休息时间已然结束。周围的人匆忙地赶回教室，他也只能怀着遗憾的心情转过身，走进逐渐安静却仍然躁动的教室，回到自己的座位上，开始了为期两个小时的自习时间。 上面曾说过，郑石奕同学喜欢怪谈。冷酷的现实主义风格抹上一笔浓厚的幻想色彩，犹如在不见天日的漆黑矿井中流传的黄金的传说，哪怕毫无可信度，也足以让人欲罢不能。黄金是人人都爱的，但未必人们都能寻找的这虚无缥缈的黄金。与其荒废漫长的毫无意义的时光去挖掘那几粒少的可怜的黄金，还不如去鼓捣那些前人早已深受其益的大众玩意儿，省的将自己的人生白白砸进深不见底的坑中。郑石奕倒是不太介意虚度时光，毕竟他至今也无从得知该如何消磨自己的人生。怪谈的美妙之处在于，角度扭曲，故事荒谬，人也疯狂。而人均无神论者的中学生自然不会把这种可笑的故事当真，作为繁重学习后的美味点心也未尝不可。然而，若是荒谬故事像一块湖边石子儿打破了湖面的平静，那更能让百无聊赖的人们欢呼雀跃。因此在自己的桌子上发现那张纸条的瞬间，郑石奕的嘴角不自觉地扬了起来。不过很快他便意识到了这也许，不，绝对只是某一个无聊至极的家伙无聊至极的恶作剧。纸条是折叠的，外面画着一张简易的笑脸——两个空洞的椭圆圈下一张夸张地咧开的大嘴。虽然很是简陋，却意外地有一种诡异的感觉。郑石奕展开纸条，里面用不怎么好看的钢笔字写着短短八个字：“今晚零时，不见不散”没有署名，连地点信息都不全。郑石奕又仔细看了看这张字条。纸似乎只是从随处可见的草稿本上随意撕下来的，并无特殊之处。至于上面的字迹，郑石奕的确感觉非常熟悉，却怎么也想不起来在何处见过。郑石奕随手将字条塞入兜中，也懒得去询问是谁将纸条放在他的桌上。对于这种恶作剧，最好的解决方法就是视而不见。对，视而不见，忽略过去。他花费了比平时多一倍的时间完成并不是很难的数学作业，又抽出一张毫无难度的物理试卷一直做到自习结束的铃声打破那令人焦虑的安静，一如既往地随着人潮回到宿舍，刷牙洗脸，与室友稍微聊上几句，便准时上床躺进柔软舒适的被窝中，闭上困倦的眼睛，准备进入睡眠的深渊。事实证明，有些东西越不去想，它便越是死缠烂打。郑石奕平躺在床上，控制着自己的呼吸平缓流动。此时无事可做，意识更为愉悦地疯狂涌动，如同脱缰之马，片刻不息，仿佛一停下思考，死亡便会降临。荒谬的怪谈，无聊的恶作剧，说到底尽是些可笑的事情。明明身体已经如此疲惫，眼皮沉重得根本无法睁开，为什么大脑还在乐此不疲地思考着这些？现在的他唯一想做的事情只有睡觉。可是人类究竟是如何进入睡眠的呢？此时此刻，他竟无从得知。睡觉，连出生的婴儿都能轻易做到，如今他竟然丧失了这等能力。郑石奕第十一次入眠失败，焦躁地翻了个身后，忍不住低声咒骂一句，似乎唯有如此方能发泄心中的郁闷。他深深地呼吸着，终于决定放弃挣扎，任由意识肆意奔流，天马行空。夜晚漫长，他终不可能彻夜不眠。 当郑石奕再次睁开双眼之时，他也说不清自己是否已经睡过一回，只觉得如今睡意全无，浑身轻松。眼前依旧是一片昏暗，纯白的天花板在不胜寒的高处默然不语，以一种冷漠无情的姿态回以凝视。有些生锈的电风扇高悬于天花板上，影子被月光拉的极长。不知何处吹来的风带着些许凉意渗入他的肌骨，让他不禁打了个寒颤。似乎……不太对劲。郑石奕意识到了什么，猛地坐起身子，有些茫然地环顾四周。他并不在宿舍里。这是一间无人的空教室。黑板上十分干净，像是被人特意擦过了一般。桌椅整整齐齐的摆放着，无论是桌面还是抽屉中都是空无一物。白瓷砖铺成的地面一尘不染，倒映着澄澈的月光。整间教室仿佛是刚刚打扫完成的一样。窗户全部洞开，风便是从此处吹进。而他自己，正穿着今日白天穿的衣服，不知所措地坐在教室中央的桌子上。忽然，他感到浑身毛发悚立，喉咙发紧，原先困惑的脸上流露出恐怖惊惧的神情。那是一个漆黑的影子，正站在敞开的窗户边上，脸上戴着一副白色的面具，面具上用黑色的线条画着一张简易的笑脸，两只空洞的椭圆圈下面一张夸张的大笑。冷清的月光洒落在他身上，却只能看见模糊且漆黑的人体轮廓。“你是谁？”郑石奕听见自己声音漂浮在昏暗的空中，就像是另一个人的呓语。“无名之辈。”那黑影回道。他的声音虚无缥缈，分不清年龄性别。“零时已到，请客人出示邀请函。”邀请函？郑石奕微微一愣，左手下意识地伸进兜中。他摸到了一张折叠起来的纸条。是那张他以为是恶作剧的神秘纸条。他取出纸条，放在手心。一阵夜风拂来，吹落了纸条。郑石奕俯身去捡，却发现纸条自己燃烧起来，蓝色的火焰在空中摇曳。此时众多桌椅向着中间汇聚，化作一棵巨大的树干，舒展开繁茂的枝叶，金黄色的光粒从枝叶上洒落，如同精灵般在空中舞动。各种颜色的粉笔纷纷从盒子里飞出，在灰绿色的黑板两端书写各种各样的诗歌，中间则画了一扇古怪的木门。一个涂着金色脸谱的杂技演员推开门，吐着赤红的火焰迈进教室，崭新的钢琴也歪歪扭扭地紧随其后，黑白琴键流畅地跃动着，弹奏着《蓝色多瑙河》的优美旋律。穿着紫色礼服的骷髅坐在钢琴上优雅地拉着小提琴。随后形形色色的人鱼贯而入——头顶着巨大显示屏的机器人，手持金刚经的黑熊，头戴华丽王冠的雕像女王，还有几只颜色全然不同的史莱姆……最后是十二生肖举着冒着香气的食物排成一排走进来。整间教室像是一只沉睡的怪兽苏醒过来，一下子热闹了起来。郑石奕目瞪口呆地看着眼前荒诞不稽的场面，像是误入了妖魔鬼怪的夜间聚会。他回头望向窗边，却发现所有的窗户全都变成了色调阴暗的抽象油画，而那个戴着诡异笑脸面具的黑影早已不知所踪。正当他一脸茫然地杵在原地时，似乎有什么软软的东西碰到了他，低头一看，只见一团毛茸茸的不明生物正费力地顶着一个木质托盘，托盘上摆放着好几杯盛有五颜六色液体的玻璃杯。郑石奕挑了一杯颜色看起来不那么奇怪的，那团不明生物便一蹦一蹦地离开了，托盘上的液体剧烈地晃动着，似乎随时都会溅出来。郑石奕看着手中冒着白色气泡的液体，小心翼翼地抿了一口。烤肉味。他皱着眉头嫌弃地将玻璃杯放在一张毫不起眼的老旧桌子上。“欢笑！舞蹈！拥抱！”杂技演员跳到讲台桌上敞开双臂高声呼喊。喊罢，他将头向后一扭，又迅速转回来，金色的脸谱变成红色，引得台下观众情绪高涨。领队的骷髅绅士丢下手中的小提琴，不知从何处掏出了金灿灿的小号。一架会动的爵士鼓也凑到了钢琴边上，鼓槌在空中不停地旋转。高亢的小号响彻教室，激昂的鼓声与肆意的琴音即兴交织，演奏出欢快美妙的爵士乐。似乎有某种无法诉说的神秘魔力蕴含在这爵士乐中，教室里的宾客纷纷都毫无顾忌地随着旋律扭动着自己的身体，就连一直与四周格格不入的郑石奕也情不自禁地胡乱摇摆起来，甚至一不小心撞翻了放在桌上的饮料。“欢笑！舞蹈！拥抱！”一时间，放肆自由的欢笑声、鞋子与地面的摩擦声、金属饰物的碰撞声……那些洋溢着激情愉悦的声音全部缠绕在一起，没入即兴的美妙爵士乐中。郑石奕踩着乱七八糟的舞步游走在狂欢的人群中，时不时地学着其他人从桌上的盘子里那几粒奶糖塞入口中，或者混在人群中观看有趣的皮影戏，甚至一不小心还被亢奋的黑熊抱住在空中旋转几周。他发现教室后方有一大群家伙正聚在一起，全神贯注地看着什么，便好奇地挤进拥挤的人群中。在细小的缝隙中，他隐隐约约看见一个万年不变严肃神情的秦陶俑正在与人掰手腕。而他的对手却是一个一两岁左右的小屁孩，咬着黄金奶嘴，浑身只穿了一条尿不湿，一脸痞气。看似差距悬殊的双方却意外的陷入了持久的鏖战，用锐利的眼神注视着自己的对手，紧咬牙关。忽然，小屁孩狰狞一笑，粗短的手臂迅速隆起了强壮的肌肉，然后以迅雷不及掩耳之势将陶俑的手臂压倒。人群中响起了一片充满遗憾的叹息声，似乎在为陶俑的失败感到可惜。“还有那个不识相的敢来挑战我？”小屁孩吐掉口中的奶嘴，双臂抱胸，翘着二郎腿，仿佛古惑仔一般靠在椅子上。奔放的爵士乐逐渐归于沉寂，嘈杂的人声躁动不安，然而四周无人敢应。郑石奕略微感到无趣，正打算转身挤出人群之际，却被后方围观的人一撞，撞到小屁孩面前，四周立刻爆发出一片掌声。“那么，你就是下一个挑战者喽？”小屁孩用极为地道的粤语问道。他从尿不湿中掏出一个果糖制成的奶嘴叼在嘴上，眯着眼睛上下打量着手足无措的郑石奕：“看起来不怎么样嘛！”郑石奕连忙摆手表示这不过是一场意外。“意外？”小屁孩不屑地摇摇头，右手肘顶在桌子上，摆好了十足的架势，“我的词典里没有意外，只有必然。”郑石奕看向四周，每个人都用期待的眼神注视着他，喊话怂恿他去接受挑战。他们在期待着一场好戏，一场能够让他们津津乐道的好戏。似乎明白自己终究无法逃避这场挑战，郑石奕认命般地坐在对面的椅子上，甩甩自己的右手，然后深吸一口气，握上了小屁孩的右手。贝斯低沉的声音混杂着厚重的鼓声悄悄开始震动着，飞舞的光粒极富节奏感闪动着七彩光芒，仿佛郑石奕有些急促的呼吸。“预备，开始！”在沉重的钢琴音犹如陨石般降落的瞬间，郑石奕感到一股难以抗衡的巨力向自己的手臂压来，像是要将他彻底压垮。然而，他并没有成功。郑石奕的右臂缓缓下沉，却依旧在死死坚持，仿佛有什么疯狂的东西在其中挣扎，反抗着这股强大的力量。一种莫名的情绪在郑石奕的胸口激荡，使得他的嘴角不自觉地扬起了夸张的笑容。他坚定地注视着傲慢的小屁孩，被压制的手臂不再下沉，反而有种要开始反制的趋势。旁边的观众们用纷纷开始叫好，在流畅且充满力量的摇滚乐中为其鼓舞。“笑容不错嘛。”方才还显得游刃有余的小屁孩面色稍微有些凝重起来，“然而，无用的挣扎。”他咔擦一声咬断自己的奶嘴，狰狞的笑容再次浮现，浑身肌肉猛地隆起，难以置信地从婴孩模样膨胀成一个一米八的肌肉壮汉，巨大的力量再度压制住郑石奕的手臂。一座巍然不动的巨岩。郑石奕的额头冒出了细密的汗珠。他死死盯着小屁孩那狰狞且认真的眼神，脸上的笑容愈发夸张，嘴角扭曲得甚至有些诡异。他浑身上下的每一粒细胞都在微微颤动，似乎在向大脑传达着无法理解的兴奋。钢琴的节奏不断加快，沉重的贝斯依旧自顾自地震动着。巨岩开始震动了。僵持许久的局势又一次被打破，郑石奕的右手正在逐渐往回扳。傲慢的笑容从小屁孩的脸上消失了，只剩下凶恶狰狞的神情。他用尽全力想要挽回自己慢慢失去的优势，却发现手上传来的力量越来越强大。“扳倒他！扳倒他！扳倒他！”钢琴快速且肆意的弹奏着，观众们挥舞着手臂疯狂呐喊，渴望着打破寻常的胜利。在狂躁的电吉他犹如雷霆般炸裂的瞬间，郑石奕仿佛宣泄着压抑的情绪一般，爆发出一声歇斯底里的怒吼，将小屁孩粗壮的手臂狠狠地拍在桌上，甚至砸出几条裂痕。“赢了！”震耳欲聋的欢呼声如同浪潮席卷整间教室。无论围观的人还是不明所以的人都陷入了狂欢之中，疯狂地摇晃着自己的身体，仰头狂饮颜色奇怪的饮料。史莱姆变幻出各种各样的形态，从最右边弹跳掉最左边，然后又从最左边跳回最右边；机器人用油漆往自己的身上喷上各种颜色的图案，巨大的显示屏闪着雪花在不断地前后摇动；黑熊头顶着空的蜂蜜罐，随着音乐扭动着自己的腰臀；雕像女王不顾身份地抱着还是一脸严肃的秦陶俑一顿狂吻，华丽的王冠早已不知所踪；骷髅绅士撕开了黑色的礼服，在晃动的钢琴上弹奏着贝斯，与身为电吉他手的老僵尸一起前后甩头……肆意宣泄的摇滚乐与人们的呐喊揉作一团，充斥在教室的每一个角落。郑石奕坐在这愈演愈烈的狂欢之中，疲惫地倚靠在椅子上，仰头望着映着如鬼怪般舞动的黑影的天花板，脸上依旧是夸张的笑容。无数混乱的声音如同混沌的低语在他脑海中嗡嗡作响，整个教室开始天旋地转，所有的光线，所有的声音，都坍塌进无边的黑暗中，消失不见。 当郑石奕醒来的时候，映入眼帘的是寝室的天花板，亲切而又熟悉。他呆呆地望着昏暗的天花板，一动不动，似乎尚未从混乱的睡梦中清醒。过了好一会儿，他才深深地呼吸了一口气，左手在枕边不断地摸索着自己的手表，然后在昏暗的光线下费力凝视着表盘。六点二十七分。他该起床了。郑石奕从床上坐了起来，环视着昏暗的寝室。寝室里十分安静，他的室友们依然处于安稳的睡眠中，耳畔安静得只有平缓的呼吸声在空气中游荡。他的床铺靠近窗户，所以他小心翼翼地将窗帘撩起一点点，想让外面的光线稍微进入一点这个昏暗的房间，可又怕一下子太亮以至于惊醒室友。窗外太阳还尚未升起，东方泛着微白。街道上空无一人，只是偶尔有一辆黄色的出租车驶过，呼啸声震荡着清晨的空气，犹如世界的一个小哈欠。房屋依旧鳞次栉比，数以千计的玻璃窗整齐地排列在铅灰色的水泥墙上，仿佛百眼巨人那些令人生畏的眼睛。整个世界似乎还在美好的梦境中沉睡。郑石奕呆呆地坐了一会儿，便开始穿上放在床头的衣服，在柔软的被子叠得整整齐齐，尽量小声地走下床，避开地上胡乱摆放的拖鞋，走进卫生间刷牙洗脸。昨天的自习课效率极低，落下了一堆尚未完成的事情。今天还有两个小测试，以及他最讨厌的英语课听写。上次考试后的错题还没有整理，虽然并没有看的时间。模拟测试在一周之后，他可不能在因为粗心丢掉许多的分数。食堂的饭菜最近似乎有些难吃，不过好在他的辣酱还能挺一段时间……当郑石奕整理完自己翘起的头发，所有思绪一消而散。他看着镜子中面无表情的自己，做了一个夸张至极的笑容，然后迈着大步伐走出了寝室。]]></content>
      <categories>
        <category>我的小说</category>
        <category>短篇</category>
      </categories>
      <tags>
        <tag>我的小说</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【读书】骆驼的后背——舞会男女的荒诞戏剧]]></title>
    <url>%2F%E3%80%90%E8%AF%BB%E4%B9%A6%E3%80%91%E9%AA%86%E9%A9%BC%E7%9A%84%E5%90%8E%E8%83%8C%E2%80%94%E2%80%94%E8%88%9E%E4%BC%9A%E7%94%B7%E5%A5%B3%E7%9A%84%E8%8D%92%E8%AF%9E%E6%88%8F%E5%89%A7.html</url>
    <content type="text"><![CDATA[《骆驼的后背》是一篇构思极为精妙的短篇小说，作者通过一系列的巧合和误会，为我们展现了一场荒诞华丽的闹剧。 我的分析故事的开篇，作者用上帝视角为我们大致介绍了故事的男女主人公、故事所处的环境以及两人所陷入的情感困境，然后将镜头逐渐放缓，开始接入现实，让人物“自己动起来”。这种写法很是常见， 菲茨杰拉德先生很快便将男女主人公的面临的困境展现在我们面前。他们之间暂时无法解决的矛盾和贝蒂的姑姑的电话使得佩里先生离开，漫无目的地开车，并且遇见了第一个推动剧情的引路人贝利先生。贝利这个人物本身便带有一种玩世不恭的混混气质，这样的角色一般具有提供情报，出谋划策（虽然大多是馊主意）的功能。在小说中，他的出现不仅让佩里的心情不再那么郁闷，也为给予了佩里下一步行动，即参加化装舞会。当然，此处他提到了两场舞会，也为下文佩里先生第一次走错舞会埋下伏笔。 临时决定参加一场马上就要开始的化装舞会是非常仓促的一件事。首先解决得化装问题，毫无准备的佩里先生只能赶去即将打烊的服装店。骆驼服装这个主意算是意外之选，想要的没有，其他的有太过大众，这件服装的出现恰到好处。而需要两个人穿的设定使得司机加入了故事主线。而此处也提到了贝蒂小姐已经前往舞会。由于过于仓促，佩里先生并不知道化装舞会的位置，并意外走错，来到前文提到另一个舞会。虽然走错舞会引发了一系列骚动，但是最终还是到达了目的地。而且佩里先生也因此被误认为是一个从纽约来的建筑师，从而得到不明真相的贝蒂的关注。 菲茨杰拉德笔下的舞会依旧是那么的热闹、华丽，带着一种极尽热情奢华的风味。贝蒂与骆驼之间的交流，骆驼滑稽的舞蹈……舞会的最后人们把选为‘欢乐女神’的贝蒂嫁给被选为‘愚蠢之神’的佩里。一场玩笑般的假婚礼拉开序幕，送亲，牧师主事，结婚证，戴戒指……然而由于佩里先生口袋中的那份结婚证书，这场假婚礼变成了真婚礼。欢乐的氛围由此切换成愤怒，震惊，嘈杂的场景，小说也由此达到了高潮。佩里与贝蒂两人的矛盾也疯狂地激化，最终甚至要关系破裂。然而此时，骆驼是由两人装扮的这个性质派上了用场。骆驼的后半身，那个司机与佩里先生通过一种荒诞可笑的方式，让贝蒂回心转意，完成了最终的反转。这完全是出乎意料之外，却又在情理之中的事情。让人不得不为之惊叹。 我的解读正如前文所述，这个短篇的结构极为精妙，文笔也非常华丽。故事荒诞可笑，又不失合理。文章以结婚作始，又以结婚作结，中间夹杂这荒谬、热闹的化装舞会。这种戏剧化的表现手法使得整个故事精彩万分。佩里先生与贝蒂小姐之间的矛盾围绕着结婚二字。一个想要结婚，一个却放不下自由生活。这样的矛盾即使在当今社会也是屡见不鲜。婚姻带来责任与约束，而那个时代或者说当今时代的年轻人似乎都不愿意背负这些。比起严肃的、神圣的诺言，也许化装舞会上的可笑婚礼更能受人青睐。这种戏剧化的演出也表现出了整个社会中娱乐至上的风气。]]></content>
      <categories>
        <category>小说阅读</category>
        <category>短篇小说</category>
        <category>菲茨杰拉德</category>
      </categories>
      <tags>
        <tag>小说阅读</tag>
        <tag>短篇小说</tag>
        <tag>菲茨杰拉德</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【观影】波西米亚狂想曲——传奇的皇后乐队]]></title>
    <url>%2F%E3%80%90%E8%A7%82%E5%BD%B1%E3%80%91%E6%B3%A2%E8%A5%BF%E7%B1%B3%E4%BA%9A%E7%8B%82%E6%83%B3%E6%9B%B2%E2%80%94%E2%80%94%E4%BC%A0%E5%A5%87%E7%9A%84%E7%9A%87%E5%90%8E%E4%B9%90%E9%98%9F.html</url>
    <content type="text"><![CDATA[关于我和这部电影的一些故事关于这部电影，我企盼已久。从去年12月份得知有电影后就开始期待能够引进大陆，但到二月份还没有消息，以至于我有点不抱希望。所幸这部电影今年获得了四项奥斯卡大奖：最佳男主角、最佳电影剪辑、最佳音响编辑和最佳混音，在奥斯卡奖的助力，终于有了引进大陆的消息。虽然正是上映是3月22日，但是点映这种操作让我得以在今天就可以跑去电影院享受这部电影。虽然对同性恋的镜头有所删减，但是整部电影还是看得我激动不已，甚至在电影结束之后我已经是一身汗了，而且莫名其妙浑身麻痹，大口喘气，坐在街边几十分钟动弹不得（真事）……《波西米亚狂想曲》是英国著名的摇滚乐队Queen的传记电影，以主唱弗雷迪·墨丘利（Freddie Mercury)为核心讲述了其乐队从成立到弗雷迪去世的故事。知道Queen乐队是因为荒木老师的《JOJO的奇妙冒险》。众所周知，荒木老师乐于以乐队或歌曲名命名替身，而且其品味非常不错，引得不少JO厨入坑摇滚，包括我。但是由于我听歌很少关注歌手或乐队，所以在一众JOJO歌单中，我只是把《Killer Queen》《Another One Bites The Dust》等歌曲当作众多摇滚中符合我口味的，并没有因此特别关注该乐队，直到……我听见了《Bohemian Rhapsody》，即波西米亚狂想曲。其富有歌剧色彩却又不失摇滚味道的独特风格深深地颠覆了我对摇滚乐的认知，让我记住了这个神奇的乐队，以至于当听到这部电影的消息之时，我的内心充满了期待。那么接下来就让我谈一谈这部电影。 关于这部电影的故事在我看来，这部电影是围绕这主唱弗雷迪来讲述Queen乐队的故事，所以我想先来谈谈弗雷迪。 弗雷迪·墨丘利毋庸置疑，弗雷迪是个才华横溢的人，但同时他又是敏感孤独、神经质的。弗雷迪拥有一副美妙的嗓音，这让他足以驾驭他那些华丽夸张的摇滚歌曲。他的歌喉使Queen乐队成名，但我认为真正使Queen乐队成为经典的是他那敢于冒险的勇气、令人惊叹的脑洞以及永不重复的意识。录专辑、将歌剧元素融入摇滚，让观众加入演奏……每一次尝试，每一次冒险都为他带来了极大的利益，而他也没有因此重蹈这些“有用”的套路，而是不断地自我进步，不断地向前走。实际上这一点并不只属于弗雷迪本人，整个乐队都有这样的意识。在 See,we don’t want to repeat ourselves.The same formula over and over.Formulas are a complete and utter waste of time. We’ll mix genres,we’ll cross boundaries…… 于是他们将各种风格迥异的音乐类型融入到摇滚，创造了经典的《Bohemian Rhapsody》《Love of My Life》《Another One Bites The Dust》……。正如他们所说，他们的音乐无法被定义，没有人知道皇后乐队意味着什么。正是这样一个富有创新意识，不局限于自我桎棝的乐队才创造出了他们伟大的传奇。 弗雷迪是一个歇斯底里的皇后，而不是循规蹈矩的绅士。这尽管铸就了他的传奇一生，但源自于他一生为其所困之物——孤独。弗雷迪的孤独来自于他与周围的格格不入。作为一个移民到英国的帕西人，一个同性恋（或者双性恋？），他难以成为他自己，他只能隐藏他的性向，逃避他的家庭。这种不合群的滋味，让他更加渴望家人，渴望他人的爱。然而，在他事业蒸蒸日上的同时，Mary离开了他，这使他一直深藏于内心的孤独迸发出来，而此时他也发现自己的同伴们都早已有了自己的家庭，唯有他孤身一人。弗雷迪如同一个不知所措的小男孩，盲目地召集所有“牛鬼蛇神”，企图用靡乱的永无止境的派对来填补他内心孤独的空洞。而他的出格行为却使他与世界的隔阂越来越大，被媒体指责，与同伴发生矛盾，他所追求正离他远去，而他只能在自己的孤独中不断麻痹自我。弗雷迪就是 一个害怕孤独的巴基男孩 而这个害怕孤独的小男孩终究放弃了他用来保护自我的外壳，将那些他用来麻痹自我，却将他的生活弄得乱七八糟的事物扔得一干二净。他尝试回到同伴身边，回到家人身边，道歉、接受、爱自己，尽管此时他已身患重症，时日无多。在生命的最后时刻，弗雷迪只想做音乐，他只想做他自己，为他的观众带来天籁之音。 Seconds that could be used making music which is all I want to do with the time I have left.I don’t have time to be their victim,their AIDS poster boy,their cautionary tale.No,I decide who I am.I’m going to be what I was born to be.A performer……who give the people what they want.Touch of the heavens. 我喜欢他的这一段话，我喜欢他对待人生的态度。人应该决定自己的人生，而不是成为别人想让他成为的人。正是这样一个传奇的皇后，在1985年的“拯救生命”演唱会，成就了经典，绽放出了生命绚烂的光芒，为我们留下了永垂不朽的形象。 弗雷迪·墨丘利是一个传奇。 Queen乐队我喜欢Queen乐队一起制作音乐的场景。从第一次录专辑，到《Another One Bites The Dust》的诞生，他们的音乐像是他们一起玩出来的。每个人都会写歌，每个人都能够提出自己的见解。尽管四人的风格不同，但他们却拥有相同的理念。每当某一个人有了妙不可言的灵感后，其他人都能够迅速理解，这是何等的默契。他们是家人，唯有家人才能达成如此默契。他们会争吵，会发生矛盾，但是他们之间的联系无比深厚。 弗雷迪曾经背叛了Queen乐队，但当希望回归并道歉时，布莱恩三人更像是以一种玩闹似的赌气对待弗雷迪，这让人感到弗雷迪从来没有脱离过这个团体。他们依旧能够理解对方想要什么，所以才会在那种情况下决定加入“拯救生命”的演唱会。 其实我只是想说：Queen的歌曲是属于Queen的，他们互相需要，缺一不可。 关于这部电影的制作作为奥斯卡最佳电影剪辑，《波西米亚狂想曲》的剪辑的确非常不错。恰到好处的BGM，自然且流畅的画面切换，给予了我们及其美妙的视听体验。而每一段作为BGM的音乐的歌词也有着与当前场景相近的含义。 皇后乐队的美国巡演那一段剪辑得也是恰到好处。第二次在巡演与弗雷迪的私生活之间的不断切换，重叠，那种鲜明的对比更能让人感到弗雷迪内心的孤独感。 中国大陆放的是删减版，删去了不少同性恋镜头，但是如果仔细观察的话还是能够发现弗雷迪是同性恋这一事实的——望着男人的眼神、经常逛同性恋俱乐部、保罗是个酷儿，所谓“朋友”几乎全为男性……这种隐藏于画面之中的深层意味，让我回味无穷。 而电影的节奏也是非常的不错，从一开始乐队越来越成功，到弗雷迪逐渐陷入孤独的困境，在酒精和药以及派对中不断麻醉自己，以及后半期在最糟糕的低谷中幡然醒悟，最后迎来全片的高潮,在Queen的演奏中结束，非常的流畅到位。 作为高潮的20多分钟的live，看得我真是心情激荡，直感叹这票买的真值。这一段仿佛是Queen乐队最璀璨的时刻，作为全片的结尾，更让人再次体会到Queen乐队的传奇生涯，回味无穷。 结束语作为我的第一篇影评，感觉写的很糟糕，很多东西没有写到点子上。比如我知道某一点有多好却无法说出他具体好在那里，这种诉说欲望与表达之间的矛盾着实让我感到难过。不过总而言之，我很喜欢波西米亚狂想曲，也很喜欢Queen，而我想说的，仅有一点：这是一个传奇乐队的优秀传记。]]></content>
      <categories>
        <category>电影</category>
      </categories>
      <tags>
        <tag>电影</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基于js的贪吃蛇小游戏]]></title>
    <url>%2F%E5%9F%BA%E4%BA%8Ejs%E7%9A%84%E8%B4%AA%E5%90%83%E8%9B%87%E5%B0%8F%E6%B8%B8%E6%88%8F.html</url>
    <content type="text"><![CDATA[我一直很想用js写一个简易的网页小游戏，但是作为一个只写过几份js代码，连入门都算不上的蒟蒻，要我自己写的话简直天方夜谭。而网上的代码很难找到适合像我这样的小白。所幸在github上找到了一位前辈做过的前端小demo，这些完整且简单的代码着实令我受益匪浅。点击此处进入 在这些的demo中，我选择了贪吃蛇游戏，一来比较简单，二来不用其他图片素材，比较方便。 游戏点此和我之前html、css、javascript炖在一起作大杂烩不同，这份代码html、css、javascript分别放在三个文档中，清晰明了。 HTML我们先从其骨架——html文档着手。html文档中的代码并不是很多，主要做了两件事： 在&lt;head&gt;中调用js和css的文档 用&lt;div&gt;标签将网页分割成几个独立区域 12345678910111213141516&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta http-equiv="Content-Type" content="text/html;charset=utf-8" /&gt; &lt;title&gt;贪吃蛇&lt;/title&gt; &lt;script src="snake.js"&gt;&lt;/script&gt; &lt;link rel="stylesheet" href="snake.css"/&gt;&lt;/head&gt;&lt;body&gt; &lt;div id="map"&gt;&lt;/div&gt; &lt;div id="Button"&gt; &lt;button type="button" onclick="start()"&gt;开始游戏&lt;/button&gt; &lt;button type="button" onclick="stop()"&gt;结束游戏&lt;/button&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; CSS分好了区域，那么就开始用css修饰网页中需要的元素。css代码没什么需要解释的，详情看代码及注释，毕竟我也是新手。1234567891011121314151617181920212223242526272829@charset "utf-8";/*允许中文字符*/*&#123; margin:0; padding:0;&#125;/* 删除浏览器中这些元素的默认值*/html,body&#123; width:100%; height:100%;&#125;/*宽度和高度为自适应*/body&#123; position:relative;&#125;/*相对定位*//*地图区域的各种样式*/#map&#123; /*#为id选择器*/ position:absolute; left:0;right:0; top:0; bottom:50px; margin:auto; border:2px solid #000; font-size: 0;&#125;/*按钮区域的各种样式*/#Button&#123; position:absolute; left:450px;right:0; bottom:10px; margin:auto; /*border:2px solid #000;*/ font-size: 25px;&#125;/*span元素的样式*/span&#123; display: inline-block; /*border: 1px solid black; 是否显示边界*/ box-sizing: border-box;&#125;/*className为snake和food的样式*/span.snake&#123;background: blue;&#125;/*蛇的颜色*/span.food&#123;background: red;&#125;/*食物的颜色*/ JAVASCRIPTjs的代码应该算是该游戏的重中之重了。代码本身并不是很难，只是新的语言还不知道怎么用。代码流程如下： 先定义所需要的变量。 游戏开始前初始化地图、蛇和食物。 开始游戏后按周期移动蛇，并判断下一步是否为自己的身体或者食物。 吃到食物，随机显示下一个食物。 吃到自己的身体则GameOver。 当遇到按键事件，根据所按键改变方向。 具体还是看代码吧……123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134//地图大小var map=&#123; width:900, height:500&#125;;var box=&#123; width:25, height:25&#125;;//格子个数var boxNums=&#123; wNums:map.width/box.width, hNums:map.height/box.height, nums:0&#125;;boxNums.nums=boxNums.wNums*boxNums.hNums;//格子大小//蛇的身体var snake=[];//其他部分var other=[];//周期var period=200;//蛇头朝向,默认向右//0 L;1 U;2 R;3 Dvar dir=2;//页面加载完成后立即执行，即最先执行的程序window.onload=function()&#123; mapInit(); createFood();&#125;function start()&#123; //周期调用函数：每隔400ms调用一次snakeMove setInterval(snakeMove,period); //按键松开时触发事件，按照所按键改变朝向，不能向后 document.onkeyup=function(e)&#123; for(var i=0;i&lt;4;i++)&#123; if(e.keyCode==i+37&amp;&amp;dir!=(i+2)%4)&#123; dir=i;break; &#125; &#125; &#125;&#125;function stop()&#123; window.location.href=window.location.href;&#125; //地图初始化function mapInit()&#123; //获取id名为“map”的块元素，并赋予样式长宽 var map_target=document.getElementById("map"); map_target.style.width=map.width+"px"; map_target.style.height=map.height+"px"; var newSpan=null; for(var i=1;i&lt;=boxNums.nums;i++)&#123; //创造方块，并赋予样式 newSpan=document.createElement("span"); newSpan.style.width=box.width+"px"; newSpan.style.height=box.height+"px"; newSpan.id=i; //appendChild():往元素中添加新元素 map_target.appendChild(newSpan); //蛇的位置初始化 if(i&lt;=5)&#123; newSpan.className="snake"; snake.push(newSpan); &#125; else &#123; other.push(newSpan); &#125; //push():往数组的最后添加元素 &#125;&#125;//随机产生一个食物function createFood()&#123; //Math.floor()向下取整，Math.random()取0～1之间的随机数，other.length:other数组的长度 var x=Math.floor(Math.random()*other.length); other[x].className="food";&#125;//蛇移动function snakeMove()&#123; //蛇头的id var headId=parseInt(snake[snake.length-1].id); //按照当前朝向向前移动一步 switch(dir)&#123; case 0: headId--; if(headId%boxNums.wNums==0)headId+=boxNums.wNums; break; case 1: headId-=boxNums.wNums; if(headId&lt;=0)headId+=boxNums.nums; break; case 2: headId++; if(headId%boxNums.wNums==1)headId-=boxNums.wNums; break; case 3: headId+=boxNums.wNums; if(headId&gt;=boxNums.nums)headId-=boxNums.nums; break; default:break; &#125; //找到下一步元素的Id var newHead=document.getElementById(headId); //如果吃到了蛇身 for(var i=1;i&lt;snake.length;i++) if(headId==snake[i].id)&#123; alert("Game Over!"); //重新跳到当前页面，即刷新 window.location.href=window.location.href; &#125; //找到新蛇头在other中的位置 var index; for(var i=1;i&lt;other.length;i++) if(other[i].id==headId)&#123; index=i; break; &#125; //删除other中的新蛇头 other.splice(index,1); snake.push(newHead); if(newHead.className=="food")&#123; //如果吃到了食物，蛇长度加一，并随机显示新食物 createFood(); &#125; else &#123; //否则删除原先蛇尾的元素 snake[0].className=""; other.push(snake.shift()); &#125; newHead.className="snake";&#125;]]></content>
      <categories>
        <category>计算机</category>
        <category>程序</category>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>游戏</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于Linux不正常关机、软件包系统和输入法的错误]]></title>
    <url>%2F%E5%85%B3%E4%BA%8ELinux%E4%B8%8D%E6%AD%A3%E5%B8%B8%E5%85%B3%E6%9C%BA%E3%80%81%E8%BD%AF%E4%BB%B6%E5%8C%85%E7%B3%BB%E7%BB%9F%E5%92%8C%E8%BE%93%E5%85%A5%E6%B3%95%E7%9A%84%E9%94%99%E8%AF%AF.html</url>
    <content type="text"><![CDATA[不正常关机不知道今晚系统抽了什么风，直接黑屏然后出现一堆神秘代码，导致我怀着恐慌的心情强制关机。当我再次开机的时候就不再是正常开机的画面了，由于当时没有截图，只能凭借记忆与网上其他人遇到的问题写下来。若下次遇到（希望没有下次）再截图。1234/dev/sdb8 contains a file system with errors,check forced./dev/sdb8:Inodes that were part of a corrupted orphan linked list found./dev/sdb8:UNEXPECTED INCONSISTENCY;RUN fsck MANUALLY.(i.e.,without -a or -p options)fsck exited with status code 4 其实还有一些，只不过我忘记了。 不过看网上的说法，是因为电脑不正常关机后再次开机必然会出现的画面。网上的解决方法自然很多，但并非个个有效。试了许多方法后，只有这个指令有效1fsck -y /dev/sdb8 dev后面应当是显示数据损坏的磁盘。出现一大堆字符后，control-D重启即可。 软件包系统错误其实这个问题并无伤大雅，但会出现一个红色的圆圈，里面一条白色的杠，鼠标放在上面会显示：“发生了一个错误，请通过……”等字眼这东西放在桌面上也挺糟心的，所以还是上网查了解决方法。网上的解决方法是输入sudo apt-get install -f,然而当我输入yes的时候出现了一堆错误，无效。 后来当我打开“软件和更新”这个应用后，它显示了那个错误软件包系统已损坏，网上一搜，找到了解决方法。12sudo apt-get cleansudo apt-get install -f 估计原因和那个博主一样，是更新系统时没下完就关机了。 输入法错误这个错误是最让我糟心的，不仅是因为它严重影响到了我对电脑的使用以及日常计划，更在于这个问题我难以查询，因为我自己都表达不清。我找了好长时间的解决方法，甚至一度以为是上面那个问题惹得祸。所幸，最终让我幸运的找到了解决方法，当然，也知道了表述问题的方法。 问题：系统自带输入法（ibus）只能回车输入第一个预选词，不能通过数字选择备选汉字。解决方法：删除 ~/.cache/ibus/libpinyin 然后重启电脑。 PS：说实话ibus输入法真心不好用，要不是因为搜狗配liunx感觉挺奇怪的，我早就换了。]]></content>
      <categories>
        <category>教程</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【读书】《牛皮糖》——繁华时代的虚度者]]></title>
    <url>%2F%E3%80%90%E8%AF%BB%E4%B9%A6%E3%80%91%E7%89%9B%E7%9A%AE%E7%B3%96%E2%80%94%E2%80%94%E7%B9%81%E5%8D%8E%E6%97%B6%E4%BB%A3%E7%9A%84%E8%99%9A%E5%BA%A6%E8%80%85.html</url>
    <content type="text"><![CDATA[我的分析 吉姆·鲍威尔就是一块牛皮糖。 这是小说开篇的第一句话，道出了这篇小说的主角——吉姆。但何为牛皮糖？菲茨杰拉德先生并没有第一时间向我们解释，而是先写了六百多字的看似与故事无关“废话”，东拉西扯，回到主题，又谈到其他地方去，然后才向我们解释道： “牛皮糖”这个称谓，倘若在整个还没有彻底瓦解的南部邦联，那可是一个人要耗费毕生精力、用单数第一人称不断变换着花样来演绎“虚度光阴”这个义同形不同的动词才能得到的——诸如，我眼下正在“虚度光阴”啊，我已经“虚度光阴”了，我今后还会“虚度光阴”的。 是的，“虚度光阴”。这个词似乎还不够，还要加上“耗费毕生精力”，“不断变换着花样”，这不正像是一块牛皮糖吗？作者正是以一种“虚度光阴”的写法，让我们对于他所想描述的“牛皮糖”有一种更加直观的理解。 吉姆先生的童年以及青年时代是孤僻的，是在混混噩噩的自娱自乐中渡过的。菲茨杰拉德先生在带有意识流色彩的“啰嗦”写法中，以一种跨越，交错时空的上帝视角，将吉姆先生的身世背景展现出来，他的长处、他的孤僻、他的浑浑噩噩，一切都为他在后续故事中的行为动机的重要解释。 经过长时间的铺垫，主线故事终于展开了，我们的主人公吉姆先生接受了他的老朋友克拉克的邀请去参加舞会。 克拉克·达罗在小说中算是一个重要的配角——最有名的花花公子、与吉姆有交情的老朋友，他每一次出现都推动了小说剧情的发展。他的存在使得不喜欢参加舞会的吉姆有了参加舞会的正当理由。作者也是借他与吉姆之间的交谈引出吉姆的现状，以及南希的信息。还有他那上等的陈年玉米威士忌，也成为了这个故事的催化剂。甚至最后那个早已传遍的南希要结婚的消息也是克拉克告诉吉姆和读者的。可以说作者把克拉克当作童话故事中的小仙女、小精灵一样的存在。 第一个场景是昏黄的大道上，作者精致的文笔渲染出一种混沌梦幻的氛围，似乎象征着吉姆的迷茫纠结的心理状态。吉姆在他那平日里司空见惯的沉思中走向自己的修车铺，将事情的起因，吉姆目前的人际关系，以及人物内心呈现出来。作为第一个部分，小说的重要角色其实已经全部登场：吉姆、克拉克以及匆匆露了一脸的南希和梅里特。而重点描写的南希显然会成为后文的焦点。 菲茨杰拉德先生擅长描绘一场绚丽奢靡，醉生梦死的舞会。性格孤僻、无所事事的吉姆先生显然是与这样的氛围格格不入的，所以他理所当然地成为了一个旁观的局外人。只不过是一个意志不坚定的牛皮糖一般的局外人。那种热切的舞会氛围很容易感染人的情绪，酒、女人，这两样东西更是让人无法抗拒。即使暂时逃离了舞会，那种与平日迥然不同的世界所产生的魔力依旧控制着他的思绪。而此时，在繁华世界之外的一处幽静之地，吉姆先生和南希小姐有了第一次交谈，而这次交谈的主角显然是南希。经过前文多次侧面描写，我们终于可以接触到南希这个角色的内核——一个渴望独立、自由、浪漫、风度、不愿意屈居于男性之下的新时代女性形象。但作者通过她的言语与行为却让人感到她的不成熟，使这个人物更加的饱满真实。 舞会结束，但真正的高潮尚未到来。前文虽然对于吉姆的描述很多很多，但就像上面所说，他是一个局外人形象，作者只是以他的视角向我们展示他所遇到的人或事，以及他内心的变化。他是小说的主角，但不一定是故事的主角。而在舞会结束后的赌局中，吉姆真正地成为了故事的主角。这一段故事简直顺理成章，前文多次提到吉姆的才能和南希的嗜赌似乎都是在为此作铺垫。吉姆如同救世英雄般拯救了南希的钱包，这也让渴望浪漫的南希对他倾心，当然，是在酒精与舞会的催化下。而南希的那梦幻似的吻与告白，仿佛宣告着吉姆的人生达到了巅峰。 也许一场爱情真的能够让一个牛皮糖一样的浑浑噩噩的人改变，而吉姆似乎拥有了足够的动力去挣脱现有的生活。作者用了大量篇幅描述了吉姆“蜕变”的内心，仿佛又将出现一个通过自己努力实现美国梦的例子。可惜这终究是一个遥不可及的梦，会随着克拉克传来的消息破碎，之前一切的心理活动如泡沫般幻灭。 最后在炎热的天气中，吉姆再次陷入浑浑噩噩当中，像牛皮糖一样变着花样“虚度光阴”。 在这暑气熏人的大热天里，没有什么事情会重要得让人放不下的。整个人生也好比这天气一样，只要天一热起来，无论什么重大事件都会变得无关紧要了，人人都在眼巴巴地等着熬过这大热天，盼望着凉爽天气的来临，像女人用她那温润娇嫩、充满爱意的手在抚摸着自己疲惫不堪的额头一样。 我的解读菲茨杰拉德先生的著作我目前就只看完过一本，即他那部家喻户晓的《了不起的盖茨比》。那部作品中所描绘的挥金如土的奢华生活与梦醒时分的孤独迷茫之间的转换着实令我惊叹。与那部小说所相似，这个短篇中也描写了一场奢华绚丽的舞会，舞会中的男男女女沉浸在那热切的梦幻的氛围当中，虚度着他们的光阴。 吉姆，这位牛皮糖一般的人物，的确是在无所事事的生活中消磨着自己的人生。他的心态在舞会事件中不断地变化，从逃避，旁观，到被吸引，出手，再到决心改变……他的内心是在不断纠结中度过的。看似复杂，但实际上他在客观世界中什么都没做过，除了那场赌局。他做事情总是陷入他那司空见惯的沉思中，但是到了最后，他却能毫无犹豫地放弃。一繁一简之间尽显可笑与讽刺，正如同牛皮糖一般，费了大半天的劲儿，却纹丝不动。 而南希，这位向往着浪漫、自由的女性，的确是非常的富有魅力的，也是受人喜爱的。然而从她的言行和事迹中也体现了她的不成熟，没有分寸，乃至最后害了自己。她只是如同一个小女孩一般盲目地追逐着那些闪闪发光的美丽之物，拙劣地模仿着自己的偶像，却丝毫不知其背后所代表的真正意味与代价。她只是享受着自己的任性，生活在自己天真的梦中。当她真正要为自己的玩笑，自己的任性付出代价时，却是“一路哭喊着跑回城里，也吓得要死”。 在那个爵士乐时代中，向吉姆这样的牛皮糖和南希这样的姑娘并不少见，甚至在当今这个世界中，你也很容易在自己的周围找到这样的形象。他们在自己的幻梦中虚度时光，有一千万中借口沉迷于看似“安乐”的生活不愿改变。也许时代所展现的一切，已经让人们失去了自己的方向，只能浑浑噩噩的做一个牛皮糖。 我的摘记 这篇传奇故事里的主人公就是在那片像牛皮糖一样的土地上造就出来的，其具体方位大概就在上述这两座城市之间的某个地方——那是一座拥有四万人口的小城市，在佐治亚州南部已经混混沌沌地沉睡了四万年之久，在其休眠状态中偶尔也会抖动一下，喃喃自语地嘀咕着曾经在某个时候、某个地点发生过的一场战争，可惜那场战争人家早已忘却不知有多久了。 四月里的一天，在黄昏后的暮光中，一派柔和的、灰茫茫的雾霭不知不觉已从天而降，缥缥缈缈地弥漫在棉田间，笼罩在这座闷热的小城的上空，吉姆模模糊糊的身影斜倚在一排木栅栏上，一边吹着口哨，一边举头凝望着高悬在天际的月晕，月晕下是华灯初放的杰克逊大街。 当暮色越来越浓、渐渐化作了蓝色的背景衬托着一轮明月时，他漫步徜徉在这座热气熏人、到处散发着扑鼻的辛辣气味的小镇中，朝杰克逊大街走去。各家店铺都在忙着关门打烊了，最后的那批购物者也在四散离去，踏上了回家的路，整个这一幕似乎给人以一种如梦如幻、天地在轮回旋转般的感觉，如同坐在儿童游乐场里慢悠悠地运行着的旋转木马上一样。远处的街头集市已经摆出了一长溜五颜六色、灯火通明的摊位，也为这夜色带来了一阵阵杂乱喧闹的乐声——有马戏团的汽笛风琴奏出的东方舞曲，有畸形动物展览馆门前吹响的令人感伤的喇叭声，也有手摇风琴拉出的《回到田纳西老家》这首歌欢快的乐曲声。 看见她双手叉腰站在那儿，低声说了句什么，接着便哈哈大笑起来。那人也跟着笑了起来，吉姆心头刹那间泛起了一股以前从未体验过的非常怪异的刺痛感。似乎有一道光芒从那一对人之间倏地一闪而过，那是片刻之前还让他感到温暖的那个太阳射出的一道美丽的光束。牛皮糖顿时觉得自己就像是长在阴暗处的一棵杂草。 牛皮糖踱出屋子，来到外面游廊上的一个谁也不会来光顾的角落里，那里很幽暗，恰好处于洒满草坪的月光与舞厅透着光亮的那个单扇门之间。他在那里找了一张椅子坐下来，然后便随手点起了一支香烟，任由自己毫无头绪的思绪渐渐陷入了沉思冥想之中，那是他平日里司空见惯的一种情绪状态。 他“啪”的一声又把灯关了，走到窗前，两只胳膊肘撑在窗台上，两眼茫然地望着越来越深邃的清晨时分的天际。随着情感的渐渐复苏，他感受到的第一个直觉是一种没出息的沮丧感，一种隐隐约约的痛楚，觉得自己的人生简直太灰暗了。似乎有一堵高墙突然拔地而起，而且在不断向他逼近，把他团团围在了垓心，那是一堵实实在在、伸手可及的高墙，如同他那一贫如洗的房间里的那堵白色的墙壁一样。]]></content>
      <categories>
        <category>小说阅读</category>
        <category>短篇小说</category>
        <category>菲茨杰拉德</category>
      </categories>
      <tags>
        <tag>小说阅读</tag>
        <tag>短篇小说</tag>
        <tag>菲茨杰拉德</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于在linux环境下搭建博客这件事]]></title>
    <url>%2F%E5%85%B3%E4%BA%8E%E5%9C%A8linux%E7%8E%AF%E5%A2%83%E4%B8%8B%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E8%BF%99%E4%BB%B6%E4%BA%8B.html</url>
    <content type="text"><![CDATA[去年六月高考结束后，我曾天真地以为自己终于可以勤劳地更新自己荒废一年半的博客了，然而由于各种各样的理由（好吧，就是因为我懒），写完一篇html的文章后，我再次荒废了半年。如今当我终于想起自己还有一个在角落里吃灰的博客时，它罢工了，而我至今不晓得它到底犯了什么毛病。不过呢，最终在我诚心诚意的不懈努力下（其实并不），它莫名其妙地好了。首先让我来展示一下我遇到的这个错误：12ERROR Local hexo not found in ~/MyHexoBlogERROR Try running: &apos;npm install hexo --save&apos; 当然，因为我原先是在Cloud9上写的博客，所以并不是in ~/MyHexoBlog，不过没什么区别。遇到自己无法解决的问题，第一步当然是百度找解决方法。然而网上的方法全试过一遍后，Cloud9的bash完全瘫痪，而此时我已经受够了Cloud9，并且决心将文件转移到本地——我的Ubuntu系统上，此过程相当于重新搭建一个博客，不过也省了很多步骤。使用hexo搭建blog并且托管到github上总共分三个步骤：1.安装nodejs和npm2.搭建本地的hexo3.安装并配置git 安装nodejs和npm12sudo apt-get install nodejssudo apt install npm linux上安装这些似乎都需要加上sudo，sudo可以使一般用户获得部分root权限，而用户只需要输入自己的密码。输入这两个命令后，nodejs和npm就安装完成了。如果你并不能确定自己是否已经安装成功，那么你可以通过以下node -v和npm -v这两句命令行检验一下。这两句命令是用来查看nodejs和npm的版本的，如果出现了1234kermit@kermit-VGN-CS33H-B:~/MyHexoBlog$ npm -v3.5.2kermit@kermit-VGN-CS33H-B:~/MyHexoBlog$ node -vv8.10.0 这样的结果，说明你已经安装成功了。 搭建本地的hexo1npm i -g hexo-cli 这一步似乎只有这一条全局安装的命令。由于我是转移自己的博客文件，所以我直接将自己的文件覆盖上去。 安装并配置git1sudo apt-get install git 这一条是用来安装git的，这不必多说。接下来就是配置git了，在此之前你必须确保自己有一个github账号，并且新建一个仓库（Repositories），仓库名为注册名.github.io。以上步骤结束后，你就可以执行12git config --global user.name &quot;你的github用户名&quot;git config --global user.email &quot;你注册github时使用的邮箱&quot; 然后需要修改你博客文件中的配置文件_config.yml，找到Deployment一栏，将其修改为:123456# Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy: type: git repository: git@github.com:你的用户名/你的用户名.github.io.git brach: master 其实到这一步就可以结束了。但浏览网上的教程都有配置SSH这一步，SSH是一种远程连接工具，在这里的作用是让你免密连接github。要配置SSH，第一步当然得先安装SSH。1sudo apt install openssh-server 安装完成之后就可以直接生成你的SSH密钥。1ssh-keygen -t rsa -C &quot;你注册github时使用的邮箱&quot; 生成密钥后，你需要将公钥添加到你的github账户中。当然在此之前，你可以通过ssh -T git@github.com这条命令检验密钥是否成功生成。首先通过cat ~/.ssh/id_rsa.pub命令得到你的公钥。然后在你github个人账户的settings中，选择SSH and GPG keys这一项，点击New SSH key,自拟题目，并将公钥粘贴到下栏，记得公钥包括最后的邮箱。 到此为止，博客搭建完成，你只要进入你的blog文件夹，然后用hexo指令尽情书写你的博客即可。 本应如此，然而也许是因为我直接将文件覆盖上去，最初的那个错误依旧挡住了我的道路。于是我再一次将网上的方法试一遍。网上大多数方法就是输入系统给你的建议npm install hexo --save,然而对我这种情况并没有改善。另一种方法是删除node_modules文件夹，然后使用npm install指令。这一次，方法奏效了。可喜可贺，可喜可贺。]]></content>
      <categories>
        <category>教程</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Blog</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[kxj's first website改]]></title>
    <url>%2Fkxj-s-first-website-%E6%94%B9.html</url>
    <content type="text"><![CDATA[放假之后重拾了HTML，结果发现自己差不多忘了个精光，所幸我本来学的本就不深，重新学习也不需要花费多少力气。只不过现在稍稍比之前深入那么一点点后，便触碰了CSS。CSS不愧为网页的皮肤，我用CSS将原来写的第一份HTML代码加以修改后，代码减少了100多行。此处是我修改后的网页 接下来呢，就是我的代码喽123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153&lt;!-- saved from url=(0077)file:///C:/Users/Administrator/Desktop/It's%20me/kxj's%20first%20website.html --&gt;&lt;html&gt; &lt;head&gt; &lt;meta http-equiv="Content-Type" content="text/html; charset=UTF-8"&gt; &lt;meta http-equiv="refresh" content="30"&gt;&lt;!-- 每30秒钟刷新当前页面 --&gt; &lt;title&gt;kxj's first website改&lt;/title&gt; &lt;link rel="shortcut icon" href="./kxj's first website改_files/1191414.ico"&gt; &lt;style type="text/css"&gt; body&#123; /*background-image: url("./kxj's first website改_files/fantasy.jpg"); background-repeat: no-repeat;不重复 background-position: right bottom;图片位置 background-attachment: fixed;固定图片*/ background: url("./kxj's first website改_files/fantasy.jpg") no-repeat right bottom fixed;/*将所有的属性合并成一个语序*/ &#125; h1&#123; color: #556fff;/*字体颜色*/ font-size: 35px ;/*字体大小*/ text-align: center;/*文本位置*/ text-decoration: underline overline ;/*line-through*/ text-transform: uppercase;/*字母转换*/ text-shadow: 2px 2px grey;/*文本阴影 水平阴影位置 垂直阴影位置 颜色*/ &#125; h2&#123;font-size: 23px;&#125; a&#123; text-decoration: none;/*消除链接的下划线*/ font-size: 18px; font-weight: bold; &#125; a:link&#123;color:#0000ff;&#125;/*未访问链接*/ a:visited&#123;color:purple;&#125;/*已访问链接*/ a:hover&#123; color: #000000; text-decoration: underline overline; background-color: #ff704d; &#125;/*鼠标移动到连接上*/ a:active&#123;color: #ff0000;&#125;/*鼠标点击时*/ /*table&#123; border-collapse: collapse折叠成单一边框; &#125;*/ th&#123;font-size:23px;&#125; th,td&#123;text-align: left;&#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;Hello world&lt;/h1&gt; &lt;hr&gt; &lt;p&gt; &lt;h2&gt;We are super &lt;ins&gt;ioers&lt;/ins&gt;&lt;/h2&gt; &lt;a href="http://10.220.121.203/judge/" target="_blank"&gt;Our's website&lt;/a&gt;&lt;br&gt; &lt;a href="http://10.220.121.203/wordpress/" target="_blank"&gt;Our's blog&lt;!-- &lt;del&gt;"为什么没人设特色图片"&lt;/del&gt;//删除线 --&gt;&lt;/a&gt;&lt;br&gt; &lt;a href="http://10.220.121.203/wordpress/wp-admin/post-new.php" target="_blank"&gt;I need to eidt&lt;/a&gt; &lt;/p&gt; &lt;hr&gt; &lt;p&gt; &lt;h2&gt;Old website&lt;/h2&gt; &lt;a href="http://10.220.121.200:8080/judge/" target="_blank"&gt;Judge&lt;/a&gt;&lt;br&gt; &lt;a href="http://10.220.121.200:8080/contest/" target="_blank"&gt;Contest&lt;/a&gt;&lt;br&gt; &lt;a href="http://10.220.121.200:8080/free/" target="_blank"&gt;Free&lt;/a&gt;&lt;br&gt; &lt;a href="http://10.220.121.200:8080/noip/" target="_blank"&gt;Noip&lt;/a&gt; &lt;/p&gt; &lt;hr&gt; &lt;table cellspadding="10" border="10" width="1250"&gt;&lt;tbody&gt; &lt;tr&gt; &lt;th&gt;TC&lt;/th&gt;&lt;!-- th 表头 --&gt; &lt;th&gt;Contest&lt;/th&gt; &lt;th colspan="2"&gt;Other Oj&lt;/th&gt;&lt;!-- colspan表示合并单元格--&gt; &lt;/tr&gt; &lt;tr&gt;&lt;td&gt; &lt;p&gt; &lt;a href="https://accounts.topcoder.com/member?retUrl=https:%2F%2Fwww.topcoder.com%2Fmy-dashboard%2F" target="_blank"&gt;Login&lt;/a&gt; &lt;br&gt; &lt;a href="http://felix-halim.net/tc/index.php?rd=16747" target="_blank"&gt;How did others do&lt;/a&gt; &lt;br&gt;&lt;!-- TC题解 --&gt; &lt;a href="https://apps.topcoder.com/wiki/display/tc/Algorithm+Problem+Set+Analysis" target="_blank"&gt;The solution&lt;/a&gt; &lt;/p&gt; &lt;/td&gt;&lt;td&gt; &lt;ol&gt;&lt;!-- 有序列表 --&gt; &lt;li&gt;&lt;a href="http://bestcoder.hdu.edu.cn/" target="_blank"&gt;BC&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="http://codeforces.com/" target="_blank"&gt;CF&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="http://acmicpc.info/archives/224" target="_blank"&gt;各大OJ近期比赛汇总&lt;/a&gt;&lt;/li&gt; &lt;/ol&gt; &lt;/td&gt;&lt;td&gt; &lt;ul style="list-style-type: square"&gt;&lt;!-- 无序列表 --&gt; &lt;li&gt;&lt;a href="http://poj.org/" target="_blank"&gt;POJ&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="http://www.tyvj.cn/" target="_blank"&gt;Tyvj&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="http://www.lydsy.com/JudgeOnline/problemset.php" target="_blank"&gt;BZOJ&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/td&gt; &lt;td&gt; &lt;ul style="list-style-type: circle"&gt; &lt;li&gt;&lt;a href="http://acm.hdu.edu.cn/" target="_blank"&gt;HDU&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="http://bak.vjudge.net/index" target="_blank"&gt;Vjudge&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="http://uoj.ac/" target="_blank"&gt;UOJ&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/td&gt;&lt;/tr&gt; &lt;/tbody&gt;&lt;/table&gt; &lt;hr&gt; &lt;p&gt; &lt;h2&gt;Tool&lt;/h2&gt; &lt;a href="https://www.baidu.com/" target="_blank"&gt;Baidu&lt;/a&gt;&lt;br&gt; &lt;a href="http://fanyi.baidu.com/#en/zh/" target="_blank"&gt;Translate&lt;/a&gt;&lt;br&gt; &lt;a href="http://pan.baidu.com/disk/home#list/path=%2F" target="_blank"&gt;My cloud disk&lt;/a&gt;&lt;br&gt; &lt;a href="./kxj's first website改_files/Draw Graph.html" target="_blank"&gt;Draw Graph&lt;/a&gt; &lt;/p&gt; &lt;hr&gt; &lt;p&gt; &lt;h2&gt;&lt;ins&gt;Legendary grandmaster&lt;/ins&gt;'s blog&lt;!-- 插入字,大多浏览器类同于下划线 --&gt;&lt;/font&gt; &lt;/h2&gt; &lt;a href="http://leefir.ml/" target="_blank"&gt;Leefir&lt;/a&gt;&lt;br&gt;&lt;!-- 换行 --&gt; &lt;a href="https://yummyjay.github.io/" target="_blank"&gt;YummyJay&lt;/a&gt;&lt;!-- &lt;del&gt;&lt;/del&gt;删除线 --&gt;&lt;br&gt;&lt;!-- 换行 --&gt; &lt;a href="http://bblss123.cf/" target="_blank"&gt;bblss123&lt;/a&gt;&lt;br&gt; &lt;a href="https://kyleyoung-ymj.github.io/" target="_blank"&gt;KyleYoung&lt;/a&gt;&lt;br&gt; &lt;a href="http://unicornt.ml/" target="_blank"&gt;unicornt&lt;/a&gt;&lt;br&gt; &lt;a href="https://shinfeb.github.io/" target="_blank"&gt;Shinfeb1&lt;/a&gt;&lt;br&gt; &lt;a href="https://shinfeb.logdown.com/" target="_blank"&gt;Shinfeb2&lt;/a&gt; &lt;/p&gt; &lt;hr&gt; &lt;div id="mouse" style="bottom: 30px;position: fixed;right : 10px"&gt; &lt;object type="application/x-shockwave-flash" data="./kxj's first website改_files/hamster.swf" title="Adobe Flash Player" height="130" width="190"&gt; &lt;param name="movie" value="http://cdn.abowman.com/widgets/hamster/hamster.swf?"&gt; &lt;param name="AllowScriptAccess" value="always"&gt; &lt;param name="wmode" value="opaque"&gt; &lt;/object&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; &lt;!-- 自主招生 http://mp.weixin.qq.com/s?__biz=MzI4ODEwNjg2NA==&amp;mid=2649598162&amp;idx=1&amp;sn=10d0cdfe9ff167d7cc21aafbfc9b2245&amp;chksm=f3da78cdc4adf1db7a7994d8e7aad483ed0685368693e1b --&gt;&lt;!-- POI 官网 http://main.edu.pl/en 题解 http://www.oi.edu.pl--&gt;&lt;!-- https://zhuanlan.zhihu.com/p/23245534 --&gt;&lt;!-- 搜图网站https://pixabay.com/https://unsplash.com/http://www.iconfont.cn/plushttps://www.pexels.com/ --&gt;&lt;!-- 动画展示各种路径搜索算法 - NetSmellhttp://netsmell.com/post/pathfinding.html --&gt;&lt;!-- hexo 主题https://www.zhihu.com/question/24422335 --&gt;&lt;!-- blog question http://flowsnow.net/2016/02/02/next.mist/http://willxue.top/blog/Hexo%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B%E4%B9%8B%E4%B8%89%EF%BC%9Anext%E4%B8%BB%E9%A2%98%E7%9A%84%E9%85%8D%E7%BD%AE%E5%92%8C%E4%BC%98%E5%8C%96-20160322/#morehttp://www.tuicool.com/articles/zeIZJzvhttp://blog.csdn.net/willxue123/article/details/50994852 --&gt;&lt;!-- 编辑器 https://www.zybuluo.com/mdeditor --&gt;&lt;!--blog https://www.farbox.com/ --&gt;&lt;!-- LaTex公式http://codex.wordpress.org.cn/%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F --&gt;]]></content>
      <categories>
        <category>计算机</category>
        <category>程序</category>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Eden Resurrection]]></title>
    <url>%2FEden%20Resurrection.html</url>
    <content type="text"><![CDATA[经过一年半的停用，Eden有完全复活了呢！ 复活后的Eden并不完全用来写关于代码的事，我还会将自己的生活，喜欢的书籍，电影，番剧，还有音乐呈现其中。 偶尔我也会将自己写的短篇小说在此发布。 如果能够侥幸走入编曲的殿堂的话，那么我也会专门设置一个电音专栏（但愿我不会半途而废）。 虽然不知道会不会有人发现我在此处述说着自己的生活，但是我还是以一种无比期待的心情开始写博客。 毕竟这是一个新的开始，我的高中生涯已经结束。 有一年半砸在了竞赛上。虽然最后没有取得理想的成绩，甚至有些对不起这段岁月的努力，但是我从来没有后悔过。这是我自己的选择，而且我的目的也变相地完成了。遗憾的不过是没有一个完美的结局罢了。 后来的一年，我在小说的路上前行着，知道的越多，前途越明晰。尽管从初一开始我便尝试写小说，但知道去年，我才知道前方该如何走。可惜后来因为学习的缘故暂停了写小说，不过构思倒是记录了不少。 关于大学，我也思考了不少。为了小说生涯，我要选综合性的大学，毕竟我需要积累更多的知识。心理学本来是我的第一志愿，但是后来我明白，自己与其有缘无分，在现实条件下我只能选择有关工科的专业。因为少年的倔强，我将第一志愿改成了光电。至此，心理学于我，便成了一种情人般的存在。每当看到这三个字，我的心便会重重地一跳，思绪飘飞。有时真的在想我的选择真是少的可怜。最后的几天，请为我指一条明路吧！ 我的娱乐生活也有所改变。在动漫的坑沿徘徊许久，我终究还是义无反顾地跳了下去。这种抽象的艺术表现形式真的，真的很吸引我。我的音乐品味也从qq音乐时代的泛听，到如今网易时代的只对纯音感冒。我爱上了后摇与古典，也尝试了爵士与摇滚。对于乐器，我迷上了二胡的哀婉和钢琴的空灵。我在各个方面摸索着，只为看到这个世界上不容错过的风景。 从唯心主义者转变为唯物主义者，在无数次思考中确定自己的志向，为自己的理想主义披上现实的外衣，阅读书籍确定自己的神经症，分析自我面对痛苦的一面。我寻找着，思考着，成长着，经历了世界观，价值观与人生观的变革，改变了很多很多，终于来到了新世界的大门前。 站在这门前，我思考良久。我深知这世上比我痛苦万倍的人如恒河沙数，我是属于幸福的那一群人中，生活不如意是世间常态，而我怎能因此而自怨自艾？我的路只有一条，那就是脚下的路，我必须走下去，无论如何都得走下去，去体验快乐与痛苦。 如今，尽管成绩尚未出炉，但是我已经开始走向新的世界。 此后的日子将更多地由我自己来安排，学习、玩乐、工作……尽管会更累（毕竟是成人的世界），但我知道，这是自由的代价。 目前的希望呢，就是早点经济独立（现在说这个好像有点早了，毕竟才高中毕业）。 至于目标呢，编程的语言会继续学下去，而且顺便会学习一下电音。 当然，重中之重，我会继续写小说。无论日子如何艰难，无论将来如何坎坷，我都会继续写下去，因为小说就是我活着的方式，是我最后的王国。 愿未来的我将在自己的夜空中肆意狂笑！]]></content>
      <categories>
        <category>杂</category>
      </categories>
      <tags>
        <tag>杂</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[坠入学考的深渊]]></title>
    <url>%2F%E5%9D%A0%E5%85%A5%E5%AD%A6%E8%80%83%E7%9A%84%E6%B7%B1%E6%B8%8A.html</url>
    <content type="text"><![CDATA[VB竞赛失利，再次成为了学考生，作为信息学竞赛生，当然要选信息技术了，那么就先从VB开始喽虽然vb不区分大小写，并且还能自动排版，但是呢，写vb会经常写中文（虽然可以不打中文），所以中英文转化会非常的麻烦。VB的语法其实和C++有类似之处，其实这些类似之处不止这两门语言之间，几乎所有语言之间都有共通之处，所以只要掌握了其中精髓，我们就可很快掌握一门语言。（但这依旧改变不了我蒟蒻的事实） Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293Private Sub Command1_Click() Dim an As Integer an = MsgBox(&quot;你确定要离开我吗？TAT&quot;, 1, &quot;离开&quot;) If an = 1 Then &apos;Exit Sub &apos; 退出事件 MsgBox &quot;泪奔QAQ&quot; End Else MsgBox &quot;乖~~~~&quot; End If End SubPrivate Sub Command2_Click() MsgBox &quot;今天是&quot; + Str(Date), 0, &quot;提示日期&quot;End SubPrivate Sub Command3_Click() Dim a As Integer, i As Integer, sum As Long, pro As Long Dim flag As Boolean a = Val(Text1.Text) b = Val(Text2.Text) For i = a To b Step 1 sum = sum + i If sum &gt;= 100000 Then flag = 1: Exit For Next i If flag = True Then List1.AddItem &quot;∑a~b 结果溢出&quot; Else List1.AddItem &quot;∑a~b&quot; + Str(sum) End If pro = 1 sum = 1 i = a Do While i &lt;= b i = i + 1 pro = pro * i If pro &gt;= 100000 Then flag = 1: Exit Do Loop If flag = True Then List1.AddItem &quot;∏a~b 结果溢出&quot; Else List1.AddItem &quot;∏a~b&quot; + Str(pro) End If List1.AddItem &quot;a*b的根号&quot; + Str(Format$(Sqr(a * b), &quot;0.00&quot;)) End SubPrivate Sub Command4_Click() Label1.Caption = &quot;&quot;End SubFunction gcd(a As Integer, b As Integer) As Integer Do While b &lt;&gt; 0 Dim t As Integer t = b b = a Mod b a = t Loop gcd = aEnd FunctionPrivate Sub Command5_Click() Dim a As Integer, b As Integer a = Val(Text1.Text) b = Val(Text2.Text) Label1.Caption = &quot;最大公约数 &quot; + Str(gcd(a, b))End SubPrivate Sub Command6_Click() Label1.BorderStyle = 0End SubPrivate Sub Command7_Click() Label1.BorderStyle = 1End SubPrivate Sub Command8_Click() Label1.Font = &quot;隶书&quot; End SubPrivate Sub Command9_Click() List1.ClearEnd Sub]]></content>
      <categories>
        <category>计算机</category>
        <category>程序</category>
        <category>VB</category>
      </categories>
      <tags>
        <tag>VB</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[noip 2016 炸坑记&&OI总结]]></title>
    <url>%2Fnoip%202016%20%E7%82%B8%E5%9D%91%E8%AE%B0%26%26OI%E6%80%BB%E7%BB%93.html</url>
    <content type="text"><![CDATA[知道成绩的那一天，我其实也不是非常难过，可能是从考完到出成绩的这一个星期内，我已经有爆炸的预感了，只不过没有想到竟然会炸的那么惨。说完全没有影响心情是假的，应该是非常的遗憾和担忧，遗憾的是我的OI生活竟然会以这么一个惨烈的成绩结尾，担忧的是感觉完全不知道该怎么面对别人的询问，尤其是对我抱有期望的那些人。 总结这次比赛，虽然题目比往年难了很多，但是这个因素并没有很大的影响，因为难度并没有超过联赛的范围，平常的题目也不必这次简单。所以我感觉爆炸的原因极大部分都出现在个人的身上。 虽然所在的学校对于考试是家常便饭，但是这并没有令我养成考试不紧张的好习惯，该慌的依旧是慌，大概是我的文化课成绩一直都不太好的原因吧，太过担心自己掉链子，使得考试的时候总是非常的紧张。尽管有些比赛只是最为炮灰的而参加的，但是内心深处还是非常渴望奇迹。而对于这次联赛，这个紧张状态在初赛是就已经出现，所幸初赛并没有掉链子。然而在复赛的时候，不，是在联赛之前，就已经开始了，到比赛的时候达到的顶端，以至于这次比赛day1由于两个低级错误失掉了125分，而day2由于没有考虑精度而导致85分的丢失，总共就有210分了，这210让我在接下来的几天里都误以为自己考了500分，但是旋即惊醒，内心失落无比。幻想很丰满，而现实很残酷，蒟蒻始终是蒟蒻，心理上的劣势终究会影响实际结果。这样的结果大概时联赛的最坏情况了吧，考场和平时的训练果然不同。 算一算，我从2015年7月20号开始的OI生活，当2016年11月20号截至，共16个月的时间里，我从刚开始的什么都是一脸懵逼，到可以掌握点分治，Dinic等算法，感觉十分不可思议，有时候看着一个个本来什么都不懂的字符从我的指尖流淌而出，都变成一篇篇可以阅读，可以运行的程序，就好像自己亲自抚养的宠物，心中充满了成就感。机房里的诸位也是每天活力满满地敲题，翻译，看题解，互相膜拜，随意扯皮，时间就在听着纯音敲着代码的日子中逝去。但是失落症发作的我总会担心这样大家一起打CF，TC的日子一去不复返，结果这样的日子就真的来了。 其实我的学习历程也不是很令人满意，像去年noip的时候，我连什么dp状态都不知道是什么，更不要提什么转移了，只能凭感觉写，接下来也只不过是浑浑噩噩地写着题目，翻译，写题解，有时候写出来的题解就是错误的。看别人题解的时候，遇到像什么扫描线，期望什么当时完全不懂的东西，就会大惊小怪，仿佛是什么不得了的东西，但是实际上也不是不能够学习的，所以说心态就没有摆正，以至于前期我学习算法的速度极慢，知道暑假后的一段时间，我开始自己主动去学习算法后，这种状况在有所好转。可以说几个月前的我还是一个连蒟蒻都算不上的渣渣，最近才进化成蒟蒻的。 即使我的竞赛历程有很多遗憾，但是我却从来没有后悔过学这门竞赛。我学这门竞赛的缘由并非是为了升学，一开始是为了另一个兴趣才开始学习的，但是却也逐渐成为了我的一个新兴趣。也许如果不是当初的一个念头，我也不会接触到这个世界，并不会知道有CF，TC这种调节生活的网站，更不会知道世界上还会有程序猿这种悲剧的物种。这一切充满了巧合，却也是必然。因为这门竞赛，我的高中生活的确变得非常的充实而有趣。可能文化课方面会落下很多，但是时间还早，我补得起，而且我想，即使我没有学竞赛，我的文化课成绩也不会比现在好多少，因为我了解自己，没有压力，就没有动力，曾经如此，现在依然。 如今，我遗憾地离开，也许明年会来一雪前耻，但是至少现阶段我不得不专心与高考。起码无论如何，冬令营省队这种神奇的东西对我来说相当于痴人说梦，无形之中这对我也算是一种安慰了。之后的日子，我也没有时间在去敲代码了，但是CF能比还是会比的，TC就算了，Div1太难了，BC偶尔会比一下。希望在之后的日子里，我可以上紫吧。（上黄等奇迹……）]]></content>
      <categories>
        <category>杂</category>
      </categories>
      <tags>
        <tag>杂</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Tarjan-图的连通性]]></title>
    <url>%2FTarjan.html</url>
    <content type="text"><![CDATA[强连通分量poj 2186 Popular Cows Task给定一个有n头牛的牛群，和m个有序对（A，B）。（A，B）表示牛A认为牛B是红人，且如果牛B认为牛C是红人，那么牛A也认为牛C是红人，求被所有牛认为是红人的牛的总数。$1&lt;=n&lt;=10000$$1&lt;=m&lt;=50000$$1&lt;=A,B&lt;=N$ Solution首先这可以构成一幅有向图。然后由传递性可知，如果两只牛相互认为对方是红人，那么认为它们是红人的牛和它们认为是红人的牛都是一样的，那么我们就可以把它们缩成一个点。而只有在一个强连通分量中的牛才会且一定会互相认为对方是红人，所以我们可以用Tarjan进行强连通分量分解，并缩点，得到一个DAG。在这个DAG中我们由拓扑序得最后没有出边的点就是答案，但由于图不一定连通，所以还需要判断一下。 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475#include &lt;stdio.h&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;#include &lt;string.h&gt;#define N 50005#define M 10005using namespace std;vector&lt;int&gt;E[M];struct kxj&#123; int t,nxt;&#125;edge[N&lt;&lt;1];int n,ans,head[M],tot,cnt[M],Q[M],sz[M],dergee[M];int dfn[M],low[M],allc,stk[M],top,belong[M],sccid;void Add(int a,int b)&#123; edge[tot]=(kxj)&#123;b,head[a]&#125;;head[a]=tot++;&#125;void Tarjan(int x)&#123; dfn[x]=low[x]=++allc; stk[++top]=x; for(int i=head[x];~i;i=edge[i].nxt)&#123; int y=edge[i].t; if(!dfn[y])&#123; Tarjan(y); low[x]=min(low[y],low[x]); &#125;else if(!belong[y])low[x]=min(low[x],dfn[y]); &#125; if(low[x]==dfn[x])&#123; ++sccid; while(top)&#123; int t=stk[top--]; belong[t]=sccid; sz[sccid]++; if(x==t)break; &#125; &#125;&#125;void solve()&#123; int L=0,R=0; for(int i=1;i&lt;=sccid;i++)&#123; if(dergee[i]==0)Q[R++]=i; cnt[i]=sz[i]; &#125; while(L&lt;R)&#123; int x=Q[L++]; if(cnt[x]==n)ans+=sz[x]; for(int i=0;i&lt;E[x].size();i++)&#123; int y=E[x][i]; cnt[y]+=cnt[x]; if(--dergee[y]==0)Q[R++]=y; &#125; &#125;&#125;int main()&#123; memset(head,-1,sizeof(head)); int m,a,b; scanf("%d %d",&amp;n,&amp;m); for(int i=1;i&lt;=m;i++)&#123; scanf("%d %d",&amp;a,&amp;b); Add(a,b); &#125; for(int i=1;i&lt;=n;i++) if(!dfn[i])Tarjan(i); for(int i=1;i&lt;=n;i++)&#123; int x=belong[i]; for(int j=head[i];~j;j=edge[j].nxt)&#123; int y=belong[edge[j].t]; if(y==x)continue; dergee[y]++; E[x].push_back(y); &#125; &#125; solve(); printf("%d\n",ans); return 0;&#125; 边双连通分量poj 3352 Road Construction Task给定一张n点m边的无向图，求最少在加几条边使其不存在桥。$1&lt;=n&lt;=1000$$1&lt;=m&lt;=1000$ Solution我们用Tarjan先将图缩成一棵树，然后答案就是得到的数的叶子节点的个数除以2向上取整。 Code12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;#define M 1005using namespace std;struct kxj&#123; int t,nxt;&#125;edge[M+M];int dfn[M],low[M],tot,head[M],setID,stk[M],top,belong[M],bccid,son[M];void Add(int a,int b)&#123; edge[tot]=(kxj)&#123;b,head[a]&#125;;head[a]=tot++; edge[tot]=(kxj)&#123;a,head[b]&#125;;head[b]=tot++;&#125;void Tarjan(int x,int id)&#123; dfn[x]=low[x]=setID++; stk[++top]=x; for(int i=head[x];~i;i=edge[i].nxt)&#123; int y=edge[i].t; if(i==id)continue; if(!dfn[y])&#123; Tarjan(y,i^1); low[x]=min(low[x],low[y]); &#125;else low[x]=min(low[x],dfn[y]); &#125; if(low[x]==dfn[x])&#123; ++bccid; while(top)&#123; int t=stk[top--]; belong[t]=bccid; if(t==x)break; &#125; &#125;&#125;int main()&#123; memset(head,-1,sizeof(head)); int n,m,a,b,ans=0; scanf("%d %d",&amp;n,&amp;m); for(int i=1;i&lt;=m;i++)&#123; scanf("%d %d",&amp;a,&amp;b); Add(a,b); &#125; Tarjan(1,-1); for(int i=1;i&lt;=n;i++)&#123; int x=belong[i]; for(int j=head[i];~j;j=edge[j].nxt) if(x!=belong[edge[j].t])son[x]++; &#125; for(int i=1;i&lt;=bccid;i++)ans+=son[i]==1; printf("%d\n",(ans+1)/2); return 0;&#125; 点双连通分量bzoj 2730 矿场搭建 Task煤矿工地可以看成是由隧道连接挖煤点组成的无向图。为安全起见，希望在工地发生事故时所有挖煤点的工人都能有一条出路逃到救援出口处。于是矿主决定在某些挖煤点设立救援出口，使得无论哪一个挖煤点坍塌之后，其他挖煤点的工人都有一条道路通向救援出口。请写一个程序，用来计算至少需要设置几个救援出口，以及不同最少救援出口的设置方案总数。(by bzoj)$n&lt;=500$ Solution此题我们画出图之后可以发现非割点（割顶）的点坍塌后对结果并无影响，所以我们只用考虑割点坍塌的情况。如果一个点双连通分量中两个割点，那么我们无需在此点双连通分量中加入救生井，因为一个割点坍塌，可以从另一个割点离开。如果一个点双中只有一个割点，那么我们就必须在此放一个救生井。如果一个连通块中只有一个点双，那么此点双中将无割点，所以我们要在此点双中放两个救生井，因为一个救生井坍塌后还可以从另一个逃生。 Code边入栈：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;vector&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#define M 505using namespace std;struct kxj&#123; int t,nxt;&#125;edge[M&lt;&lt;1];int ans1,head[M],tot,dfn[M],low[M],setID;int isCut[M],root,bccid,belong[M],stk[M],top;vector&lt;int&gt;Bcc[M];long long ans2;void Add(int a,int b)&#123; edge[tot]=(kxj)&#123;b,head[a]&#125;;head[a]=tot++; edge[tot]=(kxj)&#123;a,head[b]&#125;;head[b]=tot++;&#125;void BCC(int x)&#123; bccid++; while(top)&#123; int t=stk[top--]; int a=edge[t].t,b=edge[t^1].t; if(belong[a]!=bccid)&#123; belong[a]=bccid; Bcc[bccid].push_back(a); &#125; if(belong[b]!=bccid)&#123; belong[b]=bccid; Bcc[bccid].push_back(b); &#125; if(t==x)break; &#125;&#125;void Tarjan(int x,int eid)&#123; int child=0,flag=0; dfn[x]=low[x]=++setID; for(int i=head[x];~i;i=edge[i].nxt)&#123; int y=edge[i].t; if(!dfn[y])&#123; stk[++top]=i; Tarjan(y,i^1); low[x]=min(low[x],low[y]); if(low[y]&gt;=dfn[x])&#123; child++;flag=1; BCC(i); &#125; &#125;else if(eid!=i)low[x]=min(low[x],dfn[y]); &#125; if(root!=x&amp;&amp;flag)isCut[x]=1; if(root==x&amp;&amp;child&gt;1)isCut[x]=1;&#125; int main()&#123; int n,a,b,m,o=0; while(~scanf("%d",&amp;n))&#123; if(!n)return 0; ans2=1;m=tot=top=setID=ans1=bccid=0; memset(head,-1,sizeof(head)); memset(dfn,0,sizeof(dfn)); memset(low,0,sizeof(low)); memset(isCut,0,sizeof(isCut)); memset(belong,0,sizeof(belong)); for(int i=1;i&lt;=n;i++)&#123; scanf("%d %d",&amp;a,&amp;b); Add(a,b);m=max(m,max(a,b)); &#125; for(int i=1;i&lt;=m;i++) if(!dfn[i])root=i,Tarjan(i,-1); for(int i=1;i&lt;=bccid;i++)&#123; int cnt=0,res=Bcc[i].size(); for(int j=0;j&lt;res;j++)&#123; if(isCut[Bcc[i][j]])cnt++; &#125; if(cnt==0)ans2*=res*(res-1)/2,ans1+=2; if(cnt==1)ans2*=res-1,ans1++; Bcc[i].clear(); &#125; cout&lt;&lt;"Case "&lt;&lt;++o&lt;&lt;": "&lt;&lt;ans1&lt;&lt;" "&lt;&lt;ans2&lt;&lt;endl; &#125;&#125; 点入栈：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;vector&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#define M 505using namespace std;struct kxj&#123; int t,nxt;&#125;edge[M&lt;&lt;1];int ans1,head[M],tot,dfn[M],low[M],setID;int isCut[M],root,bccid,belong[M],stk[M],top;vector&lt;int&gt;Bcc[M];long long ans2;void Add(int a,int b)&#123; edge[tot]=(kxj)&#123;b,head[a]&#125;;head[a]=tot++; edge[tot]=(kxj)&#123;a,head[b]&#125;;head[b]=tot++;&#125;void BCC(int x)&#123;&#125;void Tarjan(int x,int eid)&#123; int child=0,flag=0; dfn[x]=low[x]=++setID; stk[++top]=x; for(int i=head[x];~i;i=edge[i].nxt)&#123; int y=edge[i].t; if(!dfn[y])&#123; Tarjan(y,i^1); low[x]=min(low[x],low[y]); if(low[y]&gt;=dfn[x])&#123; child++;bccid++; isCut[x]=1; while(top)&#123; int t=stk[top--]; Bcc[bccid].push_back(t); if(t==y)break; &#125; Bcc[bccid].push_back(x); &#125; &#125; else if(eid!=i)low[x]=min(low[x],dfn[y]); &#125; if(root==x&amp;&amp;child&lt;=1)isCut[x]=0;&#125; int main()&#123; int n,a,b,m,o=0; while(~scanf("%d",&amp;n))&#123; if(!n)return 0; ans2=1;m=tot=top=setID=ans1=bccid=0; memset(head,-1,sizeof(head)); memset(dfn,0,sizeof(dfn)); memset(low,0,sizeof(low)); memset(isCut,0,sizeof(isCut)); memset(belong,0,sizeof(belong)); for(int i=1;i&lt;=n;i++)&#123; scanf("%d %d",&amp;a,&amp;b); Add(a,b);m=max(m,max(a,b)); &#125; for(int i=1;i&lt;=m;i++) if(!dfn[i])root=i,Tarjan(i,-1); for(int i=1;i&lt;=bccid;i++)&#123; int cnt=0,res=Bcc[i].size(); for(int j=0;j&lt;res;j++)&#123; if(isCut[Bcc[i][j]])cnt++; &#125; if(cnt==0)ans2*=res*(res-1)/2,ans1+=2; if(cnt==1)ans2*=res-1,ans1++; Bcc[i].clear(); &#125; cout&lt;&lt;"Case "&lt;&lt;++o&lt;&lt;": "&lt;&lt;ans1&lt;&lt;" "&lt;&lt;ans2&lt;&lt;endl; &#125;&#125;]]></content>
      <categories>
        <category>计算机</category>
        <category>程序</category>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>图论</tag>
        <tag>强连通分量</tag>
        <tag>双连通分量</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SWERC 2013 H Binary Tree]]></title>
    <url>%2FSWERC%202013%20H%20Binary%20Tree.html</url>
    <content type="text"><![CDATA[task众所周知，二叉树是一种最多含有2个子节点的树形数据结构。现在有一棵无限大的二叉树。在这棵树中，每个节点都有左右两个儿子，和一个父亲。我们称根节点的父亲是它自己。kxj极其无聊地将手指指向根节点，然后极其无聊地根据指令S移动手指。一串指令S为一个字符串，这个字符串是包含大写的L,R,U分别表示着走向当前节点的左儿子，右儿子和父亲。现在kxj又得到了另一串指令L，这一串指令从指令S结束时手指所在的节点开始移动。但是这一次kxj可以跳掉T中的任意指令(可能一个都不跳，或者全跳)。kxj想知道最终他的手指可以指向多少个不同的节点。S,T的长度&lt;=100000 solution首先我们将指令S处理一下，因为在这一条指令中是有许多无效操作，即‘U’操作，每次遇到一个‘U’就意味着往上走，那么我们可以发现我们又退回到上一个点了，那么这之间的操作都是无效的。这样我们最后处理完的指令中只有L和R，这一条指令就在二叉树中构成一条向下的路径。那么接下来我们考虑在每个深度向下走，在初始深度我们可以使用T中的所有的L和R，用这些L和R构成的不同子序列都代表着一个不同的结果。而当我们每用一个‘U’，我们都可以上去一层(root除外)，这时候我们只能往另一个儿子那边走，即如果初始点是一个左儿子，那么我们我们在我们可以用的L和R中找所有一个R开头的不同的子序列。所以其实题目就变成了在一个只有L和R的字符串中找到所有不同的子序列。对于这种题，我们可以借用trie树的思路，trie树上有几个节点就代表有多少的子序列。而trie树中为R的节点都代表着一个以R结尾的字符串。L同理。所以我们就枚举指令T，每次将trie树中一个与当前字符有关的字符串删去，然后遇到一个‘U’，就将加上此时trie树中的‘L’节点或者‘R’节点。但是有一个非常严肃的问题，我们无法做到在trie树上删点。那么根据通常的思路我们改删点为加点即可，倒着枚举指令T，然后我们就可以将每个非‘U’的字符加到当前trie树上的节点上(前提是该节点的儿子中没有这种字符)。而且实际上我们没有必要将trie数构出来，因为我们只是想知道trie树中L和R节点的个数而已。所以我们只要维护5个参数L，R，Lcnt，Rcnt，leaf 就好了。L和R分别表示trie树中L节点和R节点的个数，Lcnt和Rcnt分别表示在trie树中有多少节点是只有一个右儿子(即左儿子是空的)或只有一个左儿子(即右儿子是空的)，leaf就是叶子节点。每当我们枚举到一个‘L’，那么此时trie树上就有leaf+Lcnt个节点可以加一个左儿子。那么几个参数的更新如下：$L+=leaf+Lcnt$$Rcnt+=leaf$$leaf+=Lcnt$$Lcnt=0$枚举到‘R’同理。如果枚举到‘U’呢？假设这是正数第x个‘U’，那么我们就要看在新的S指令中的正数第x个字符什么，如果是‘L’，那么我们就为答案加上一个R+1,反之同理。但是当x大于S中字符的个数是，我们不用更新答案。最后我们还要加上一个$L+R+1$，表示在初始节点时向下走的方案数。 Code12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#define M 100005#define P 21092013using namespace std;char S[M],T[M];void Mod(int &amp;a,int b)&#123; a+=b; if(a&gt;=P)a-=P;&#125;int main()&#123; int cas,o=0; scanf("%d",&amp;cas); while(cas--&amp;&amp;scanf("%s %s",&amp;S,&amp;T))&#123; int n=strlen(S); int m=strlen(T); int L=0,R=0,t=0,Lcnt=0,Rcnt=0,leaf=1,ans=0; for(int i=0;i&lt;n;i++) if(t&amp;&amp;S[i]=='U')t--; else S[t++]=S[i]; n=t;t=0; for(int i=0;i&lt;m;i++)t+=(T[i]=='U'); t=n-t; for(int i=m-1;i&gt;=0;i--)&#123; if(T[i]=='L')&#123; Mod(L,leaf); Mod(L,Lcnt); Mod(Rcnt,leaf); Mod(leaf,Lcnt); Lcnt=0; &#125; else if(T[i]=='R')&#123; Mod(R,leaf); Mod(R,Rcnt); Mod(Lcnt,leaf); Mod(leaf,Rcnt); Rcnt=0; &#125; else if(t&lt;n)&#123; t++; if(t&lt;=0)continue; if(S[t-1]=='L')Mod(ans,(R+1)%P); else Mod(ans,(L+1)%P); &#125; &#125; Mod(ans,(L+R+1)%P); printf("Case %d: %d\n",++o,ans); &#125; return 0;&#125;]]></content>
      <categories>
        <category>计算机</category>
        <category>程序</category>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>字符串</tag>
        <tag>trie树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SWERC 2013 F Odd and Even Zeroes]]></title>
    <url>%2FSWERC%202013%20F%20Odd%20and%20Even%20Zeroes.html</url>
    <content type="text"><![CDATA[task在数学中，一个数n的阶乘写作n!，且定义如下：$n! = 1 × 2 × 3 × 4 × $• • • $× (n − 1) × n =\prod_{i=1}^N i$0!被认为是1。n!将会随着n迅速增长。如下一些数的阶乘：0! = 1 5! = 1201! = 1 10! = 36288002! = 2 14! = 871782912003! = 6 18! = 64023737057280004! = 24 22! = 1124000727777607680000通过观察可以发现，有些数的阶乘末尾中有奇数个零(即5！和18！)，而有些数的阶乘的末尾中有偶数个零(即0！，10！，20！)。那么问题来了，给定一个数n，求在1~n中有多少数的阶乘的末尾有偶数个0？$n&lt;=10^{18}$ solution首先我们需要知道怎样的数字的阶乘是可以有偶数个零。肯定是是由偶数个10相乘，而10=2*5，所以我们只用统计2和5的因子的个数，看一下它们是否能够组成偶数个10，那么10的个数一定是根据个数较少的那个因子判定的，而在一个数的阶乘当中因子2的个数总是不少于5的，所以我们就只用统计n的阶乘中5的个数。那么怎么统计呢？最暴力的写法就是用字母那题的方法判断，一个数我们可以算的很快，但是我们需要1~n的所有的数的阶乘中因子5的个数，而n最大可达$10^{18}$，显然会超时。原先我想着用数学的方法去写，但是随着想法越来越复杂，只能放弃。对于判断一个数的阶乘是否有偶数个5，正解有更好的方法：以530为例，我们将其转化为5进制，即4110，而1~530中为5的倍数的数用411(5进制)个，为25的倍数的有41(5进制)个，为125的倍数的有4(5进制)个，那么我们可以发现当411的每一位数字之和为偶数的话，那么1~530中就有偶数个数为5的倍数。25，和125都可以以此类推。所以接下来我们就可以用数位dp来计算个数了。$dp[f][p][pre][x]$表示当前数字是第x位时，前面几位上的数字这和的末位的奇偶性为pre，p为前面几位时的pre之和的奇偶性。如果前面有一位的数字是小于n那一位上的数字，那么接下来取什么数字，都将小于n，所以我们需要一个f，来判断当前数字是否可以随便取。记忆化搜索的边界是但x&lt;0时，只有p=0时，才说明是有偶数个5，我们返回一个1. Code1234567891011121314151617181920212223242526272829303132333435363738#include &lt;iostream&gt;#include &lt;string.h&gt;#include &lt;algorithm&gt;#define ll long longusing namespace std;int num[30];ll dp[2][2][2][27];ll dfs(int x,int f,int p,int pre)&#123;//x-th digit,have or haven't limit,parity,the sum of pre x digit's parity if(x&lt;0)return p==0; ll &amp;t=dp[f][p][pre][x]; if(t==-1)&#123; t=0; if(f)&#123; for(int i=0;i&lt;=num[x];i++) t+=dfs(x-1,i==num[x],(p+pre+i)&amp;1,(pre+i)&amp;1); &#125; else &#123; for(int i=0;i&lt;5;i++) t+=dfs(x-1,0,(p+pre+i)&amp;1,(pre+i)&amp;1); &#125; &#125;return t;&#125;ll solve(ll n)&#123; if(n&lt;5)return n+1; int c=0; while(n)num[c++]=n%5,n/=5; memset(dp,-1,sizeof(dp)); return dfs(c-1,1,0,0);&#125;int main()&#123; ll n; while(1)&#123; cin&gt;&gt;n; if(n==-1)return 0; cout&lt;&lt;solve(n)&lt;&lt;endl; &#125; return 0;&#125;]]></content>
      <categories>
        <category>计算机</category>
        <category>程序</category>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
        <tag>数位dp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SWERC 2013 D Decoding the Hallway]]></title>
    <url>%2FSWERC%202013%20D%20Decoding%20the%20Hallway.html</url>
    <content type="text"><![CDATA[task爱德华为了恢复国家炼金术师的称号而再次参加试炼，只是今年的试炼内容有点坑。炼金术师们将面对一道长长的直走廊，然后从左边进入，右边出来，这样走n次。每一次，炼金术师们遇到一条直的走廊就按先右后左的顺序将其弯曲，例如： 图1，原先是一条直的走廊(虚线)，现在炼金术师将其弯折向右(实线)。图2，现在走廊由两段直线构成(虚线)，现在炼金术师先将第一段弯折向右，然后第二段向左弯折(实线)。图3，现在现在走廊由四段直线构成(虚线)，现在炼金术师依次按右左右左的顺序弯折4条线段(实线)。在接下去就变成了图4和图5所示。钢之炼金术师爱德华是非常厉害的，所以他非常完美地完成了试炼。现在轮到裁判们去判断他是否做的正确了。裁判将从左进入走廊，然后从右走出走廊。途中，他会记录自己每次转弯的方向，如果向右转，那么就是R，如果向左转就是L。所以当n=1时，该裁判将会记下L。当n=2，该裁判会记下LLR。当n=4是那么裁判写下的就是LLRLLRRLLLRRLRR了。显然字符串的长度会随n的增长而呈指数级增长。他将很难判断这个字符串是否正确。所以现在他会给出一个字符串，只要判断这个字符串是否在原串中即可。n&lt;=1000,s的长度&lt;=100 solution我们把n=1,2,3,4,5时的字符串列出来后，我们可以发现相邻两个字符串之间的联系。 n string 1 L 2 LLR 3 LLRLLRR 4 LLRLLRRLRRLRRLL 5 LLRLLRRLRRLRRLLLRRLRRLLRLLRLLRR 显然对于第i个字符串，就是第i-1个字符串加一个‘L’和将第i-1个字符串中的每个字符取反之后的字符串(L-&gt;R,R-&gt;L)。虽然字符串是随n变大而指数级增长，但是给出的子串的长度只有100.那么是否只要n到达某一值，它就包括了之后所有的字符串中小于等于100分子串？事实证明是的，这个n就等于10。所以我们就可以预处理出n=1,2,3,4,5,6,7,8,9,10时的字符串，然后n小于10的情况我们就可以直接判断，而n&gt;=10的情况我们都在n==10的字符串中判断。至于为什么n等于10，根据每个字符串与上一个串的关系，如果我们将第一个超过100的串设为LLR(即n=7)，接下来的字符串中任意一个长度为100的子串的跨度都不会超过3个字符，那么我们根据上述的表我们可以等出当n==6是，就会出现所有的字符长度为3的字符串，同理可得当n=7+6-2-1=10是就可以出现所有n==100的字符 Code1234567891011121314151617181920212223242526#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;string&gt;#include &lt;algorithm&gt;using namespace std;char str[105];string res[11];int m;void Init()&#123; res[0]="L"; while(++m&lt;9)&#123; int len=res[m-1].size(); for(int i=0;i&lt;len;i++)res[m]+=(i&amp;1?'R':'L'),res[m]+=res[m-1][i]; res[m]+='R'; &#125;&#125;int main()&#123; int T,n,o=0; Init(); scanf("%d",&amp;T); while(T--&amp;&amp;scanf("%d %s",&amp;n,str))&#123; if(~res[min(n,m)-1].find(str))printf("Case %d: Yes\n",++o); else printf("Case %d: No\n",++o); &#125; return 0;&#125;]]></content>
      <categories>
        <category>计算机</category>
        <category>程序</category>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SWERC 2013 B It Can Be Arranged]]></title>
    <url>%2FSWERC%202013%20B%20It%20Can%20Be%20Arranged.html</url>
    <content type="text"><![CDATA[task一所编程学院每天将有n门课程。你将被给定每一门课程的开始和结束时间，以及有多少学生上这门课。当然不会有人愿意一天学两门不同的课。学校将租用一些房间作为学院的教室，每个房间最多只能坐下M个人。由于一个房间上完一节课后会被学生们弄得很脏，所以在第i门课结束后，第j门节课在此教室上课之前，他需要用clean(i,j)的时间去清扫这间教室。为了节省经费，学校想知道最少需要租几间教室，才能满足一天顺利地上完n门课程。 $n&lt;=100$$m,Si &lt;=10000$$Ai,Bi,clean(i,j)&lt;=10000000$ solution由于一间教室可能容不下一节课的所有学生，所以上一节课时我们可能需要多个房间。发现贪心，动规等策略都没什么办法后，我们可以开始考虑建模。显然我们可以把所有的可以放在同一间教室上课的课程之间连一条边。这样我们就构出了一张图，那么我们要怎样在这张图中得出我想要的答案呢？我们可以运用最大流算法，但是我们要求的不是最大而是最小需要的房间，怎么办呢？最小，肯定是在总量中减去最大的，所以我们反过来求最大有都少节课可以在同一间教室上课。对于网络流，首先我们需要一个源点和一个汇点，其次我们还需要将点i拆成i和i+n，防止不合法的两节课连在一起。那么i与源点相连，i+n与汇点相连。至于边的容量，显然与源点和汇点相连的边就是该课程所需要的房间个数。然后其他边就是oo。最后将最多需要的房间量减去这个值就好了。 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#define M 205#define N 10005#define oo 1000000007using namespace std;struct kxj&#123; int t,nxt,c;&#125;E[N&lt;&lt;1];int clean[105][105],A[105],B[105],S[105];int n,Q[M],dis[M],head[M],tot,cur[M];bool mark[105];void Add(int a,int b,int c)&#123; E[tot]=(kxj)&#123;b,head[a],c&#125;;head[a]=tot++; E[tot]=(kxj)&#123;a,head[b],0&#125;;head[b]=tot++;&#125;bool bfs()&#123; for(int i=0;i&lt;=n;i++)dis[i]=-1; int L=0,R=0; Q[R++]=0;dis[0]=0; while(L&lt;R)&#123; int x=Q[L++]; for(int i=head[x];~i;i=E[i].nxt)&#123; int y=E[i].t; if(E[i].c&amp;&amp;dis[y]==-1)&#123; dis[y]=dis[x]+1; Q[R++]=y; &#125; &#125; &#125; return dis[n]!=-1;&#125;int dfs(int x,int flow)&#123; int res=0; if(x==n||flow==0)return flow; for(int &amp;i=cur[x];~i;i=E[i].nxt)&#123; int y=E[i].t; if(E[i].c&amp;&amp;dis[y]==dis[x]+1)&#123; int tmp=dfs(y,min(E[i].c,flow)); E[i].c-=tmp; E[i^1].c+=tmp; flow-=tmp; res+=tmp; if(flow==0)break; &#125; &#125; return res;&#125;int Dinic()&#123; int ans=0; while(bfs())&#123; for(int i=0;i&lt;=n;i++)cur[i]=head[i]; ans+=dfs(0,oo); &#125; return ans;&#125;int main()&#123; int T,m,o=0; scanf("%d",&amp;T); while(T--&amp;&amp;scanf("%d %d",&amp;n,&amp;m))&#123; memset(head,-1,sizeof(head)); memset(mark,0,sizeof(mark)); tot=0; int ans=0; for(int i=1;i&lt;=n;i++)scanf("%d %d %d",A+i,B+i,S+i),S[i]=(S[i]-1)/m+1; for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=n;j++) scanf("%d",&amp;clean[i][j]); for(int i=1;i&lt;=n;i++)&#123; ans+=S[i]; Add(0,i,S[i]); for(int j=1;j&lt;=n;j++) if(A[j]&gt;B[i]+clean[i][j])Add(i,j+n,oo); Add(i+n,n+n+1,S[i]); &#125; n=n+n+1; printf("Case %d: %d\n",++o,ans-Dinic()); &#125; return 0;&#125;]]></content>
      <categories>
        <category>计算机</category>
        <category>程序</category>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>网络流</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SWERC 2013 A Mixing Colours]]></title>
    <url>%2FSWERC%202013%20A%20Mixing%20Colours.html</url>
    <content type="text"><![CDATA[task小C站在路边等车，无聊之余他玩起了合并方块游戏。这n个方块排成一排，每个方块有一个颜色，我们会用一个字符串表示。我们会知道两种颜色可以合并，以及它们合并后的颜色。现在我们要把这n个方块合并成一个方块，但是问题来了，小C是在烈阳下玩的游戏，屏幕的严重反光让他可能看不清每个方块的颜色，所以他只能用上他强大的第六感来预测。小C猜了每个方块可能是什么颜色，为颜色k的可能性用浮点数cer(k)来表示。他想知道最后最有可能得到的颜色是什么。 n,R\le100solution我们很容易发现此题就是石子合并问题，所以我们同样的用动态规划来写。但是这题与经典的石子合并不同，多了颜色这一条件，所以我们的dp状态理所应当的需要在多一维。dp[i][j][k]表示将j~k中的方块合并之后得到颜色i的概率是多少。那么显然转移方程为： dp[c][l][r]=max(dp[c][l][r],dp[a][l][j]*dp[b][j+1][r])dp[c][l][r]=max(dp[c][l][r],dp[b][l][j]*dp[a][j+1][r])其中颜色a与颜色b混合之后得到c，而j∈[l,r)。这样转移的复杂度就是石子合并的n^3在加上枚举所有的关系R，最终复杂度为O(n^3R)需要注意的是为了防止精度丢失或溢出等问题，我们可以将概率取对数，然后可以把相乘的操作改成相加。 Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071#include &lt;cstdio&gt;#include &lt;cmath&gt;#include &lt;string&gt;#include &lt;map&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#define M 305#define N 505#define E 105#define Max(a,b) if(a&lt;(b))a=(b)using namespace std;struct kxj&#123; int a,b,c;&#125;s[E];map&lt;string,int&gt;mp;string color[M],A,B,C;int n,m,R,tot;double dp[M][N][N],cel;int Id(string str)&#123; if(mp[str]==0)&#123; mp[str]=++tot; color[tot]=str; &#125; return mp[str];&#125; int main()&#123; bool flag=0; while(~scanf("%d",&amp;R))&#123; if(flag)puts(""); else flag=1; mp.clear();tot=0; for(int i=1;i&lt;=R;i++)&#123; cin&gt;&gt;A&gt;&gt;B&gt;&gt;C; int x=Id(A),y=Id(B),z=Id(C); s[i]=(kxj)&#123;x,y,z&#125;; &#125; scanf("%d",&amp;m); while(m--&amp;&amp;scanf("%d",&amp;n))&#123; for(int i=1;i&lt;=n;i++) for(int k=1;k&lt;=tot;k++)dp[k][i][i]=-1e99; for(int i=1;i&lt;=n;i++)&#123; while(cin&gt;&gt;A)&#123; if(A=="END")break; scanf("%lf",&amp;cel); int x=mp[A]; dp[x][i][i]=log(cel); &#125; &#125; for(int i=1;i&lt;n;i++)&#123; for(int l=1,r=l+i;r&lt;=n;l++,r++)&#123; for(int k=1;k&lt;=tot;k++)dp[k][l][r]=-1e99; for(int j=l;j&lt;r;j++)&#123; for(int k=1;k&lt;=R;k++)&#123; int a=s[k].a,b=s[k].b,c=s[k].c; Max(dp[c][l][r],dp[a][l][j]+dp[b][j+1][r]); Max(dp[c][l][r],dp[b][l][j]+dp[a][j+1][r]); &#125; &#125; &#125; &#125; double mx=-1e99; int c=-1; for(int i=1;i&lt;=tot;i++)&#123; if(dp[i][1][n]&gt;mx)mx=dp[i][1][n],c=i; &#125; if(c==-1)puts("GAMEOVER"); else cout&lt;&lt;color[c]&lt;&lt;endl; &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>计算机</category>
        <category>程序</category>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
        <tag>概率</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Codeforces 599E Sandy and Nuts]]></title>
    <url>%2FCodeforces%20599E%20Sandy%20and%20Nuts.html</url>
    <content type="text"><![CDATA[task给出一棵树的点的数量n，和部分边的数量，以及一个q，q表示给出q个三元组(a,b,c)，满足lca(a,b)=c，求满足这样条件并以1为根的树共有几种。$1&lt;=n&lt;=15$$0&lt;=m&lt;n$$1&lt;=q&lt;=100$ solution这题既然问的是方案数，那么不是搜索就是dp了。搜索显然不可能，那么就是dp了。由于n最多也就是15个点，所以我们可以用状压dp。$dp[x][s]$表示第x个节点为根的子树中点的状况为s的最多方案数。我们可以用递归的方式来写。每次从原状态s中找到一个子集i，然后判断这个子集能否从s中分离，判断条件如下： 在子集i中是否有两个点的lca是x或者有两个点已经与x有一条边，若是则不行。 是否有两个点分别属于i与$s^i$但是它们的lca并不是x，或是他们之间有一条边，若是则不行。 如果成立我们从s中枚举一个子树的根j。当然我们需要判断此点是否可以作为子树的根。判断条件如下： 在子集i中是否有一个点与j的lca不是j，若是则不行。 在子集i中是否有另外一个点与x已有边，若是则不行。 如果成立，那么说明此点可以作为子树的根，那么我们就可以转移了。 Dp[x][s]+=dfs(j,i-1]]></content>
      <categories>
        <category>计算机</category>
        <category>程序</category>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Codeforces 567E Mausoleum]]></title>
    <url>%2FCodeforces%20576E%20Mausoleum.html</url>
    <content type="text"><![CDATA[task有n种底为1*1的长方体，高分别是1到n，而每种长方体只有两个。这种我们要求办这些长方体排成一排，满足前半部分单调不减，后半部分单调不增，两个部分也可以只有一个部分。如以下这些方案：[1, 2, 2, 3, 4, 4, 3, 1];[1, 1];[2, 2, 1, 1];[1, 2, 3, 3, 2, 1].现在我们还有(1&lt;=m&lt;=100)个限制，如x&gt;y,表示第x个长方体的高度大于第y个长方体的高度。这样的限制有5种，分别是”xy”,”x=y”,”x&lt;=y”,”x&gt;=y”。求方案数。$1&lt;=n&lt;=35$$1&lt;=m&lt;=100$ solution一看题目就知道是dp题。 $dp[L][R]$表示区间[L,R]内的方案数。 如果我们从小到大放每种的两个数我们可以知道我们只有三种放法： 两个数都放区间的左边。 两个数都放区间的右边。 一个数放区间的左边，一个数放区间的右边。 而且根据经验，这种状态的dp一般都是用记忆化搜索来写，所以我们状态的转移就是 dp[L][R]=dp[L+2][R]+dp[L][R−2]+dp[L+1][R−1]而边界就是$R-L==1$. 但是这题并不是简单的记忆化搜索，而是还有限制条件的。 对于每个限制条件我们可以把这些数的关系存下来，然后每次转移前都判断一下。 对于所有情况，我们都需要判断一下放的这两个数的位置是否可以相等的关系。 两个数都放区间的左边，然后判断左边已经放的数中(即[1,L+2])是否有与在R位置上的数不满足小于关系的。接着是判断剩余没有放的数中(即[L+3,R])是否有与L和L+1位置上的数不满足大于关系的。 两个数都放区间的右边，然后判断左边已经放的数中(即[R-2,n])是否有与在L位置上的数不满足小于关系的。接着是判断剩余没有放的数中(即[L,R-3])是否有与R和R-1位置上的数不满足大于关系的。 一个数放区间的左边，一个数放区间的右边。那么我们就只用判断只剩余还没有放的数中是否有与L和R上的数不满足大于关系的。 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#define M 80#define ll long longusing namespace std;int n,rel[M][M];ll dp[M][M];int rep(char c)&#123; if(c=='&lt;')return 1; if(c=='&gt;')return 2; return 3;&#125;void Init(char str[])&#123; int len=strlen(str),a,b=0,c,t=1; for(int i=0;i&lt;len;i++)&#123; if(str[i]==' ')&#123; if(t==1)a=b; if(t==2) if(b&gt;10)c=(b==13)?4:5; else c=b; t++;b=0; &#125;else if(str[i]&lt;='9'&amp;&amp;str[i]&gt;='0')b=b*10+str[i]-'0'; else b=b*10+rep(str[i]); &#125; if(a&gt;b)&#123; swap(a,b); if(c&lt;3)c=(c==1)?2:1; if(c&gt;3)c=(c==4)?5:4; &#125; rel[a][b]=c;&#125;bool check1(int L,int R)&#123; if(rel[R][R+1]&amp;&amp;rel[R][R+1]&lt;3)return 0; for(int i=R+1;i&lt;=n;i++) if(rel[L][i]==1||rel[L][i]==3||rel[L][i]==4)return 0; for(int i=L;i&lt;R;i++)&#123; if(rel[i][R]==1||rel[i][R+1]==1)return 0; if(rel[i][R]==3||rel[i][R+1]==3)return 0; if(rel[i][R]==4||rel[i][R+1]==4)return 0; &#125; return !rel[L][R]||rel[L][R]==2||rel[L][R]==5;&#125;bool check2(int L,int R)&#123; if(rel[L-1][L]&amp;&amp;rel[L-1][L]&lt;3)return 0; for(int i=1;i&lt;L;i++) if(rel[i][R]==2||rel[i][R]==3||rel[i][R]==5)return 0; for(int i=L+1;i&lt;=R;i++)&#123; if(rel[L][i]==2||rel[L-1][i]==2)return 0; if(rel[L][i]==3||rel[L-1][i]==3)return 0; if(rel[L][i]==5||rel[L-1][i]==5)return 0; &#125; return !rel[L][R]||rel[L][R]==1||rel[L][R]==4;&#125;bool check3(int L,int R)&#123; for(int i=L+1;i&lt;R;i++)&#123; if(rel[L][i]==2||rel[i][R]==1)return 0; if(rel[L][i]==3||rel[i][R]==3)return 0; if(rel[L][i]==5||rel[i][R]==4)return 0; &#125; return !rel[L][R]||rel[L][R]&gt;2;&#125;ll dfs(int L,int R)&#123; if(R&lt;=L)return 0; if(R-L==1)return rel[L][R]==0||rel[L][R]&gt;2; ll &amp;t=dp[L][R]; if(t==-1)&#123; t=0; if(check1(L,R-1))t+=dfs(L,R-2); if(check2(L+1,R))t+=dfs(L+2,R); if(check3(L,R))t+=dfs(L+1,R-1); &#125; return t;&#125; int main()&#123; memset(dp,-1,sizeof(dp)); int m,i,a,b; char str[10]; scanf("%d %d\n",&amp;n,&amp;m); for(i=1;i&lt;=m;i++)&#123; gets(str); Init(str); &#125;n*=2; cout&lt;&lt;dfs(1,n)&lt;&lt;endl; return 0;&#125;]]></content>
      <categories>
        <category>计算机</category>
        <category>程序</category>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2Fhello-world.html</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
